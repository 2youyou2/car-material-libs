// Effect Syntax Guide: https://docs.cocos.com/creator/manual/zh/shader/index.html

CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: unlit-vs:vert # builtin header
      frag: unlit-fs:frag
      properties: &props
        mainColor:      { value: [1, 1, 1, 1], editor: { type: color } }

        lineWidth: { value: 0.01 }
        # lineCount: { value: 2 }
        xLine: { value: 1 }
        yLine: { value: 0 }

        tilingOffset: { value: [1,1, 0, 0] }
  - name: transparent
    passes:
    - vert: unlit-vs:vert # builtin header
      frag: unlit-fs:frag
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
}%


CCProgram shared-ubo %{
  uniform SharedUBO {
    vec4 tilingOffset;
    float xLine;
    float yLine;
    float lineWidth;
    float lineCount;
  };
}%

CCProgram unlit-vs %{
  precision highp float;
  #include <legacy/input>
  #include <builtin/uniforms/cc-global>
  #include <legacy/decode-base>
  #include <legacy/local-batch>
  #include <legacy/input>
  #include <legacy/fog-vs>

  #if USE_VERTEX_COLOR
    in lowp vec4 a_color;
    out lowp vec4 v_color;
  #endif

  #include <shared-ubo>

  out vec2 v_uv;

  out vec3 v_position;
  out vec3 v_cameraCenteringOffset;

  vec4 vert () {
    vec4 position;
    CCVertInput(position);

    mat4 matWorld;
    CCGetWorldMatrix(matWorld);
    
    vec2 tilingScale = tilingOffset.xy * vec2(xLine, yLine);
    v_uv = (a_texCoord + 0.5 / tilingScale) * tilingScale + tilingOffset.zw;// + 1. / (tilingScale * 2.);// * tilingOffset.xy + tilingOffset.zw;

    #if USE_VERTEX_COLOR
      v_color = a_color;
    #endif

    vec4 worldPos = matWorld * position;
    v_position = worldPos.xyz;

    float division = 1. ;//uMajorGridFactor;
    v_cameraCenteringOffset = floor(cc_cameraPos.xyz / division) * division;

    CC_TRANSFER_FOG(worldPos);
    return cc_matProj * cc_matView * worldPos;
  }
}%

CCProgram unlit-fs %{
  precision highp float;

  #pragma extension([GL_OES_standard_derivatives, __VERSION__ < 110])

  #include <legacy/output>
  #include <legacy/fog-fs>
  #include <common/common-define>

  #include <shared-ubo>

  in vec2 v_uv;
  in vec3 v_position;
  in vec3 v_cameraCenteringOffset;

  uniform Constant {
    vec4 mainColor;
  };



  float gridLine(vec2 uv) {
    float uMajorLineWidth = lineWidth;
    float majorGridSize = 1.;

    vec4 uvDDXY = vec4(dFdx(uv.xy), dFdy(uv.xy));
    vec2 uvDeriv = vec2(length(uvDDXY.xz), length(uvDDXY.yw));
    

    float majorDiv = max(0.1, majorGridSize);
    vec2 majorUVDeriv = uvDeriv / majorDiv;
    float majorLineWidth = uMajorLineWidth / majorDiv;
    vec2 majorDrawWidth = clamp(vec2(majorLineWidth), majorUVDeriv, vec2(0.5));
    vec2 majorLineAA = majorUVDeriv * 1.5;
    vec2 majorGridUV = 1.0 - abs(fract(uv.xy / majorDiv) * 2.0 - 1.0);
    vec2 majorGrid2 = smoothstep(majorDrawWidth + majorLineAA, majorDrawWidth - majorLineAA, majorGridUV);
    majorGrid2 *= saturate(majorLineWidth / majorDrawWidth);
    // majorGrid2 = saturate(majorGrid2 - axisLines2); // hack
    majorGrid2 = mix(majorGrid2, vec2(majorLineWidth), saturate(majorUVDeriv * 2.0 - 1.0));

    float majorGrid = mix(majorGrid2.x, 1.0, majorGrid2.y);

    return majorGrid;
  }
  

  vec4 frag () {
    
    float division = 1. ;//uMajorGridFactor;

    // trick to reduce visual artifacts when far from the world origin
    // vec3 cameraCenteringOffset = floor(cc_cameraPos.xyz / division) * division;


    // return vec4(cameraCenteringOffset, 1.);

    vec2 uv = v_position.xz - v_cameraCenteringOffset.xz;
    vec2 pos = v_position.xz;

    float line = gridLine(v_uv);
    // return vec4(v_uv, 0., 1.);

    vec4 col = mainColor;

    return vec4(col.rgb, col.a * line);

    // vec4 uvDDXY = vec4(dFdx(uv.xy), dFdy(uv.xy));
    // vec2 uvDeriv = vec2(length(uvDDXY.xz), length(uvDDXY.yw));

    // return vec4(uvDeriv, 0., 1.);


    // float axisLineWidth = 0.1;
    // vec2 axisDrawWidth = max(vec2(axisLineWidth), uvDeriv);
    // vec2 axisLineAA = uvDeriv * 1.5;
    // vec2 axisLines2 = smoothstep(axisDrawWidth + axisLineAA, axisDrawWidth - axisLineAA, abs(pos * 2.0));
    // axisLines2 *= clamp(axisLineWidth / axisDrawWidth, 0., 1.);

    // return vec4(vec3(axisLines2.x), 1.);

    // vec4 col = mainColor * texture(mainTexture, v_uv);
    // CC_APPLY_FOG(col, v_position);
    // return CCFragOutput(col);
  }
}%
