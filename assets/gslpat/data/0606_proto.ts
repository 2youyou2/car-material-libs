// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.31.1
// source: assets/gslpat/data/0606_proto.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "DesayALGSerialization";

export interface DrivingSignals {
  accStatusEnum: DrivingSignals_ACCStatus;
  accDistStatusEnum: DrivingSignals_DistRange;
  icaStatusEnum: DrivingSignals_ICAStatus;
  icaDistStatusEnum: DrivingSignals_DistRange;
  userSetSpeedKph: number;
}

export enum DrivingSignals_ACCStatus {
  ACC_OFF = 0,
  ACC_PASSIVE = 1,
  ACC_STANDBY = 2,
  ACC_ACTIVE = 3,
  ACC_STANDSTILL_ACTIVE = 4,
  ACC_STANDSTILL_WAIT = 5,
  ACC_OVERRIDE = 6,
  ACC_BRAKE_ONLY = 7,
  ACC_FAULT = 8,
  ACC_RESERVED = 9,
  UNRECOGNIZED = -1,
}

export function drivingSignals_ACCStatusFromJSON(object: any): DrivingSignals_ACCStatus {
  switch (object) {
    case 0:
    case "ACC_OFF":
      return DrivingSignals_ACCStatus.ACC_OFF;
    case 1:
    case "ACC_PASSIVE":
      return DrivingSignals_ACCStatus.ACC_PASSIVE;
    case 2:
    case "ACC_STANDBY":
      return DrivingSignals_ACCStatus.ACC_STANDBY;
    case 3:
    case "ACC_ACTIVE":
      return DrivingSignals_ACCStatus.ACC_ACTIVE;
    case 4:
    case "ACC_STANDSTILL_ACTIVE":
      return DrivingSignals_ACCStatus.ACC_STANDSTILL_ACTIVE;
    case 5:
    case "ACC_STANDSTILL_WAIT":
      return DrivingSignals_ACCStatus.ACC_STANDSTILL_WAIT;
    case 6:
    case "ACC_OVERRIDE":
      return DrivingSignals_ACCStatus.ACC_OVERRIDE;
    case 7:
    case "ACC_BRAKE_ONLY":
      return DrivingSignals_ACCStatus.ACC_BRAKE_ONLY;
    case 8:
    case "ACC_FAULT":
      return DrivingSignals_ACCStatus.ACC_FAULT;
    case 9:
    case "ACC_RESERVED":
      return DrivingSignals_ACCStatus.ACC_RESERVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DrivingSignals_ACCStatus.UNRECOGNIZED;
  }
}

export function drivingSignals_ACCStatusToJSON(object: DrivingSignals_ACCStatus): string {
  switch (object) {
    case DrivingSignals_ACCStatus.ACC_OFF:
      return "ACC_OFF";
    case DrivingSignals_ACCStatus.ACC_PASSIVE:
      return "ACC_PASSIVE";
    case DrivingSignals_ACCStatus.ACC_STANDBY:
      return "ACC_STANDBY";
    case DrivingSignals_ACCStatus.ACC_ACTIVE:
      return "ACC_ACTIVE";
    case DrivingSignals_ACCStatus.ACC_STANDSTILL_ACTIVE:
      return "ACC_STANDSTILL_ACTIVE";
    case DrivingSignals_ACCStatus.ACC_STANDSTILL_WAIT:
      return "ACC_STANDSTILL_WAIT";
    case DrivingSignals_ACCStatus.ACC_OVERRIDE:
      return "ACC_OVERRIDE";
    case DrivingSignals_ACCStatus.ACC_BRAKE_ONLY:
      return "ACC_BRAKE_ONLY";
    case DrivingSignals_ACCStatus.ACC_FAULT:
      return "ACC_FAULT";
    case DrivingSignals_ACCStatus.ACC_RESERVED:
      return "ACC_RESERVED";
    case DrivingSignals_ACCStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DrivingSignals_ICAStatus {
  ICA_OFF = 0,
  ICA_PASSIVE = 1,
  ICA_STANDBY = 2,
  ICA_ACTIVE = 3,
  ICA_OVERRIDE = 4,
  ICA_FAULT = 5,
  ICA_RESERVED = 6,
  UNRECOGNIZED = -1,
}

export function drivingSignals_ICAStatusFromJSON(object: any): DrivingSignals_ICAStatus {
  switch (object) {
    case 0:
    case "ICA_OFF":
      return DrivingSignals_ICAStatus.ICA_OFF;
    case 1:
    case "ICA_PASSIVE":
      return DrivingSignals_ICAStatus.ICA_PASSIVE;
    case 2:
    case "ICA_STANDBY":
      return DrivingSignals_ICAStatus.ICA_STANDBY;
    case 3:
    case "ICA_ACTIVE":
      return DrivingSignals_ICAStatus.ICA_ACTIVE;
    case 4:
    case "ICA_OVERRIDE":
      return DrivingSignals_ICAStatus.ICA_OVERRIDE;
    case 5:
    case "ICA_FAULT":
      return DrivingSignals_ICAStatus.ICA_FAULT;
    case 6:
    case "ICA_RESERVED":
      return DrivingSignals_ICAStatus.ICA_RESERVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DrivingSignals_ICAStatus.UNRECOGNIZED;
  }
}

export function drivingSignals_ICAStatusToJSON(object: DrivingSignals_ICAStatus): string {
  switch (object) {
    case DrivingSignals_ICAStatus.ICA_OFF:
      return "ICA_OFF";
    case DrivingSignals_ICAStatus.ICA_PASSIVE:
      return "ICA_PASSIVE";
    case DrivingSignals_ICAStatus.ICA_STANDBY:
      return "ICA_STANDBY";
    case DrivingSignals_ICAStatus.ICA_ACTIVE:
      return "ICA_ACTIVE";
    case DrivingSignals_ICAStatus.ICA_OVERRIDE:
      return "ICA_OVERRIDE";
    case DrivingSignals_ICAStatus.ICA_FAULT:
      return "ICA_FAULT";
    case DrivingSignals_ICAStatus.ICA_RESERVED:
      return "ICA_RESERVED";
    case DrivingSignals_ICAStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DrivingSignals_DistRange {
  DISTRANGE_OFF = 0,
  DISTRANGE_SHORTEST_RANGE = 1,
  DISTRANGE_SHORT_RANGE = 2,
  DISTRANGE_MIDDLE_RANGE = 3,
  DISTRANGE_LONG_RANGE = 4,
  DISTRANGE_LONGEST_RANGE = 5,
  UNRECOGNIZED = -1,
}

export function drivingSignals_DistRangeFromJSON(object: any): DrivingSignals_DistRange {
  switch (object) {
    case 0:
    case "DISTRANGE_OFF":
      return DrivingSignals_DistRange.DISTRANGE_OFF;
    case 1:
    case "DISTRANGE_SHORTEST_RANGE":
      return DrivingSignals_DistRange.DISTRANGE_SHORTEST_RANGE;
    case 2:
    case "DISTRANGE_SHORT_RANGE":
      return DrivingSignals_DistRange.DISTRANGE_SHORT_RANGE;
    case 3:
    case "DISTRANGE_MIDDLE_RANGE":
      return DrivingSignals_DistRange.DISTRANGE_MIDDLE_RANGE;
    case 4:
    case "DISTRANGE_LONG_RANGE":
      return DrivingSignals_DistRange.DISTRANGE_LONG_RANGE;
    case 5:
    case "DISTRANGE_LONGEST_RANGE":
      return DrivingSignals_DistRange.DISTRANGE_LONGEST_RANGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DrivingSignals_DistRange.UNRECOGNIZED;
  }
}

export function drivingSignals_DistRangeToJSON(object: DrivingSignals_DistRange): string {
  switch (object) {
    case DrivingSignals_DistRange.DISTRANGE_OFF:
      return "DISTRANGE_OFF";
    case DrivingSignals_DistRange.DISTRANGE_SHORTEST_RANGE:
      return "DISTRANGE_SHORTEST_RANGE";
    case DrivingSignals_DistRange.DISTRANGE_SHORT_RANGE:
      return "DISTRANGE_SHORT_RANGE";
    case DrivingSignals_DistRange.DISTRANGE_MIDDLE_RANGE:
      return "DISTRANGE_MIDDLE_RANGE";
    case DrivingSignals_DistRange.DISTRANGE_LONG_RANGE:
      return "DISTRANGE_LONG_RANGE";
    case DrivingSignals_DistRange.DISTRANGE_LONGEST_RANGE:
      return "DISTRANGE_LONGEST_RANGE";
    case DrivingSignals_DistRange.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface HmiSignals {
  iteractionTargetId: number[];
  iteractionTargetTagEnum: HmiSignals_IteractionTargetTag[];
  trafficLightTypeEnum: HmiSignals_TrafficLightType;
  trafficLightColorEnum: HmiSignals_TrafficLightColor;
  egoLaneId: number;
  targetLaneId: number;
  accInfoEnum: number;
  accWarningEnum: number;
  accFaultEnum: number;
  icaInfoEnum: number;
  icaWarningEnum: number;
  icaFaultEnum: number;
  ncaInfoEnum: number;
  ncaWarningEnum: number;
  ncaFaultEnum: number;
}

export enum HmiSignals_IteractionTargetTag {
  OFF = 0,
  NORMAL_FOLLOWING = 1,
  CUTIN_IN_PROGRESS = 2,
  POTENTIAL_CRASH_ALERT = 3,
  IN_ROAD_SIDESHIFT = 4,
  RESERVED = 5,
  UNRECOGNIZED = -1,
}

export function hmiSignals_IteractionTargetTagFromJSON(object: any): HmiSignals_IteractionTargetTag {
  switch (object) {
    case 0:
    case "OFF":
      return HmiSignals_IteractionTargetTag.OFF;
    case 1:
    case "NORMAL_FOLLOWING":
      return HmiSignals_IteractionTargetTag.NORMAL_FOLLOWING;
    case 2:
    case "CUTIN_IN_PROGRESS":
      return HmiSignals_IteractionTargetTag.CUTIN_IN_PROGRESS;
    case 3:
    case "POTENTIAL_CRASH_ALERT":
      return HmiSignals_IteractionTargetTag.POTENTIAL_CRASH_ALERT;
    case 4:
    case "IN_ROAD_SIDESHIFT":
      return HmiSignals_IteractionTargetTag.IN_ROAD_SIDESHIFT;
    case 5:
    case "RESERVED":
      return HmiSignals_IteractionTargetTag.RESERVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HmiSignals_IteractionTargetTag.UNRECOGNIZED;
  }
}

export function hmiSignals_IteractionTargetTagToJSON(object: HmiSignals_IteractionTargetTag): string {
  switch (object) {
    case HmiSignals_IteractionTargetTag.OFF:
      return "OFF";
    case HmiSignals_IteractionTargetTag.NORMAL_FOLLOWING:
      return "NORMAL_FOLLOWING";
    case HmiSignals_IteractionTargetTag.CUTIN_IN_PROGRESS:
      return "CUTIN_IN_PROGRESS";
    case HmiSignals_IteractionTargetTag.POTENTIAL_CRASH_ALERT:
      return "POTENTIAL_CRASH_ALERT";
    case HmiSignals_IteractionTargetTag.IN_ROAD_SIDESHIFT:
      return "IN_ROAD_SIDESHIFT";
    case HmiSignals_IteractionTargetTag.RESERVED:
      return "RESERVED";
    case HmiSignals_IteractionTargetTag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum HmiSignals_TrafficLightType {
  TYPE_UNKNOWN = 0,
  TYPE_FORWARD = 1,
  TYPE_LEFT_TURN = 2,
  TYPE_RIGHT_TURN = 3,
  TYPE_CIRCLE = 4,
  TYPE_RESERVED = 5,
  UNRECOGNIZED = -1,
}

export function hmiSignals_TrafficLightTypeFromJSON(object: any): HmiSignals_TrafficLightType {
  switch (object) {
    case 0:
    case "TYPE_UNKNOWN":
      return HmiSignals_TrafficLightType.TYPE_UNKNOWN;
    case 1:
    case "TYPE_FORWARD":
      return HmiSignals_TrafficLightType.TYPE_FORWARD;
    case 2:
    case "TYPE_LEFT_TURN":
      return HmiSignals_TrafficLightType.TYPE_LEFT_TURN;
    case 3:
    case "TYPE_RIGHT_TURN":
      return HmiSignals_TrafficLightType.TYPE_RIGHT_TURN;
    case 4:
    case "TYPE_CIRCLE":
      return HmiSignals_TrafficLightType.TYPE_CIRCLE;
    case 5:
    case "TYPE_RESERVED":
      return HmiSignals_TrafficLightType.TYPE_RESERVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HmiSignals_TrafficLightType.UNRECOGNIZED;
  }
}

export function hmiSignals_TrafficLightTypeToJSON(object: HmiSignals_TrafficLightType): string {
  switch (object) {
    case HmiSignals_TrafficLightType.TYPE_UNKNOWN:
      return "TYPE_UNKNOWN";
    case HmiSignals_TrafficLightType.TYPE_FORWARD:
      return "TYPE_FORWARD";
    case HmiSignals_TrafficLightType.TYPE_LEFT_TURN:
      return "TYPE_LEFT_TURN";
    case HmiSignals_TrafficLightType.TYPE_RIGHT_TURN:
      return "TYPE_RIGHT_TURN";
    case HmiSignals_TrafficLightType.TYPE_CIRCLE:
      return "TYPE_CIRCLE";
    case HmiSignals_TrafficLightType.TYPE_RESERVED:
      return "TYPE_RESERVED";
    case HmiSignals_TrafficLightType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum HmiSignals_TrafficLightColor {
  COLOR_UNKNOWN = 0,
  COLOR_RED = 1,
  COLOR_YELLOW = 2,
  COLOR_GREEN = 3,
  COLOR_BLACK = 4,
  COLOR_RESERVED = 5,
  UNRECOGNIZED = -1,
}

export function hmiSignals_TrafficLightColorFromJSON(object: any): HmiSignals_TrafficLightColor {
  switch (object) {
    case 0:
    case "COLOR_UNKNOWN":
      return HmiSignals_TrafficLightColor.COLOR_UNKNOWN;
    case 1:
    case "COLOR_RED":
      return HmiSignals_TrafficLightColor.COLOR_RED;
    case 2:
    case "COLOR_YELLOW":
      return HmiSignals_TrafficLightColor.COLOR_YELLOW;
    case 3:
    case "COLOR_GREEN":
      return HmiSignals_TrafficLightColor.COLOR_GREEN;
    case 4:
    case "COLOR_BLACK":
      return HmiSignals_TrafficLightColor.COLOR_BLACK;
    case 5:
    case "COLOR_RESERVED":
      return HmiSignals_TrafficLightColor.COLOR_RESERVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HmiSignals_TrafficLightColor.UNRECOGNIZED;
  }
}

export function hmiSignals_TrafficLightColorToJSON(object: HmiSignals_TrafficLightColor): string {
  switch (object) {
    case HmiSignals_TrafficLightColor.COLOR_UNKNOWN:
      return "COLOR_UNKNOWN";
    case HmiSignals_TrafficLightColor.COLOR_RED:
      return "COLOR_RED";
    case HmiSignals_TrafficLightColor.COLOR_YELLOW:
      return "COLOR_YELLOW";
    case HmiSignals_TrafficLightColor.COLOR_GREEN:
      return "COLOR_GREEN";
    case HmiSignals_TrafficLightColor.COLOR_BLACK:
      return "COLOR_BLACK";
    case HmiSignals_TrafficLightColor.COLOR_RESERVED:
      return "COLOR_RESERVED";
    case HmiSignals_TrafficLightColor.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PanelSignals {
  drivingCruisingPanel: DrivingCruisingPanel | undefined;
  parkingPanel: ParkingPanel | undefined;
}

export interface DrivingCruisingPanel {
  /** 行车巡航功能SR */
  drivingCruisingFuncSr:
    | DrivingCruisingFunctionSR
    | undefined;
  /** 行车巡航功能图标显示状态 */
  drivingCruisingFuncIcon:
    | DrivingCruisingFunctionIcon
    | undefined;
  /** 行车巡航功能开关状态反馈 */
  drivingCruisingFuncSwitch:
    | DrivingCruisingFunctionSwitch
    | undefined;
  /** 行车巡航功能文言提示 */
  drivingCruisingFuncTxt:
    | DrivingCruisingFunctionText
    | undefined;
  /** 行车巡航功能状态机 */
  drivingCruisingFuncSts: DrivingCruisingFunctionStatus | undefined;
}

export interface DrivingCruisingFunctionStatus {
  /** 记忆行车功能状态机 */
  mcaStsEnum: number;
}

export interface DrivingCruisingFunctionText {
  accDispInfoEnum: number;
  accPassiveReasonEnum: number;
  accFailureReasonEnum: number;
  icaDispInfoEnum: number;
  ncaDispInfoEnum: number;
  /** 巡航功能文言提示 */
  drivingDispInfoEnum: number;
  /** 巡航功能异常退出原因 */
  drivingAbortReasonEnum: number;
  /** 巡航功能故障原因 */
  drivingFailureReasonEnum: number;
  /** 巡航功能被抑制原因 */
  drivingPassiveReasonEnum: number;
}

export interface DrivingCruisingFunctionIcon {
  accIconColorEnum: number;
  icaIconColorEnum: number;
  ncaIconColorEnum: number;
  accCruiseSpeedIconKmH: number;
  /** MCA地图创建按钮状态 */
  mcaMapBuildButtonEnum: number;
  /** MCA完成地图学习按钮状态 */
  mcaMapBuildConfirmButtonEnum: number;
  /** MCA退出按钮状态 */
  mcaExitButtonEnum: number;
  /** MCA与ICA切换按钮状态 */
  mcaToIcaButtonEnum: number;
  /** MCA推荐图标按钮状态 */
  mcaRecommendIconEnum: number;
  /** MCA学习距离 km */
  mcaLearningDistKm: number;
  /** MCA地图创建进度 % */
  mcaMapBuildProcessBar: number;
  /** MCA图标显示 */
  mcaIconColorEnum: number;
}

export interface DrivingCruisingFunctionSwitch {
  accTimeGapRespEnum: number;
}

export interface ParkingPanel {
  /** 泊车功能图标显示状态 */
  parkingFuncIcon:
    | ParkingFunctionIcon
    | undefined;
  /** 泊车功能文本提示 */
  parkingFuncTxt:
    | ParkingFunctionText
    | undefined;
  /** 泊车功能状态机 */
  parkingFuncSts:
    | ParkingFunctionStatus
    | undefined;
  /** 泊车功能软开关 */
  parkingFuncSwitch:
    | ParkingFunctionSwitch
    | undefined;
  /** 泊车功能声音提示 */
  parkingFuncVoice:
    | ParkingFunctionVoice
    | undefined;
  /** 泊车功能渲染信息 */
  parkingFuncSr:
    | ParkingFunctionSR
    | undefined;
  /** 泊车功能分析统计信息 */
  parkingFuncAnalysis: ParkingFunctionAnalysis | undefined;
}

export interface ParkingFunctionIcon {
  /** APA后台搜车位图标 */
  apaBackStageIconEnum: number;
  /** APA子功能模式 */
  apaParkModeEnum: number;
  /** RPA子功能模式 */
  rpaParkModeEnum: number;
  /** HPA子功能模式 */
  hpaParkModeEnum: number;
  /** HPA推荐图标状态 */
  hpaRecommendIconEnum: number;
  /** APA开始泊入按钮状态 */
  apaStartParkInButtonEnum: number;
  /** APA开始泊出按钮状态 */
  apaStartParkOutButtonEnum: number;
  /** APA暂停按钮状态 */
  apaPauseButtonEnum: number;
  /** APA继续按钮状态 */
  apaContinueButtonEnum: number;
  /** APA退出按钮状态 */
  apaExitButtonEnum: number;
  /** HPA泊入地图创建按钮状态 */
  hpaParkInMapBuildButtonEnum: number;
  /** HPA泊出地图创建按钮状态 */
  hpaParkOutMapBuildButtonEnum: number;
  /** HPA泊入地图重新创建按钮状态 */
  hpaParkInMapRebuildButtonEnum: number;
  /** HPA泊出地图重新创建按钮状态 */
  hpaParkOutMapRebuildButtonEnum: number;
  /** HPA泊入按钮状态 */
  hpaParkInButtonEnum: number;
  /** HPA泊出按钮状态 */
  hpaParkOutButtonEnum: number;
  /** HPA暂停按钮状态 */
  hpaPauseButtonEnum: number;
  /** HPA继续按钮状态 */
  hpaContinueButtonEnum: number;
  /** HPA退出按钮状态 */
  hpaExitButtonEnum: number;
  /** HPA可用手机APP控制按钮状态 */
  hpaAppControlButtonEnum: number;
  /** RPA给到APP的车位类型 */
  rpaAppSlotTypeEnum: number;
  /** 自选车位可用性 */
  userDefinedSlotStsEnum: number;
  /** APA当前档位下的剩余距离 */
  apaRemainDistM: number;
  /** APA当前档位下的百分比 */
  apaProcessRatio: number;
  /** APA当前步数 */
  apaCurrentStep: number;
  /** APA总共步数 */
  apaTotalStep: number;
  /** APA总耗时 */
  apaUsedTotalTimeS: number;
  /** HPA已学习路线距离 */
  hpaLearningDistM: number;
  /** HPA剩余路线距离 */
  hpaRemainPathDistM: number;
  /** HPA地图创建百分比 */
  hpaMapBuildProcessRatio: number;
  /** HPA已行驶路线百分比 */
  hpaDrivedProcessRatio: number;
  /** HPA路线总耗时 */
  hpaUsedTotalTimeS: number;
  /** 泊出方向可用性 */
  parkOutDirectionBits: number;
  /** 档位图标显示 */
  apaGearIconEnum: number;
  /** HPA图标显示 */
  hpaIconColorEnum: number;
  /** 关闭按钮显示状态 */
  closeButtonStsEnum: number;
  /** 泊入功能按钮状态 */
  apaParkInButtonEnum: number;
  /** 泊出功能按钮状态 */
  apaParkOutButtonEnum: number;
  /** 自选车位功能按钮状态 */
  apaSelfSelectButtonEnum: number;
  /** 遥控泊车功能按钮状态 */
  rpaButtonEnum: number;
  /** 离车泊车功能按钮状态 */
  lpaButtonEnum: number;
  /** 沿途泊入按钮状态 */
  pawButtonEnum: number;
  /** 泊出路径状态 */
  apaParkOutPathEnum: number;
  /** HPA路线创建确认按钮状态 */
  hpaMapBuildConfirmButtonEnum: number;
  /** HPA路线创建推荐图标 */
  hpaMapBuildRecommandIconEnum: number;
  /** 记忆泊车按钮状态 */
  hpaButtonEnum: number;
  /** 循迹倒车按钮状态 */
  tbaButtonEnum: number;
  /** TBA开始按钮状态 */
  tbaStartParkButtonEnum: number;
  /** TBA暂停按钮状态 */
  tbaPauseButtonEnum: number;
  /** TBA继续按钮状态 */
  tbaContinueButtonEnum: number;
}

export interface ParkingFunctionText {
  /** 泊车功能故障原因 */
  parkingFailureReasonEnum: number;
  /** 泊车功能被抑制原因 */
  parkingPassiveReasonEnum: number;
  /** 泊车功能异常退出原因 */
  parkingAbortReasonEnum: number;
  /** 泊车功能暂停原因 */
  parkingSuspendReasonEnum: number;
  /** 泊车功能文言提示 */
  parkingDispInfoEnum: number;
}

export interface ParkingFunctionStatus {
  /** APA功能状态机 */
  apaStsEnum: number;
  /** RPA功能状态机 */
  rpaStsEnum: number;
  /** HPA功能状态机 */
  hpaStsEnum: number;
  /** MEB功能状态机（低速紧急制动，类似AEB） */
  mebStsEnum: number;
  /** PAS功能状态机（PDC辅助系统） */
  pasStsEnum: number;
  /** TBA功能状态机（通过摄像头） */
  tbaStsEnum: number;
}

export interface ParkingFunctionSwitch {
  /** APA界面显示反馈 */
  apaDispRespEnum: number;
  /** HPA界面显示反馈 */
  hpaDispRespEnum: number;
  /** APA界面显示模式反馈 */
  apaViewModeEnum: number;
  /** 泊出方向反馈 */
  parkOutDirectionRespEnum: number;
  /** APA泊车车速反馈 */
  apaSpdTypeRespEnum: number;
  /** HPA泊车车速反馈 */
  hpaSpdTypeRespEnum: number;
  /** 语音播报类型反馈 */
  parkingVoiceBroadcastTypeRespEnum: number;
}

export interface ParkingFunctionVoice {
  /** APA找到车位提示音 */
  apaSlotFoundPromptEnum: number;
  /** APA语音提示 */
  apaVoiceReminderEnum: number;
}

export interface ParkingFunctionSR {
  /** 效库位数量 */
  parkingSlotNum: number;
  /** 车位信息列表 */
  parkingSlotList: ParkingSlotInfo[];
}

export interface ParkingSlotInfo {
  /** 车位ID */
  slotId: number;
  /** 车位编号 */
  slotNumber: number;
  /** 车位状态 */
  slotStsEnum: number;
  /** 车位类型 */
  slotTypeEnum: number;
  /** 车位来源 */
  slotDetectedEnum: number;
  /** 车位中心点X坐标 */
  slotCentralPointXM: number;
  /** 车位中心点Y坐标 */
  slotCentralPointYM: number;
  /** POI相对于自车X轴的角度 */
  slotYawDeg: number;
  /** POI1和POI2的夹角 */
  slotEdgeDeg: number;
  /** 车位长度 */
  slotLengthM: number;
  /** 车位宽度 */
  slotWidthM: number;
  /** 车位角点P0的X坐标 */
  slotPoint1XM: number;
  /** 车位角点P0的Y坐标 */
  slotPoint1YM: number;
  /** 车位角点P1的X坐标 */
  slotPoint2XM: number;
  /** 车位角点P1的Y坐标 */
  slotPoint2YM: number;
  /** 车位角点P2的X坐标 */
  slotPoint3XM: number;
  /** 车位角点P2的Y坐标 */
  slotPoint3YM: number;
  /** 车位角点P3的X坐标 */
  slotPoint4XM: number;
  /** 车位角点P3的Y坐标 */
  slotPoint4YM: number;
}

export interface ParkingFunctionAnalysis {
  /** APA功能当前点火周期成功泊入次数 */
  apaCurrentCycleSuccTimes: number;
  /** APA功能当前点火周期失败次数 */
  apaCurrentCycleFailtimes: number;
  /** HPA功能当前点火周期成功泊入次数 */
  hpaCurrentCycleSuccTimes: number;
  /** MEB功能当前点火周期激活次数 */
  mebCurrentCycleActimes: number;
  /** 停车场记忆泊车使用次数 */
  hpaUseNumber: number;
  /** 停车场记忆泊车泊入成功次数 */
  hpaParkInSuccessNumber: number;
  /** APA泊车使用次数 */
  apaUseNumber: number;
  /** APA泊车泊入成功次数 */
  apaParkInSuccessNumber: number;
  /** APA泊车泊入成功率 */
  apaParkInSuccessRatio: number;
  /** APA泊入平均时长 */
  apaParkInAverageTimeS: number;
  /** APA泊出平均时长 */
  apaParkOutAverageTimeS: number;
  /** HPA避免行人次数 */
  hpaPedestrianAvoidNumber: number;
  /** HPA通过路口次数 */
  hpaPassJunctionNumber: number;
  /** HPA通过减速带次数 */
  hpaPassSpeedbumpNumber: number;
  /** HPA用户干预次数 */
  hpaUserInterventionNumber: number;
}

export interface AvmPadRequest {
  avmChannelButtonReqEnum: number;
  avmFrontRearWheelReqEnum: number;
  apa360ButtonReqEnum: number;
  apaSettingsVoicePromptReqEnum: number;
  apaSettingsProtocalPromptReqEnum: number;
  apaSettingsTransparentChassisReqEnum: number;
  padVideoChannelEnum: number;
}

export interface ParkingPadRequest {
  /** APA功能激活请求 */
  apaActReqEnum: number;
  /** RPA功能激活请求 */
  rpaActReqEnum: number;
  /** 离车泊入功能激活请求 */
  lpaActReqEnum: number;
  /** APA泊车模式请求 */
  apaParkModeReqEnum: number;
  /** 车头车尾泊入切换请求 */
  apaParkTypeReqEnum: number;
  /** 用户选择车位编号 */
  apaParkSlotSelectId: number;
  /** 开始泊入按钮请求 */
  apaParkInReqEnum: number;
  /** 暂停泊入按钮请求 */
  apaPauseReqEnum: number;
  /** 继续泊入按钮请求 */
  apaContinueReqEnum: number;
  /** 退出按钮请求 */
  apaExitReqEnum: number;
  /** APA泊车车速调节请求 */
  apaSpdTypeReqEnum: number;
  /** 开始泊出按钮请求 */
  apaParkOutReqEnum: number;
  /** 泊出方向请求 */
  apaParkOutDirectionReqEnum: number;
  /** 自选车位角点P0坐标 */
  apaSelfSelectPoint0:
    | Point3f
    | undefined;
  /** 自选车位角点P1坐标 */
  apaSelfSelectPoint1:
    | Point3f
    | undefined;
  /** 自选车位角点P2坐标 */
  apaSelfSelectPoint2:
    | Point3f
    | undefined;
  /** 自选车位角点P3坐标 */
  apaSelfSelectPoint3:
    | Point3f
    | undefined;
  /** 自选车位角度 */
  apaSelfSelectSlotAngleDeg: number;
  /** 自选车位中心点x坐标 */
  apaSelfSelectSlotXM: number;
  /** 自选车位中心点y坐标 */
  apaSelfSelectSlotYM: number;
  /** 自选车位长 */
  apaSelfSelectSlotLengthM: number;
  /** 自选车位宽 */
  apaSelfSelectSlotWidthM: number;
  /** 自选车位是否被拖动 */
  apaMoveSelfSelectEnum: number;
  /** 语音播报类型请求 */
  parkingVoiceBroadcastTypeReqEnum: number;
  /** 记忆泊车功能激活请求 */
  hpaActReqEnum: number;
  /** HPA泊入路线创建按钮请求 */
  hpaParkInMapBuildReqEnum: number;
  /** HPA泊出路线创建按钮请求 */
  hpaParkOutMapBuildReqEnum: number;
  /** HPA泊入路线重新创建按钮请求 */
  hpaParkInMapRebuildReqEnum: number;
  /** HPA泊出路线重新创建按钮请求 */
  hpaParkOutMapRebuildReqEnum: number;
  /** HPA路线创建确认按钮请求 */
  hpaMapBuildConfirmReqEnum: number;
  /** HPA泊入按钮请求 */
  hpaParkInReqEnum: number;
  /** HPA泊出按钮请求 */
  hpaParkOutReqEnum: number;
  /** HPA暂停按钮请求 */
  hpaPauseReqEnum: number;
  /** HPA继续按钮请求 */
  hpaContinueReqEnum: number;
  /** HPA退出按钮请求 */
  hpaExitReqEnum: number;
  /** HPA返回按钮请求 */
  hpaBackReqEnum: number;
  /** 手机APP按钮请求 */
  hpaAppControlReqEnum: number;
  /** HPA泊车车速调节请求 */
  hpaSpdTypeReqEnum: number;
  /** 用户点击HPA地图ID */
  hpaMapId: number;
  /** 地图删除请求 */
  hpaDeleteMapReqEnum: number;
  /** 沿途泊入按钮请求 */
  pawReqEnum: number;
  /** 循迹倒车功能激活请求 */
  tbaActReqEnum: number;
  /** TBA开始按钮请求 */
  tbaStartParkReqEnum: number;
  /** TBA暂停按钮请求 */
  tbaPauseReqEnum: number;
  /** TBA继续按钮请求 */
  tbaContinueReqEnum: number;
  /** PAD界面显示状态 */
  padDisplayModeEnum: number;
}

export interface VehicleSpeed {
  dspVehSpdKph: number;
}

export interface LightStatus {
  /** 左转向灯 */
  isLeftDircnIndLampOn: boolean;
  /** 右转向灯 */
  isRightDircnIndLampOn: boolean;
  /** 远光灯 */
  isMainBeamLightOn: boolean;
  /** 近光灯 */
  isDippedBeamLightOn: boolean;
  /** 前雾灯 */
  isFrtFogLightOn: boolean;
  /** 后雾灯 */
  isRrFogLightOn: boolean;
  /** 左右两侧刹车灯状态 */
  sideBrakeLightStsEnum: number;
  /** 高位刹车灯状态 */
  centreHightBrakeLightStsEnum: number;
}

export interface BrakePedal {
  brkpdlAppdEnum: number;
}

export interface VehicleDynamic {
  /** 自车车速 */
  vehspd:
    | VehicleSpeed
    | undefined;
  /** 车辆加速度 */
  vehaccl:
    | VehicleAcceleration
    | undefined;
  /** 车辆运动状态 */
  movgsts: MovingStatus | undefined;
}

export interface VehicleAcceleration {
  /** 纵向加速度 */
  longAcclMS2: number;
}

export interface VehicleBody {
  /** 自车车灯 */
  lightSts: LightStatus | undefined;
}

export interface MovingStatus {
  /** 车辆静止状态 */
  vehststStsEnum: number;
  /** 车辆静止状态有效性 */
  isVehststStsVld: boolean;
  /** 车辆运动方向 */
  vehMovgDirEnum: number;
}

export interface BrakeSystem {
  brkpdl: BrakePedal | undefined;
}

export interface SteeringSystem {
  /** 方向盘转角 */
  pnnagsaeDeg: number;
}

export interface PowerTrain {
  /** 挡位信息 */
  gear: Gear | undefined;
}

export interface Gear {
  /** 当前挡位有效性 */
  isActvGearVld: boolean;
  /** 当前挡位 */
  actvGearEnum: number;
}

export interface DrivingCruisingFunctionSR {
  laneChangeStepEnum: number;
  iteractionTargetIdList: number[];
  iteractionTargetTagEnumList: number[];
  targetLaneId: number;
  trafficLightTypeEnum: number[];
  trafficLightColorEnum: number[];
  cipvId: number;
  cipvTagEnum: number;
  /** 红绿灯倒计时 */
  trafficLightCountdown: number;
}

export interface FSMNodeInfo {
  drivingModeEnum: FSMNodeInfo_DrivingMode;
  functionStsEnum: number;
}

export enum FSMNodeInfo_DrivingMode {
  NOT_RUNNING = 0,
  APA = 1,
  RPA = 2,
  AVP = 3,
  ACC = 4,
  ICA = 5,
  NCA = 6,
  RESERVED = 7,
  UNRECOGNIZED = -1,
}

export function fSMNodeInfo_DrivingModeFromJSON(object: any): FSMNodeInfo_DrivingMode {
  switch (object) {
    case 0:
    case "NOT_RUNNING":
      return FSMNodeInfo_DrivingMode.NOT_RUNNING;
    case 1:
    case "APA":
      return FSMNodeInfo_DrivingMode.APA;
    case 2:
    case "RPA":
      return FSMNodeInfo_DrivingMode.RPA;
    case 3:
    case "AVP":
      return FSMNodeInfo_DrivingMode.AVP;
    case 4:
    case "ACC":
      return FSMNodeInfo_DrivingMode.ACC;
    case 5:
    case "ICA":
      return FSMNodeInfo_DrivingMode.ICA;
    case 6:
    case "NCA":
      return FSMNodeInfo_DrivingMode.NCA;
    case 7:
    case "RESERVED":
      return FSMNodeInfo_DrivingMode.RESERVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FSMNodeInfo_DrivingMode.UNRECOGNIZED;
  }
}

export function fSMNodeInfo_DrivingModeToJSON(object: FSMNodeInfo_DrivingMode): string {
  switch (object) {
    case FSMNodeInfo_DrivingMode.NOT_RUNNING:
      return "NOT_RUNNING";
    case FSMNodeInfo_DrivingMode.APA:
      return "APA";
    case FSMNodeInfo_DrivingMode.RPA:
      return "RPA";
    case FSMNodeInfo_DrivingMode.AVP:
      return "AVP";
    case FSMNodeInfo_DrivingMode.ACC:
      return "ACC";
    case FSMNodeInfo_DrivingMode.ICA:
      return "ICA";
    case FSMNodeInfo_DrivingMode.NCA:
      return "NCA";
    case FSMNodeInfo_DrivingMode.RESERVED:
      return "RESERVED";
    case FSMNodeInfo_DrivingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Vertex {
  xM: number;
  yM: number;
  zM: number;
  hM: number;
}

export interface CubicCurve {
  startXM: number;
  endXM: number;
  c0: number;
  c1: number;
  c2: number;
  c3: number;
}

export interface SamplingPoint {
  xM: number;
  yM: number;
}

export interface GeometryLine {
  isCurveValid: boolean;
  curve: CubicCurve | undefined;
  isSamplingPointValid: boolean;
  numberOfSamplingPoint: number;
  samplingPointList: SamplingPoint[];
}

export interface StaticElement {
  id: number;
  classEnum: number;
  numOfVertices: number;
  verticesList: Vertex[];
  /** 高度属性 */
  heightPropertyEnum: number;
}

export interface SegLane {
  id: number;
  laneWidthM: number;
  laneGeometry: GeometryLine | undefined;
}

export interface SegLaneLine {
  id: number;
  geometry: GeometryLine | undefined;
}

export interface SegLaneLineAttr {
  startOffsetM: number;
  endOffsetM: number;
  type: SegLaneLineAttr_LineType;
  color: SegLaneLineAttr_Color;
}

export enum SegLaneLineAttr_LineType {
  NONE = 0,
  SOLID_LINE = 1,
  DASHED_LINE = 2,
  LEFT_SOLID_LINE_RIGHT_DASHED_LINE = 3,
  RIGHT_SOLID_LINE_LEFT_DASHED_LINE = 4,
  DOUBLE_SOLID_LINE = 5,
  DOUBLE_DASHED_LINE = 6,
  COMPENSATION = 7,
  BOTTS_LINE = 8,
  VIRTUAL = 9,
  RESERVED = 10,
  CURB = 11,
  GUARDRAIL = 12,
  UNKNOWN = 255,
  UNRECOGNIZED = -1,
}

export function segLaneLineAttr_LineTypeFromJSON(object: any): SegLaneLineAttr_LineType {
  switch (object) {
    case 0:
    case "NONE":
      return SegLaneLineAttr_LineType.NONE;
    case 1:
    case "SOLID_LINE":
      return SegLaneLineAttr_LineType.SOLID_LINE;
    case 2:
    case "DASHED_LINE":
      return SegLaneLineAttr_LineType.DASHED_LINE;
    case 3:
    case "LEFT_SOLID_LINE_RIGHT_DASHED_LINE":
      return SegLaneLineAttr_LineType.LEFT_SOLID_LINE_RIGHT_DASHED_LINE;
    case 4:
    case "RIGHT_SOLID_LINE_LEFT_DASHED_LINE":
      return SegLaneLineAttr_LineType.RIGHT_SOLID_LINE_LEFT_DASHED_LINE;
    case 5:
    case "DOUBLE_SOLID_LINE":
      return SegLaneLineAttr_LineType.DOUBLE_SOLID_LINE;
    case 6:
    case "DOUBLE_DASHED_LINE":
      return SegLaneLineAttr_LineType.DOUBLE_DASHED_LINE;
    case 7:
    case "COMPENSATION":
      return SegLaneLineAttr_LineType.COMPENSATION;
    case 8:
    case "BOTTS_LINE":
      return SegLaneLineAttr_LineType.BOTTS_LINE;
    case 9:
    case "VIRTUAL":
      return SegLaneLineAttr_LineType.VIRTUAL;
    case 10:
    case "RESERVED":
      return SegLaneLineAttr_LineType.RESERVED;
    case 11:
    case "CURB":
      return SegLaneLineAttr_LineType.CURB;
    case 12:
    case "GUARDRAIL":
      return SegLaneLineAttr_LineType.GUARDRAIL;
    case 255:
    case "UNKNOWN":
      return SegLaneLineAttr_LineType.UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SegLaneLineAttr_LineType.UNRECOGNIZED;
  }
}

export function segLaneLineAttr_LineTypeToJSON(object: SegLaneLineAttr_LineType): string {
  switch (object) {
    case SegLaneLineAttr_LineType.NONE:
      return "NONE";
    case SegLaneLineAttr_LineType.SOLID_LINE:
      return "SOLID_LINE";
    case SegLaneLineAttr_LineType.DASHED_LINE:
      return "DASHED_LINE";
    case SegLaneLineAttr_LineType.LEFT_SOLID_LINE_RIGHT_DASHED_LINE:
      return "LEFT_SOLID_LINE_RIGHT_DASHED_LINE";
    case SegLaneLineAttr_LineType.RIGHT_SOLID_LINE_LEFT_DASHED_LINE:
      return "RIGHT_SOLID_LINE_LEFT_DASHED_LINE";
    case SegLaneLineAttr_LineType.DOUBLE_SOLID_LINE:
      return "DOUBLE_SOLID_LINE";
    case SegLaneLineAttr_LineType.DOUBLE_DASHED_LINE:
      return "DOUBLE_DASHED_LINE";
    case SegLaneLineAttr_LineType.COMPENSATION:
      return "COMPENSATION";
    case SegLaneLineAttr_LineType.BOTTS_LINE:
      return "BOTTS_LINE";
    case SegLaneLineAttr_LineType.VIRTUAL:
      return "VIRTUAL";
    case SegLaneLineAttr_LineType.RESERVED:
      return "RESERVED";
    case SegLaneLineAttr_LineType.CURB:
      return "CURB";
    case SegLaneLineAttr_LineType.GUARDRAIL:
      return "GUARDRAIL";
    case SegLaneLineAttr_LineType.UNKNOWN:
      return "UNKNOWN";
    case SegLaneLineAttr_LineType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SegLaneLineAttr_Color {
  COLOR_UNKNOWN = 0,
  COLOR_WHITE = 1,
  COLOR_YELLOW = 2,
  COLOR_BLUE = 3,
  COLOR_RED = 4,
  COLOR_BLACK = 5,
  COLOR_GREEN = 6,
  COLOR_GREY = 7,
  UNRECOGNIZED = -1,
}

export function segLaneLineAttr_ColorFromJSON(object: any): SegLaneLineAttr_Color {
  switch (object) {
    case 0:
    case "COLOR_UNKNOWN":
      return SegLaneLineAttr_Color.COLOR_UNKNOWN;
    case 1:
    case "COLOR_WHITE":
      return SegLaneLineAttr_Color.COLOR_WHITE;
    case 2:
    case "COLOR_YELLOW":
      return SegLaneLineAttr_Color.COLOR_YELLOW;
    case 3:
    case "COLOR_BLUE":
      return SegLaneLineAttr_Color.COLOR_BLUE;
    case 4:
    case "COLOR_RED":
      return SegLaneLineAttr_Color.COLOR_RED;
    case 5:
    case "COLOR_BLACK":
      return SegLaneLineAttr_Color.COLOR_BLACK;
    case 6:
    case "COLOR_GREEN":
      return SegLaneLineAttr_Color.COLOR_GREEN;
    case 7:
    case "COLOR_GREY":
      return SegLaneLineAttr_Color.COLOR_GREY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SegLaneLineAttr_Color.UNRECOGNIZED;
  }
}

export function segLaneLineAttr_ColorToJSON(object: SegLaneLineAttr_Color): string {
  switch (object) {
    case SegLaneLineAttr_Color.COLOR_UNKNOWN:
      return "COLOR_UNKNOWN";
    case SegLaneLineAttr_Color.COLOR_WHITE:
      return "COLOR_WHITE";
    case SegLaneLineAttr_Color.COLOR_YELLOW:
      return "COLOR_YELLOW";
    case SegLaneLineAttr_Color.COLOR_BLUE:
      return "COLOR_BLUE";
    case SegLaneLineAttr_Color.COLOR_RED:
      return "COLOR_RED";
    case SegLaneLineAttr_Color.COLOR_BLACK:
      return "COLOR_BLACK";
    case SegLaneLineAttr_Color.COLOR_GREEN:
      return "COLOR_GREEN";
    case SegLaneLineAttr_Color.COLOR_GREY:
      return "COLOR_GREY";
    case SegLaneLineAttr_Color.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SegRoadEdge {
  id: number;
  geometry: GeometryLine | undefined;
}

export interface Slot {
  slotId: number;
  isSlotBeingOccupied: boolean;
  p0: Point3f | undefined;
  p1: Point3f | undefined;
  p2: Point3f | undefined;
  p3: Point3f | undefined;
  typeEnum: number;
  locationEnum: number;
  /** 车位宽度 */
  widthM: number;
  /** 车位深度 */
  depthM: number;
  /** p0p3和开口边的夹角度数 */
  p0p3AngleRad: number;
  /** p1p2和开口边的夹角度数 */
  p1p2AngleRad: number;
  /** 是否存在轮档 */
  isWheelStopValid: boolean;
  /** 轮档在odom坐标系下位置 */
  wheelStopPosition: Point3f[];
  /** 是否可以释放 */
  isToRelease: boolean;
}

export interface Lane {
  id: number;
  numOfSegLane: number;
  segLaneList: SegLane[];
  numOfSegLaneAttr: number;
  segLaneAttrList: SegLaneAttr[];
  positionEnum: number;
  numOfRightLaneLine: number;
  rightLaneLineIdList: number[];
  numOfLeftLaneLine: number;
  leftLaneLineIdList: number[];
}

export interface SegLaneAttr {
  startOffsetM: number;
  endOffsetM: number;
  laneTypeEnum: number;
}

export interface LaneLine {
  id: number;
  numOfSegLaneLine: number;
  segLaneLineList: SegLaneLine[];
  numOfSegLaneLineAttribute: number;
  segLaneLineAttrList: SegLaneLineAttr[];
  positionEnum: number;
}

export interface RoadEdge {
  id: number;
  numOfSegRoadEdge: number;
  segRoadEdgesList: SegRoadEdge[];
}

export interface Point3f {
  xM: number;
  yM: number;
  zM: number;
}

export interface FusionObject {
  id: number;
  classificationEnum: number;
  posCenterM: Point3f | undefined;
  posRefM: Point3f | undefined;
  yawRad: number;
  isLightFlashing: boolean[];
  /** 运动属性类别 */
  motionTypeEnum: number;
}

export interface LandMarker {
  id: number;
  typeEnum: number;
  position: Point3f | undefined;
  orientationRad: number;
  lengthM: number;
  widthM: number;
}

/** 行车闸机信号 */
export interface LandMarker2 {
  id: number;
  typeEnum: number;
  position: Point3f | undefined;
  orientationRad: number;
  lengthM: number;
  widthM: number;
  /** ETC闸机通行状态 */
  trafficLightStatusEnum: number;
}

export interface ReflineViz {
  xM: number;
  yM: number;
  zM: number;
  leftWidthM: number;
  rightWidthM: number;
}

export interface TrajViz {
  xM: number;
  yM: number;
  zM: number;
  sM: number;
  vMS: number;
}

export interface VehicleTrajectory {
  ptsList: TrajectoryPoint[];
}

export interface TrajectoryPoint {
  xM: number;
  yM: number;
}

export interface Pose {
  /** 位置（米） */
  position:
    | Point3f
    | undefined;
  /** 朝向（四元数） */
  orientation: Quaternion4f | undefined;
}

export interface Quaternion4f {
  x: number;
  y: number;
  z: number;
  w: number;
}

/** 静态障碍物 */
export interface StaticElements {
  numOfElements: number;
  elementsList: StaticElement[];
}

/** 交通车道线,车道,路沿 */
export interface Road {
  numOfLaneLine: number;
  laneLinesList: LaneLine[];
  numOfRoadedge: number;
  roadEdgesList: RoadEdge[];
  numOfLane: number;
  lanesList: Lane[];
}

/** 交通参与者 */
export interface FusionObjects {
  numberOfObjects: number;
  objects: FusionObject[];
}

/** 车位信息 */
export interface SlotsList {
  numOfParkingSlots: number;
  slotsList: Slot[];
}

/** 地面箭头 */
export interface LandMarkers {
  numOfTrafficLandmarkers: number;
  landMarkersList: LandMarker[];
}

/** FSM输出信号 */
export interface FsmOut {
  fsmNodeInfo: FSMNodeInfo | undefined;
  drvSignals: DrivingSignals | undefined;
  hmiSignals: HmiSignals | undefined;
  panelSignals: PanelSignals | undefined;
  prkSignals: ParkingSignals | undefined;
  drvPrkDualInfoEnum: number;
}

/** 自车基础信息 */
export interface VehicleChassis {
  /** 车辆运动状态 */
  vehdyn:
    | VehicleDynamic
    | undefined;
  /** 制动系统状态 */
  brksys:
    | BrakeSystem
    | undefined;
  /** 动力系统状态 */
  pt:
    | PowerTrain
    | undefined;
  /** 转向系统状态 */
  strsys: SteeringSystem | undefined;
}

/** 自车状态信息 */
export interface VehicleStatus {
  vehbody: VehicleBody | undefined;
}

/** 参考线和轨迹线 */
export interface PathInfoHmi {
  numReflineVizPts: number;
  reflineVizPts: ReflineViz[];
  numTrajVizPts: number;
  trajVizPts: TrajViz[];
}

/** HMI请求信息 */
export interface HMIRequest {
  parkingPadReq: ParkingPadRequest | undefined;
  avmPadReq: AvmPadRequest | undefined;
}

/** AVM信号回复 */
export interface AvmPadRespone {
  avmChannelButtonRespEnum: number;
  avmFrontRearWheelRespEnum: number;
  apa360ButtonStsEnum: number;
  apaSettingsRespEnum: number;
}

/** 自车轨迹 */
export interface AutoDriveInfo {
  trajectory: VehicleTrajectory | undefined;
}

/** DR信号 */
export interface Odometry {
  /** 位姿 */
  pose:
    | Pose
    | undefined;
  /** dr状态 */
  statusBits: number;
  /** 信号源 */
  sourceBits: number;
  /** 线速度/角速度 */
  twist:
    | Twist
    | undefined;
  /** 加速度 */
  accelaration:
    | Acceleration
    | undefined;
  /** 底盘诊断状态 */
  chassisDiagBits: number;
  /** IMU诊断状态 */
  imuDiagBits: number;
  /** 算法内部参数 */
  internalSignalList: number[];
}

export interface Twist {
  /** 线速度 */
  linear:
    | Vector3f
    | undefined;
  /** 角速度 */
  angular: Vector3f | undefined;
}

export interface Acceleration {
  /** 线加速度 */
  accelaration: Vector3f | undefined;
}

export interface Vector3f {
  x: number;
  y: number;
  z: number;
}

/** 可通行区域 */
export interface DrivableArea {
  /** grid原点x坐标 */
  originXM: number;
  /** grid原点y坐标 */
  originYM: number;
  /** 数据 dr世界系 size：440x55 */
  data: number[];
}

/** 行车闸机 */
export interface LandMarkers2 {
  numOfTrafficLandmarkers: number;
  landMarkersList: LandMarker2[];
}

/** 泊车信号 */
export interface ParkingSignals {
  /** 车位ID */
  parkingSlotId: number;
  /** hap地图ID */
  hpaMapId: number;
  /** 删除地图ID */
  hpaDeleteMapIp: number;
  /** APA子功能模式 */
  apaParkModeEnum: number;
  /** 泊入方式 */
  parkInTypeEnum: number;
  /** HPA泊入方式 */
  hpaParkInTypeEnum: number;
  /** 开始泊入按钮请求 */
  apaParkInReqEnum: number;
  /** 泊出方向 */
  parkOutDirectionReqEnum: number;
  /** APA泊车车速调节请求 */
  apaSpdTypeReqEnum: number;
  /** 目标车位匹配状态 */
  slotMatchedStsEnum: number;
  /** 自选车位信息 */
  apaSelfSelect:
    | ApaSelfSelect
    | undefined;
  /** 左后视镜状态枚举 */
  leftMirrorStsEnum: number;
  /** 右后视镜状态枚举 */
  rightMirrorStsEnum: number;
}

/** 自选车位信息 */
export interface ApaSelfSelect {
  /** 车位类型: 0x0=None; 0x1=Horizontal; 0x2=Vertical; 0x3=Slant */
  slotTypeEnum: number;
  /** 车位位置: 0x0=None; 0x1=Left; 0x2=Right */
  slotLocationEnum: number;
  /** 自选车位角点P0坐标 */
  apaSelfSelectPoint0:
    | Point3f
    | undefined;
  /** 自选车位角点P1坐标 */
  apaSelfSelectPoint1:
    | Point3f
    | undefined;
  /** 自选车位角点P2坐标 */
  apaSelfSelectPoint2:
    | Point3f
    | undefined;
  /** 自选车位角点P3坐标 */
  apaSelfSelectPoint3:
    | Point3f
    | undefined;
  /** 自选车位角度 */
  apaSelfSelectSlotAngleDeg: number;
  /** 自选车位中心点x坐标 */
  apaSelfSelectSlotXM: number;
  /** 自选车位中心点y坐标 */
  apaSelfSelectSlotYM: number;
  /** 自选车位长度 */
  apaSelfSelectSlotLengthM: number;
  /** 自选车位宽度 */
  apaSelfSelectSlotWidthM: number;
}

/** 泊车轨迹 */
export interface TrajectoryOut {
  /** 轨迹点个数 */
  numTrajPts: number;
  /** 轨迹总长度 */
  totalTrajLengthM: number;
  /** 规划目标速度 */
  targetSpeedMS: number;
  /** 规划目标速度原因 */
  targetSpeedReasonEnum: number;
  /** 有效轨迹点数 */
  trajPtsNum: number;
  /** 轨迹点集 */
  trajPts: PathPoint[];
}

/** 轨迹点集 */
export interface PathPoint {
  /** 相对时间 */
  tS: number;
  /** x坐标(DR系) */
  xM: number;
  /** y坐标(DR系) */
  yM: number;
  /** z坐标(DR系) */
  zM: number;
  /** 航向角(DR系) */
  thetaRad: number;
  /** 曲率 */
  kappaLM: number;
  /** 曲率变化率 */
  dkappaLM: number;
  /** 轨迹点相对距离 */
  sM: number;
  /** 速度 */
  vMS: number;
  /** 加速度 */
  aMS2: number;
  /** 加加速度 */
  daMS3: number;
  /** 档位 */
  gearEnum: number;
}

/** 超声波雷达信息 */
export interface UssPdcData {
  /** 右后边缘的距离信息 */
  ussDistanceRrsMm: number;
  /** 右后侧的距离信息 */
  ussDistanceRrMm: number;
  /** 后右中间的距离信息 */
  ussDistanceRrmMm: number;
  /** 左后中间的距离信息 */
  ussDistanceRlmMm: number;
  /** 左后侧的距离信息 */
  ussDistanceRlMm: number;
  /** 左后边缘的距离信息 */
  ussDistanceRlsMm: number;
  /** 右前边缘的距离信息 */
  ussDistanceFrsMm: number;
  /** 右前侧的距离信息 */
  ussDistanceFrMm: number;
  /** 右前中间的距离信息 */
  ussDistanceFrmMm: number;
  /** 左前中间的距离信息 */
  ussDistanceFlmMm: number;
  /** 左前侧的距离信息 */
  ussDistanceFlMm: number;
  /** 左前边缘的距离信息 */
  ussDistanceFlsMm: number;
}

/** 激光雷达 */
export interface PointCloud2 {
  /** 点云的高度（行数） */
  height: number;
  /** 点云的宽度（每行的点数） */
  width: number;
  /** 点云字段的描述 */
  fields: PointField[];
  /** 数据是否为大端字节序 */
  isBigendian: boolean;
  /** 每个点的字节数 */
  pointStep: number;
  /** 每行的字节数 */
  rowStep: number;
  /** 点云数据 size is (row_step*height) */
  data: number[];
  /** 点云是否密集（是否包含无效点） */
  isDense: boolean;
}

/** 点云字段的描述 */
export interface PointField {
  /** 字段名称 */
  name: string;
  /** 从点结构的起始位置的偏移量 */
  offset: number;
  /** 数据类型枚举 */
  datatype: number;
  /** 字段中的元素数量 */
  count: number;
}

function createBaseDrivingSignals(): DrivingSignals {
  return { accStatusEnum: 0, accDistStatusEnum: 0, icaStatusEnum: 0, icaDistStatusEnum: 0, userSetSpeedKph: 0 };
}

export const DrivingSignals: MessageFns<DrivingSignals> = {
  encode(message: DrivingSignals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accStatusEnum !== 0) {
      writer.uint32(8).int32(message.accStatusEnum);
    }
    if (message.accDistStatusEnum !== 0) {
      writer.uint32(16).int32(message.accDistStatusEnum);
    }
    if (message.icaStatusEnum !== 0) {
      writer.uint32(24).int32(message.icaStatusEnum);
    }
    if (message.icaDistStatusEnum !== 0) {
      writer.uint32(32).int32(message.icaDistStatusEnum);
    }
    if (message.userSetSpeedKph !== 0) {
      writer.uint32(40).uint32(message.userSetSpeedKph);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrivingSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrivingSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accStatusEnum = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accDistStatusEnum = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.icaStatusEnum = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.icaDistStatusEnum = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.userSetSpeedKph = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrivingSignals {
    return {
      accStatusEnum: isSet(object.accStatusEnum) ? drivingSignals_ACCStatusFromJSON(object.accStatusEnum) : 0,
      accDistStatusEnum: isSet(object.accDistStatusEnum)
        ? drivingSignals_DistRangeFromJSON(object.accDistStatusEnum)
        : 0,
      icaStatusEnum: isSet(object.icaStatusEnum) ? drivingSignals_ICAStatusFromJSON(object.icaStatusEnum) : 0,
      icaDistStatusEnum: isSet(object.icaDistStatusEnum)
        ? drivingSignals_DistRangeFromJSON(object.icaDistStatusEnum)
        : 0,
      userSetSpeedKph: isSet(object.userSetSpeedKph) ? globalThis.Number(object.userSetSpeedKph) : 0,
    };
  },

  toJSON(message: DrivingSignals): unknown {
    const obj: any = {};
    if (message.accStatusEnum !== 0) {
      obj.accStatusEnum = drivingSignals_ACCStatusToJSON(message.accStatusEnum);
    }
    if (message.accDistStatusEnum !== 0) {
      obj.accDistStatusEnum = drivingSignals_DistRangeToJSON(message.accDistStatusEnum);
    }
    if (message.icaStatusEnum !== 0) {
      obj.icaStatusEnum = drivingSignals_ICAStatusToJSON(message.icaStatusEnum);
    }
    if (message.icaDistStatusEnum !== 0) {
      obj.icaDistStatusEnum = drivingSignals_DistRangeToJSON(message.icaDistStatusEnum);
    }
    if (message.userSetSpeedKph !== 0) {
      obj.userSetSpeedKph = Math.round(message.userSetSpeedKph);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrivingSignals>, I>>(base?: I): DrivingSignals {
    return DrivingSignals.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrivingSignals>, I>>(object: I): DrivingSignals {
    const message = createBaseDrivingSignals();
    message.accStatusEnum = object.accStatusEnum ?? 0;
    message.accDistStatusEnum = object.accDistStatusEnum ?? 0;
    message.icaStatusEnum = object.icaStatusEnum ?? 0;
    message.icaDistStatusEnum = object.icaDistStatusEnum ?? 0;
    message.userSetSpeedKph = object.userSetSpeedKph ?? 0;
    return message;
  },
};

function createBaseHmiSignals(): HmiSignals {
  return {
    iteractionTargetId: [],
    iteractionTargetTagEnum: [],
    trafficLightTypeEnum: 0,
    trafficLightColorEnum: 0,
    egoLaneId: 0,
    targetLaneId: 0,
    accInfoEnum: 0,
    accWarningEnum: 0,
    accFaultEnum: 0,
    icaInfoEnum: 0,
    icaWarningEnum: 0,
    icaFaultEnum: 0,
    ncaInfoEnum: 0,
    ncaWarningEnum: 0,
    ncaFaultEnum: 0,
  };
}

export const HmiSignals: MessageFns<HmiSignals> = {
  encode(message: HmiSignals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.iteractionTargetId) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.iteractionTargetTagEnum) {
      writer.int32(v);
    }
    writer.join();
    if (message.trafficLightTypeEnum !== 0) {
      writer.uint32(24).int32(message.trafficLightTypeEnum);
    }
    if (message.trafficLightColorEnum !== 0) {
      writer.uint32(32).int32(message.trafficLightColorEnum);
    }
    if (message.egoLaneId !== 0) {
      writer.uint32(40).uint32(message.egoLaneId);
    }
    if (message.targetLaneId !== 0) {
      writer.uint32(48).uint32(message.targetLaneId);
    }
    if (message.accInfoEnum !== 0) {
      writer.uint32(56).uint32(message.accInfoEnum);
    }
    if (message.accWarningEnum !== 0) {
      writer.uint32(64).uint32(message.accWarningEnum);
    }
    if (message.accFaultEnum !== 0) {
      writer.uint32(72).uint32(message.accFaultEnum);
    }
    if (message.icaInfoEnum !== 0) {
      writer.uint32(80).uint32(message.icaInfoEnum);
    }
    if (message.icaWarningEnum !== 0) {
      writer.uint32(88).uint32(message.icaWarningEnum);
    }
    if (message.icaFaultEnum !== 0) {
      writer.uint32(96).uint32(message.icaFaultEnum);
    }
    if (message.ncaInfoEnum !== 0) {
      writer.uint32(104).uint32(message.ncaInfoEnum);
    }
    if (message.ncaWarningEnum !== 0) {
      writer.uint32(112).uint32(message.ncaWarningEnum);
    }
    if (message.ncaFaultEnum !== 0) {
      writer.uint32(120).uint32(message.ncaFaultEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HmiSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHmiSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.iteractionTargetId.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.iteractionTargetId.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.iteractionTargetTagEnum.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.iteractionTargetTagEnum.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.trafficLightTypeEnum = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.trafficLightColorEnum = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.egoLaneId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.targetLaneId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.accInfoEnum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.accWarningEnum = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.accFaultEnum = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.icaInfoEnum = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.icaWarningEnum = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.icaFaultEnum = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.ncaInfoEnum = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.ncaWarningEnum = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.ncaFaultEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HmiSignals {
    return {
      iteractionTargetId: globalThis.Array.isArray(object?.iteractionTargetId)
        ? object.iteractionTargetId.map((e: any) => globalThis.Number(e))
        : [],
      iteractionTargetTagEnum: globalThis.Array.isArray(object?.iteractionTargetTagEnum)
        ? object.iteractionTargetTagEnum.map((e: any) => hmiSignals_IteractionTargetTagFromJSON(e))
        : [],
      trafficLightTypeEnum: isSet(object.trafficLightTypeEnum)
        ? hmiSignals_TrafficLightTypeFromJSON(object.trafficLightTypeEnum)
        : 0,
      trafficLightColorEnum: isSet(object.trafficLightColorEnum)
        ? hmiSignals_TrafficLightColorFromJSON(object.trafficLightColorEnum)
        : 0,
      egoLaneId: isSet(object.egoLaneId) ? globalThis.Number(object.egoLaneId) : 0,
      targetLaneId: isSet(object.targetLaneId) ? globalThis.Number(object.targetLaneId) : 0,
      accInfoEnum: isSet(object.accInfoEnum) ? globalThis.Number(object.accInfoEnum) : 0,
      accWarningEnum: isSet(object.accWarningEnum) ? globalThis.Number(object.accWarningEnum) : 0,
      accFaultEnum: isSet(object.accFaultEnum) ? globalThis.Number(object.accFaultEnum) : 0,
      icaInfoEnum: isSet(object.icaInfoEnum) ? globalThis.Number(object.icaInfoEnum) : 0,
      icaWarningEnum: isSet(object.icaWarningEnum) ? globalThis.Number(object.icaWarningEnum) : 0,
      icaFaultEnum: isSet(object.icaFaultEnum) ? globalThis.Number(object.icaFaultEnum) : 0,
      ncaInfoEnum: isSet(object.ncaInfoEnum) ? globalThis.Number(object.ncaInfoEnum) : 0,
      ncaWarningEnum: isSet(object.ncaWarningEnum) ? globalThis.Number(object.ncaWarningEnum) : 0,
      ncaFaultEnum: isSet(object.ncaFaultEnum) ? globalThis.Number(object.ncaFaultEnum) : 0,
    };
  },

  toJSON(message: HmiSignals): unknown {
    const obj: any = {};
    if (message.iteractionTargetId?.length) {
      obj.iteractionTargetId = message.iteractionTargetId.map((e) => Math.round(e));
    }
    if (message.iteractionTargetTagEnum?.length) {
      obj.iteractionTargetTagEnum = message.iteractionTargetTagEnum.map((e) => hmiSignals_IteractionTargetTagToJSON(e));
    }
    if (message.trafficLightTypeEnum !== 0) {
      obj.trafficLightTypeEnum = hmiSignals_TrafficLightTypeToJSON(message.trafficLightTypeEnum);
    }
    if (message.trafficLightColorEnum !== 0) {
      obj.trafficLightColorEnum = hmiSignals_TrafficLightColorToJSON(message.trafficLightColorEnum);
    }
    if (message.egoLaneId !== 0) {
      obj.egoLaneId = Math.round(message.egoLaneId);
    }
    if (message.targetLaneId !== 0) {
      obj.targetLaneId = Math.round(message.targetLaneId);
    }
    if (message.accInfoEnum !== 0) {
      obj.accInfoEnum = Math.round(message.accInfoEnum);
    }
    if (message.accWarningEnum !== 0) {
      obj.accWarningEnum = Math.round(message.accWarningEnum);
    }
    if (message.accFaultEnum !== 0) {
      obj.accFaultEnum = Math.round(message.accFaultEnum);
    }
    if (message.icaInfoEnum !== 0) {
      obj.icaInfoEnum = Math.round(message.icaInfoEnum);
    }
    if (message.icaWarningEnum !== 0) {
      obj.icaWarningEnum = Math.round(message.icaWarningEnum);
    }
    if (message.icaFaultEnum !== 0) {
      obj.icaFaultEnum = Math.round(message.icaFaultEnum);
    }
    if (message.ncaInfoEnum !== 0) {
      obj.ncaInfoEnum = Math.round(message.ncaInfoEnum);
    }
    if (message.ncaWarningEnum !== 0) {
      obj.ncaWarningEnum = Math.round(message.ncaWarningEnum);
    }
    if (message.ncaFaultEnum !== 0) {
      obj.ncaFaultEnum = Math.round(message.ncaFaultEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HmiSignals>, I>>(base?: I): HmiSignals {
    return HmiSignals.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HmiSignals>, I>>(object: I): HmiSignals {
    const message = createBaseHmiSignals();
    message.iteractionTargetId = object.iteractionTargetId?.map((e) => e) || [];
    message.iteractionTargetTagEnum = object.iteractionTargetTagEnum?.map((e) => e) || [];
    message.trafficLightTypeEnum = object.trafficLightTypeEnum ?? 0;
    message.trafficLightColorEnum = object.trafficLightColorEnum ?? 0;
    message.egoLaneId = object.egoLaneId ?? 0;
    message.targetLaneId = object.targetLaneId ?? 0;
    message.accInfoEnum = object.accInfoEnum ?? 0;
    message.accWarningEnum = object.accWarningEnum ?? 0;
    message.accFaultEnum = object.accFaultEnum ?? 0;
    message.icaInfoEnum = object.icaInfoEnum ?? 0;
    message.icaWarningEnum = object.icaWarningEnum ?? 0;
    message.icaFaultEnum = object.icaFaultEnum ?? 0;
    message.ncaInfoEnum = object.ncaInfoEnum ?? 0;
    message.ncaWarningEnum = object.ncaWarningEnum ?? 0;
    message.ncaFaultEnum = object.ncaFaultEnum ?? 0;
    return message;
  },
};

function createBasePanelSignals(): PanelSignals {
  return { drivingCruisingPanel: undefined, parkingPanel: undefined };
}

export const PanelSignals: MessageFns<PanelSignals> = {
  encode(message: PanelSignals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.drivingCruisingPanel !== undefined) {
      DrivingCruisingPanel.encode(message.drivingCruisingPanel, writer.uint32(10).fork()).join();
    }
    if (message.parkingPanel !== undefined) {
      ParkingPanel.encode(message.parkingPanel, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PanelSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePanelSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.drivingCruisingPanel = DrivingCruisingPanel.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parkingPanel = ParkingPanel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PanelSignals {
    return {
      drivingCruisingPanel: isSet(object.drivingCruisingPanel)
        ? DrivingCruisingPanel.fromJSON(object.drivingCruisingPanel)
        : undefined,
      parkingPanel: isSet(object.parkingPanel) ? ParkingPanel.fromJSON(object.parkingPanel) : undefined,
    };
  },

  toJSON(message: PanelSignals): unknown {
    const obj: any = {};
    if (message.drivingCruisingPanel !== undefined) {
      obj.drivingCruisingPanel = DrivingCruisingPanel.toJSON(message.drivingCruisingPanel);
    }
    if (message.parkingPanel !== undefined) {
      obj.parkingPanel = ParkingPanel.toJSON(message.parkingPanel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PanelSignals>, I>>(base?: I): PanelSignals {
    return PanelSignals.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PanelSignals>, I>>(object: I): PanelSignals {
    const message = createBasePanelSignals();
    message.drivingCruisingPanel = (object.drivingCruisingPanel !== undefined && object.drivingCruisingPanel !== null)
      ? DrivingCruisingPanel.fromPartial(object.drivingCruisingPanel)
      : undefined;
    message.parkingPanel = (object.parkingPanel !== undefined && object.parkingPanel !== null)
      ? ParkingPanel.fromPartial(object.parkingPanel)
      : undefined;
    return message;
  },
};

function createBaseDrivingCruisingPanel(): DrivingCruisingPanel {
  return {
    drivingCruisingFuncSr: undefined,
    drivingCruisingFuncIcon: undefined,
    drivingCruisingFuncSwitch: undefined,
    drivingCruisingFuncTxt: undefined,
    drivingCruisingFuncSts: undefined,
  };
}

export const DrivingCruisingPanel: MessageFns<DrivingCruisingPanel> = {
  encode(message: DrivingCruisingPanel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.drivingCruisingFuncSr !== undefined) {
      DrivingCruisingFunctionSR.encode(message.drivingCruisingFuncSr, writer.uint32(10).fork()).join();
    }
    if (message.drivingCruisingFuncIcon !== undefined) {
      DrivingCruisingFunctionIcon.encode(message.drivingCruisingFuncIcon, writer.uint32(18).fork()).join();
    }
    if (message.drivingCruisingFuncSwitch !== undefined) {
      DrivingCruisingFunctionSwitch.encode(message.drivingCruisingFuncSwitch, writer.uint32(26).fork()).join();
    }
    if (message.drivingCruisingFuncTxt !== undefined) {
      DrivingCruisingFunctionText.encode(message.drivingCruisingFuncTxt, writer.uint32(34).fork()).join();
    }
    if (message.drivingCruisingFuncSts !== undefined) {
      DrivingCruisingFunctionStatus.encode(message.drivingCruisingFuncSts, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrivingCruisingPanel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrivingCruisingPanel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.drivingCruisingFuncSr = DrivingCruisingFunctionSR.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.drivingCruisingFuncIcon = DrivingCruisingFunctionIcon.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.drivingCruisingFuncSwitch = DrivingCruisingFunctionSwitch.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.drivingCruisingFuncTxt = DrivingCruisingFunctionText.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.drivingCruisingFuncSts = DrivingCruisingFunctionStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrivingCruisingPanel {
    return {
      drivingCruisingFuncSr: isSet(object.drivingCruisingFuncSr)
        ? DrivingCruisingFunctionSR.fromJSON(object.drivingCruisingFuncSr)
        : undefined,
      drivingCruisingFuncIcon: isSet(object.drivingCruisingFuncIcon)
        ? DrivingCruisingFunctionIcon.fromJSON(object.drivingCruisingFuncIcon)
        : undefined,
      drivingCruisingFuncSwitch: isSet(object.drivingCruisingFuncSwitch)
        ? DrivingCruisingFunctionSwitch.fromJSON(object.drivingCruisingFuncSwitch)
        : undefined,
      drivingCruisingFuncTxt: isSet(object.drivingCruisingFuncTxt)
        ? DrivingCruisingFunctionText.fromJSON(object.drivingCruisingFuncTxt)
        : undefined,
      drivingCruisingFuncSts: isSet(object.drivingCruisingFuncSts)
        ? DrivingCruisingFunctionStatus.fromJSON(object.drivingCruisingFuncSts)
        : undefined,
    };
  },

  toJSON(message: DrivingCruisingPanel): unknown {
    const obj: any = {};
    if (message.drivingCruisingFuncSr !== undefined) {
      obj.drivingCruisingFuncSr = DrivingCruisingFunctionSR.toJSON(message.drivingCruisingFuncSr);
    }
    if (message.drivingCruisingFuncIcon !== undefined) {
      obj.drivingCruisingFuncIcon = DrivingCruisingFunctionIcon.toJSON(message.drivingCruisingFuncIcon);
    }
    if (message.drivingCruisingFuncSwitch !== undefined) {
      obj.drivingCruisingFuncSwitch = DrivingCruisingFunctionSwitch.toJSON(message.drivingCruisingFuncSwitch);
    }
    if (message.drivingCruisingFuncTxt !== undefined) {
      obj.drivingCruisingFuncTxt = DrivingCruisingFunctionText.toJSON(message.drivingCruisingFuncTxt);
    }
    if (message.drivingCruisingFuncSts !== undefined) {
      obj.drivingCruisingFuncSts = DrivingCruisingFunctionStatus.toJSON(message.drivingCruisingFuncSts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrivingCruisingPanel>, I>>(base?: I): DrivingCruisingPanel {
    return DrivingCruisingPanel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrivingCruisingPanel>, I>>(object: I): DrivingCruisingPanel {
    const message = createBaseDrivingCruisingPanel();
    message.drivingCruisingFuncSr =
      (object.drivingCruisingFuncSr !== undefined && object.drivingCruisingFuncSr !== null)
        ? DrivingCruisingFunctionSR.fromPartial(object.drivingCruisingFuncSr)
        : undefined;
    message.drivingCruisingFuncIcon =
      (object.drivingCruisingFuncIcon !== undefined && object.drivingCruisingFuncIcon !== null)
        ? DrivingCruisingFunctionIcon.fromPartial(object.drivingCruisingFuncIcon)
        : undefined;
    message.drivingCruisingFuncSwitch =
      (object.drivingCruisingFuncSwitch !== undefined && object.drivingCruisingFuncSwitch !== null)
        ? DrivingCruisingFunctionSwitch.fromPartial(object.drivingCruisingFuncSwitch)
        : undefined;
    message.drivingCruisingFuncTxt =
      (object.drivingCruisingFuncTxt !== undefined && object.drivingCruisingFuncTxt !== null)
        ? DrivingCruisingFunctionText.fromPartial(object.drivingCruisingFuncTxt)
        : undefined;
    message.drivingCruisingFuncSts =
      (object.drivingCruisingFuncSts !== undefined && object.drivingCruisingFuncSts !== null)
        ? DrivingCruisingFunctionStatus.fromPartial(object.drivingCruisingFuncSts)
        : undefined;
    return message;
  },
};

function createBaseDrivingCruisingFunctionStatus(): DrivingCruisingFunctionStatus {
  return { mcaStsEnum: 0 };
}

export const DrivingCruisingFunctionStatus: MessageFns<DrivingCruisingFunctionStatus> = {
  encode(message: DrivingCruisingFunctionStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcaStsEnum !== 0) {
      writer.uint32(8).uint32(message.mcaStsEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrivingCruisingFunctionStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrivingCruisingFunctionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mcaStsEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrivingCruisingFunctionStatus {
    return { mcaStsEnum: isSet(object.mcaStsEnum) ? globalThis.Number(object.mcaStsEnum) : 0 };
  },

  toJSON(message: DrivingCruisingFunctionStatus): unknown {
    const obj: any = {};
    if (message.mcaStsEnum !== 0) {
      obj.mcaStsEnum = Math.round(message.mcaStsEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrivingCruisingFunctionStatus>, I>>(base?: I): DrivingCruisingFunctionStatus {
    return DrivingCruisingFunctionStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrivingCruisingFunctionStatus>, I>>(
    object: I,
  ): DrivingCruisingFunctionStatus {
    const message = createBaseDrivingCruisingFunctionStatus();
    message.mcaStsEnum = object.mcaStsEnum ?? 0;
    return message;
  },
};

function createBaseDrivingCruisingFunctionText(): DrivingCruisingFunctionText {
  return {
    accDispInfoEnum: 0,
    accPassiveReasonEnum: 0,
    accFailureReasonEnum: 0,
    icaDispInfoEnum: 0,
    ncaDispInfoEnum: 0,
    drivingDispInfoEnum: 0,
    drivingAbortReasonEnum: 0,
    drivingFailureReasonEnum: 0,
    drivingPassiveReasonEnum: 0,
  };
}

export const DrivingCruisingFunctionText: MessageFns<DrivingCruisingFunctionText> = {
  encode(message: DrivingCruisingFunctionText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accDispInfoEnum !== 0) {
      writer.uint32(8).uint32(message.accDispInfoEnum);
    }
    if (message.accPassiveReasonEnum !== 0) {
      writer.uint32(16).uint32(message.accPassiveReasonEnum);
    }
    if (message.accFailureReasonEnum !== 0) {
      writer.uint32(24).uint32(message.accFailureReasonEnum);
    }
    if (message.icaDispInfoEnum !== 0) {
      writer.uint32(32).uint32(message.icaDispInfoEnum);
    }
    if (message.ncaDispInfoEnum !== 0) {
      writer.uint32(40).uint32(message.ncaDispInfoEnum);
    }
    if (message.drivingDispInfoEnum !== 0) {
      writer.uint32(48).uint32(message.drivingDispInfoEnum);
    }
    if (message.drivingAbortReasonEnum !== 0) {
      writer.uint32(56).uint32(message.drivingAbortReasonEnum);
    }
    if (message.drivingFailureReasonEnum !== 0) {
      writer.uint32(64).uint32(message.drivingFailureReasonEnum);
    }
    if (message.drivingPassiveReasonEnum !== 0) {
      writer.uint32(72).uint32(message.drivingPassiveReasonEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrivingCruisingFunctionText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrivingCruisingFunctionText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accDispInfoEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accPassiveReasonEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.accFailureReasonEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.icaDispInfoEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ncaDispInfoEnum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.drivingDispInfoEnum = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.drivingAbortReasonEnum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.drivingFailureReasonEnum = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.drivingPassiveReasonEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrivingCruisingFunctionText {
    return {
      accDispInfoEnum: isSet(object.accDispInfoEnum) ? globalThis.Number(object.accDispInfoEnum) : 0,
      accPassiveReasonEnum: isSet(object.accPassiveReasonEnum) ? globalThis.Number(object.accPassiveReasonEnum) : 0,
      accFailureReasonEnum: isSet(object.accFailureReasonEnum) ? globalThis.Number(object.accFailureReasonEnum) : 0,
      icaDispInfoEnum: isSet(object.icaDispInfoEnum) ? globalThis.Number(object.icaDispInfoEnum) : 0,
      ncaDispInfoEnum: isSet(object.ncaDispInfoEnum) ? globalThis.Number(object.ncaDispInfoEnum) : 0,
      drivingDispInfoEnum: isSet(object.drivingDispInfoEnum) ? globalThis.Number(object.drivingDispInfoEnum) : 0,
      drivingAbortReasonEnum: isSet(object.drivingAbortReasonEnum)
        ? globalThis.Number(object.drivingAbortReasonEnum)
        : 0,
      drivingFailureReasonEnum: isSet(object.drivingFailureReasonEnum)
        ? globalThis.Number(object.drivingFailureReasonEnum)
        : 0,
      drivingPassiveReasonEnum: isSet(object.drivingPassiveReasonEnum)
        ? globalThis.Number(object.drivingPassiveReasonEnum)
        : 0,
    };
  },

  toJSON(message: DrivingCruisingFunctionText): unknown {
    const obj: any = {};
    if (message.accDispInfoEnum !== 0) {
      obj.accDispInfoEnum = Math.round(message.accDispInfoEnum);
    }
    if (message.accPassiveReasonEnum !== 0) {
      obj.accPassiveReasonEnum = Math.round(message.accPassiveReasonEnum);
    }
    if (message.accFailureReasonEnum !== 0) {
      obj.accFailureReasonEnum = Math.round(message.accFailureReasonEnum);
    }
    if (message.icaDispInfoEnum !== 0) {
      obj.icaDispInfoEnum = Math.round(message.icaDispInfoEnum);
    }
    if (message.ncaDispInfoEnum !== 0) {
      obj.ncaDispInfoEnum = Math.round(message.ncaDispInfoEnum);
    }
    if (message.drivingDispInfoEnum !== 0) {
      obj.drivingDispInfoEnum = Math.round(message.drivingDispInfoEnum);
    }
    if (message.drivingAbortReasonEnum !== 0) {
      obj.drivingAbortReasonEnum = Math.round(message.drivingAbortReasonEnum);
    }
    if (message.drivingFailureReasonEnum !== 0) {
      obj.drivingFailureReasonEnum = Math.round(message.drivingFailureReasonEnum);
    }
    if (message.drivingPassiveReasonEnum !== 0) {
      obj.drivingPassiveReasonEnum = Math.round(message.drivingPassiveReasonEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrivingCruisingFunctionText>, I>>(base?: I): DrivingCruisingFunctionText {
    return DrivingCruisingFunctionText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrivingCruisingFunctionText>, I>>(object: I): DrivingCruisingFunctionText {
    const message = createBaseDrivingCruisingFunctionText();
    message.accDispInfoEnum = object.accDispInfoEnum ?? 0;
    message.accPassiveReasonEnum = object.accPassiveReasonEnum ?? 0;
    message.accFailureReasonEnum = object.accFailureReasonEnum ?? 0;
    message.icaDispInfoEnum = object.icaDispInfoEnum ?? 0;
    message.ncaDispInfoEnum = object.ncaDispInfoEnum ?? 0;
    message.drivingDispInfoEnum = object.drivingDispInfoEnum ?? 0;
    message.drivingAbortReasonEnum = object.drivingAbortReasonEnum ?? 0;
    message.drivingFailureReasonEnum = object.drivingFailureReasonEnum ?? 0;
    message.drivingPassiveReasonEnum = object.drivingPassiveReasonEnum ?? 0;
    return message;
  },
};

function createBaseDrivingCruisingFunctionIcon(): DrivingCruisingFunctionIcon {
  return {
    accIconColorEnum: 0,
    icaIconColorEnum: 0,
    ncaIconColorEnum: 0,
    accCruiseSpeedIconKmH: 0,
    mcaMapBuildButtonEnum: 0,
    mcaMapBuildConfirmButtonEnum: 0,
    mcaExitButtonEnum: 0,
    mcaToIcaButtonEnum: 0,
    mcaRecommendIconEnum: 0,
    mcaLearningDistKm: 0,
    mcaMapBuildProcessBar: 0,
    mcaIconColorEnum: 0,
  };
}

export const DrivingCruisingFunctionIcon: MessageFns<DrivingCruisingFunctionIcon> = {
  encode(message: DrivingCruisingFunctionIcon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accIconColorEnum !== 0) {
      writer.uint32(8).uint32(message.accIconColorEnum);
    }
    if (message.icaIconColorEnum !== 0) {
      writer.uint32(16).uint32(message.icaIconColorEnum);
    }
    if (message.ncaIconColorEnum !== 0) {
      writer.uint32(24).uint32(message.ncaIconColorEnum);
    }
    if (message.accCruiseSpeedIconKmH !== 0) {
      writer.uint32(32).uint32(message.accCruiseSpeedIconKmH);
    }
    if (message.mcaMapBuildButtonEnum !== 0) {
      writer.uint32(40).uint32(message.mcaMapBuildButtonEnum);
    }
    if (message.mcaMapBuildConfirmButtonEnum !== 0) {
      writer.uint32(48).uint32(message.mcaMapBuildConfirmButtonEnum);
    }
    if (message.mcaExitButtonEnum !== 0) {
      writer.uint32(56).uint32(message.mcaExitButtonEnum);
    }
    if (message.mcaToIcaButtonEnum !== 0) {
      writer.uint32(64).uint32(message.mcaToIcaButtonEnum);
    }
    if (message.mcaRecommendIconEnum !== 0) {
      writer.uint32(72).uint32(message.mcaRecommendIconEnum);
    }
    if (message.mcaLearningDistKm !== 0) {
      writer.uint32(85).float(message.mcaLearningDistKm);
    }
    if (message.mcaMapBuildProcessBar !== 0) {
      writer.uint32(88).uint32(message.mcaMapBuildProcessBar);
    }
    if (message.mcaIconColorEnum !== 0) {
      writer.uint32(96).uint32(message.mcaIconColorEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrivingCruisingFunctionIcon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrivingCruisingFunctionIcon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accIconColorEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.icaIconColorEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ncaIconColorEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.accCruiseSpeedIconKmH = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.mcaMapBuildButtonEnum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.mcaMapBuildConfirmButtonEnum = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.mcaExitButtonEnum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.mcaToIcaButtonEnum = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.mcaRecommendIconEnum = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.mcaLearningDistKm = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.mcaMapBuildProcessBar = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.mcaIconColorEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrivingCruisingFunctionIcon {
    return {
      accIconColorEnum: isSet(object.accIconColorEnum) ? globalThis.Number(object.accIconColorEnum) : 0,
      icaIconColorEnum: isSet(object.icaIconColorEnum) ? globalThis.Number(object.icaIconColorEnum) : 0,
      ncaIconColorEnum: isSet(object.ncaIconColorEnum) ? globalThis.Number(object.ncaIconColorEnum) : 0,
      accCruiseSpeedIconKmH: isSet(object.accCruiseSpeedIconKmH) ? globalThis.Number(object.accCruiseSpeedIconKmH) : 0,
      mcaMapBuildButtonEnum: isSet(object.mcaMapBuildButtonEnum) ? globalThis.Number(object.mcaMapBuildButtonEnum) : 0,
      mcaMapBuildConfirmButtonEnum: isSet(object.mcaMapBuildConfirmButtonEnum)
        ? globalThis.Number(object.mcaMapBuildConfirmButtonEnum)
        : 0,
      mcaExitButtonEnum: isSet(object.mcaExitButtonEnum) ? globalThis.Number(object.mcaExitButtonEnum) : 0,
      mcaToIcaButtonEnum: isSet(object.mcaToIcaButtonEnum) ? globalThis.Number(object.mcaToIcaButtonEnum) : 0,
      mcaRecommendIconEnum: isSet(object.mcaRecommendIconEnum) ? globalThis.Number(object.mcaRecommendIconEnum) : 0,
      mcaLearningDistKm: isSet(object.mcaLearningDistKm) ? globalThis.Number(object.mcaLearningDistKm) : 0,
      mcaMapBuildProcessBar: isSet(object.mcaMapBuildProcessBar) ? globalThis.Number(object.mcaMapBuildProcessBar) : 0,
      mcaIconColorEnum: isSet(object.mcaIconColorEnum) ? globalThis.Number(object.mcaIconColorEnum) : 0,
    };
  },

  toJSON(message: DrivingCruisingFunctionIcon): unknown {
    const obj: any = {};
    if (message.accIconColorEnum !== 0) {
      obj.accIconColorEnum = Math.round(message.accIconColorEnum);
    }
    if (message.icaIconColorEnum !== 0) {
      obj.icaIconColorEnum = Math.round(message.icaIconColorEnum);
    }
    if (message.ncaIconColorEnum !== 0) {
      obj.ncaIconColorEnum = Math.round(message.ncaIconColorEnum);
    }
    if (message.accCruiseSpeedIconKmH !== 0) {
      obj.accCruiseSpeedIconKmH = Math.round(message.accCruiseSpeedIconKmH);
    }
    if (message.mcaMapBuildButtonEnum !== 0) {
      obj.mcaMapBuildButtonEnum = Math.round(message.mcaMapBuildButtonEnum);
    }
    if (message.mcaMapBuildConfirmButtonEnum !== 0) {
      obj.mcaMapBuildConfirmButtonEnum = Math.round(message.mcaMapBuildConfirmButtonEnum);
    }
    if (message.mcaExitButtonEnum !== 0) {
      obj.mcaExitButtonEnum = Math.round(message.mcaExitButtonEnum);
    }
    if (message.mcaToIcaButtonEnum !== 0) {
      obj.mcaToIcaButtonEnum = Math.round(message.mcaToIcaButtonEnum);
    }
    if (message.mcaRecommendIconEnum !== 0) {
      obj.mcaRecommendIconEnum = Math.round(message.mcaRecommendIconEnum);
    }
    if (message.mcaLearningDistKm !== 0) {
      obj.mcaLearningDistKm = message.mcaLearningDistKm;
    }
    if (message.mcaMapBuildProcessBar !== 0) {
      obj.mcaMapBuildProcessBar = Math.round(message.mcaMapBuildProcessBar);
    }
    if (message.mcaIconColorEnum !== 0) {
      obj.mcaIconColorEnum = Math.round(message.mcaIconColorEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrivingCruisingFunctionIcon>, I>>(base?: I): DrivingCruisingFunctionIcon {
    return DrivingCruisingFunctionIcon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrivingCruisingFunctionIcon>, I>>(object: I): DrivingCruisingFunctionIcon {
    const message = createBaseDrivingCruisingFunctionIcon();
    message.accIconColorEnum = object.accIconColorEnum ?? 0;
    message.icaIconColorEnum = object.icaIconColorEnum ?? 0;
    message.ncaIconColorEnum = object.ncaIconColorEnum ?? 0;
    message.accCruiseSpeedIconKmH = object.accCruiseSpeedIconKmH ?? 0;
    message.mcaMapBuildButtonEnum = object.mcaMapBuildButtonEnum ?? 0;
    message.mcaMapBuildConfirmButtonEnum = object.mcaMapBuildConfirmButtonEnum ?? 0;
    message.mcaExitButtonEnum = object.mcaExitButtonEnum ?? 0;
    message.mcaToIcaButtonEnum = object.mcaToIcaButtonEnum ?? 0;
    message.mcaRecommendIconEnum = object.mcaRecommendIconEnum ?? 0;
    message.mcaLearningDistKm = object.mcaLearningDistKm ?? 0;
    message.mcaMapBuildProcessBar = object.mcaMapBuildProcessBar ?? 0;
    message.mcaIconColorEnum = object.mcaIconColorEnum ?? 0;
    return message;
  },
};

function createBaseDrivingCruisingFunctionSwitch(): DrivingCruisingFunctionSwitch {
  return { accTimeGapRespEnum: 0 };
}

export const DrivingCruisingFunctionSwitch: MessageFns<DrivingCruisingFunctionSwitch> = {
  encode(message: DrivingCruisingFunctionSwitch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accTimeGapRespEnum !== 0) {
      writer.uint32(8).uint32(message.accTimeGapRespEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrivingCruisingFunctionSwitch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrivingCruisingFunctionSwitch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accTimeGapRespEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrivingCruisingFunctionSwitch {
    return { accTimeGapRespEnum: isSet(object.accTimeGapRespEnum) ? globalThis.Number(object.accTimeGapRespEnum) : 0 };
  },

  toJSON(message: DrivingCruisingFunctionSwitch): unknown {
    const obj: any = {};
    if (message.accTimeGapRespEnum !== 0) {
      obj.accTimeGapRespEnum = Math.round(message.accTimeGapRespEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrivingCruisingFunctionSwitch>, I>>(base?: I): DrivingCruisingFunctionSwitch {
    return DrivingCruisingFunctionSwitch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrivingCruisingFunctionSwitch>, I>>(
    object: I,
  ): DrivingCruisingFunctionSwitch {
    const message = createBaseDrivingCruisingFunctionSwitch();
    message.accTimeGapRespEnum = object.accTimeGapRespEnum ?? 0;
    return message;
  },
};

function createBaseParkingPanel(): ParkingPanel {
  return {
    parkingFuncIcon: undefined,
    parkingFuncTxt: undefined,
    parkingFuncSts: undefined,
    parkingFuncSwitch: undefined,
    parkingFuncVoice: undefined,
    parkingFuncSr: undefined,
    parkingFuncAnalysis: undefined,
  };
}

export const ParkingPanel: MessageFns<ParkingPanel> = {
  encode(message: ParkingPanel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parkingFuncIcon !== undefined) {
      ParkingFunctionIcon.encode(message.parkingFuncIcon, writer.uint32(10).fork()).join();
    }
    if (message.parkingFuncTxt !== undefined) {
      ParkingFunctionText.encode(message.parkingFuncTxt, writer.uint32(18).fork()).join();
    }
    if (message.parkingFuncSts !== undefined) {
      ParkingFunctionStatus.encode(message.parkingFuncSts, writer.uint32(26).fork()).join();
    }
    if (message.parkingFuncSwitch !== undefined) {
      ParkingFunctionSwitch.encode(message.parkingFuncSwitch, writer.uint32(34).fork()).join();
    }
    if (message.parkingFuncVoice !== undefined) {
      ParkingFunctionVoice.encode(message.parkingFuncVoice, writer.uint32(42).fork()).join();
    }
    if (message.parkingFuncSr !== undefined) {
      ParkingFunctionSR.encode(message.parkingFuncSr, writer.uint32(50).fork()).join();
    }
    if (message.parkingFuncAnalysis !== undefined) {
      ParkingFunctionAnalysis.encode(message.parkingFuncAnalysis, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingPanel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingPanel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parkingFuncIcon = ParkingFunctionIcon.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parkingFuncTxt = ParkingFunctionText.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parkingFuncSts = ParkingFunctionStatus.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parkingFuncSwitch = ParkingFunctionSwitch.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parkingFuncVoice = ParkingFunctionVoice.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.parkingFuncSr = ParkingFunctionSR.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.parkingFuncAnalysis = ParkingFunctionAnalysis.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingPanel {
    return {
      parkingFuncIcon: isSet(object.parkingFuncIcon) ? ParkingFunctionIcon.fromJSON(object.parkingFuncIcon) : undefined,
      parkingFuncTxt: isSet(object.parkingFuncTxt) ? ParkingFunctionText.fromJSON(object.parkingFuncTxt) : undefined,
      parkingFuncSts: isSet(object.parkingFuncSts) ? ParkingFunctionStatus.fromJSON(object.parkingFuncSts) : undefined,
      parkingFuncSwitch: isSet(object.parkingFuncSwitch)
        ? ParkingFunctionSwitch.fromJSON(object.parkingFuncSwitch)
        : undefined,
      parkingFuncVoice: isSet(object.parkingFuncVoice)
        ? ParkingFunctionVoice.fromJSON(object.parkingFuncVoice)
        : undefined,
      parkingFuncSr: isSet(object.parkingFuncSr) ? ParkingFunctionSR.fromJSON(object.parkingFuncSr) : undefined,
      parkingFuncAnalysis: isSet(object.parkingFuncAnalysis)
        ? ParkingFunctionAnalysis.fromJSON(object.parkingFuncAnalysis)
        : undefined,
    };
  },

  toJSON(message: ParkingPanel): unknown {
    const obj: any = {};
    if (message.parkingFuncIcon !== undefined) {
      obj.parkingFuncIcon = ParkingFunctionIcon.toJSON(message.parkingFuncIcon);
    }
    if (message.parkingFuncTxt !== undefined) {
      obj.parkingFuncTxt = ParkingFunctionText.toJSON(message.parkingFuncTxt);
    }
    if (message.parkingFuncSts !== undefined) {
      obj.parkingFuncSts = ParkingFunctionStatus.toJSON(message.parkingFuncSts);
    }
    if (message.parkingFuncSwitch !== undefined) {
      obj.parkingFuncSwitch = ParkingFunctionSwitch.toJSON(message.parkingFuncSwitch);
    }
    if (message.parkingFuncVoice !== undefined) {
      obj.parkingFuncVoice = ParkingFunctionVoice.toJSON(message.parkingFuncVoice);
    }
    if (message.parkingFuncSr !== undefined) {
      obj.parkingFuncSr = ParkingFunctionSR.toJSON(message.parkingFuncSr);
    }
    if (message.parkingFuncAnalysis !== undefined) {
      obj.parkingFuncAnalysis = ParkingFunctionAnalysis.toJSON(message.parkingFuncAnalysis);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingPanel>, I>>(base?: I): ParkingPanel {
    return ParkingPanel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingPanel>, I>>(object: I): ParkingPanel {
    const message = createBaseParkingPanel();
    message.parkingFuncIcon = (object.parkingFuncIcon !== undefined && object.parkingFuncIcon !== null)
      ? ParkingFunctionIcon.fromPartial(object.parkingFuncIcon)
      : undefined;
    message.parkingFuncTxt = (object.parkingFuncTxt !== undefined && object.parkingFuncTxt !== null)
      ? ParkingFunctionText.fromPartial(object.parkingFuncTxt)
      : undefined;
    message.parkingFuncSts = (object.parkingFuncSts !== undefined && object.parkingFuncSts !== null)
      ? ParkingFunctionStatus.fromPartial(object.parkingFuncSts)
      : undefined;
    message.parkingFuncSwitch = (object.parkingFuncSwitch !== undefined && object.parkingFuncSwitch !== null)
      ? ParkingFunctionSwitch.fromPartial(object.parkingFuncSwitch)
      : undefined;
    message.parkingFuncVoice = (object.parkingFuncVoice !== undefined && object.parkingFuncVoice !== null)
      ? ParkingFunctionVoice.fromPartial(object.parkingFuncVoice)
      : undefined;
    message.parkingFuncSr = (object.parkingFuncSr !== undefined && object.parkingFuncSr !== null)
      ? ParkingFunctionSR.fromPartial(object.parkingFuncSr)
      : undefined;
    message.parkingFuncAnalysis = (object.parkingFuncAnalysis !== undefined && object.parkingFuncAnalysis !== null)
      ? ParkingFunctionAnalysis.fromPartial(object.parkingFuncAnalysis)
      : undefined;
    return message;
  },
};

function createBaseParkingFunctionIcon(): ParkingFunctionIcon {
  return {
    apaBackStageIconEnum: 0,
    apaParkModeEnum: 0,
    rpaParkModeEnum: 0,
    hpaParkModeEnum: 0,
    hpaRecommendIconEnum: 0,
    apaStartParkInButtonEnum: 0,
    apaStartParkOutButtonEnum: 0,
    apaPauseButtonEnum: 0,
    apaContinueButtonEnum: 0,
    apaExitButtonEnum: 0,
    hpaParkInMapBuildButtonEnum: 0,
    hpaParkOutMapBuildButtonEnum: 0,
    hpaParkInMapRebuildButtonEnum: 0,
    hpaParkOutMapRebuildButtonEnum: 0,
    hpaParkInButtonEnum: 0,
    hpaParkOutButtonEnum: 0,
    hpaPauseButtonEnum: 0,
    hpaContinueButtonEnum: 0,
    hpaExitButtonEnum: 0,
    hpaAppControlButtonEnum: 0,
    rpaAppSlotTypeEnum: 0,
    userDefinedSlotStsEnum: 0,
    apaRemainDistM: 0,
    apaProcessRatio: 0,
    apaCurrentStep: 0,
    apaTotalStep: 0,
    apaUsedTotalTimeS: 0,
    hpaLearningDistM: 0,
    hpaRemainPathDistM: 0,
    hpaMapBuildProcessRatio: 0,
    hpaDrivedProcessRatio: 0,
    hpaUsedTotalTimeS: 0,
    parkOutDirectionBits: 0,
    apaGearIconEnum: 0,
    hpaIconColorEnum: 0,
    closeButtonStsEnum: 0,
    apaParkInButtonEnum: 0,
    apaParkOutButtonEnum: 0,
    apaSelfSelectButtonEnum: 0,
    rpaButtonEnum: 0,
    lpaButtonEnum: 0,
    pawButtonEnum: 0,
    apaParkOutPathEnum: 0,
    hpaMapBuildConfirmButtonEnum: 0,
    hpaMapBuildRecommandIconEnum: 0,
    hpaButtonEnum: 0,
    tbaButtonEnum: 0,
    tbaStartParkButtonEnum: 0,
    tbaPauseButtonEnum: 0,
    tbaContinueButtonEnum: 0,
  };
}

export const ParkingFunctionIcon: MessageFns<ParkingFunctionIcon> = {
  encode(message: ParkingFunctionIcon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apaBackStageIconEnum !== 0) {
      writer.uint32(8).uint32(message.apaBackStageIconEnum);
    }
    if (message.apaParkModeEnum !== 0) {
      writer.uint32(16).uint32(message.apaParkModeEnum);
    }
    if (message.rpaParkModeEnum !== 0) {
      writer.uint32(24).uint32(message.rpaParkModeEnum);
    }
    if (message.hpaParkModeEnum !== 0) {
      writer.uint32(32).uint32(message.hpaParkModeEnum);
    }
    if (message.hpaRecommendIconEnum !== 0) {
      writer.uint32(40).uint32(message.hpaRecommendIconEnum);
    }
    if (message.apaStartParkInButtonEnum !== 0) {
      writer.uint32(48).uint32(message.apaStartParkInButtonEnum);
    }
    if (message.apaStartParkOutButtonEnum !== 0) {
      writer.uint32(56).uint32(message.apaStartParkOutButtonEnum);
    }
    if (message.apaPauseButtonEnum !== 0) {
      writer.uint32(64).uint32(message.apaPauseButtonEnum);
    }
    if (message.apaContinueButtonEnum !== 0) {
      writer.uint32(72).uint32(message.apaContinueButtonEnum);
    }
    if (message.apaExitButtonEnum !== 0) {
      writer.uint32(80).uint32(message.apaExitButtonEnum);
    }
    if (message.hpaParkInMapBuildButtonEnum !== 0) {
      writer.uint32(88).uint32(message.hpaParkInMapBuildButtonEnum);
    }
    if (message.hpaParkOutMapBuildButtonEnum !== 0) {
      writer.uint32(96).uint32(message.hpaParkOutMapBuildButtonEnum);
    }
    if (message.hpaParkInMapRebuildButtonEnum !== 0) {
      writer.uint32(104).uint32(message.hpaParkInMapRebuildButtonEnum);
    }
    if (message.hpaParkOutMapRebuildButtonEnum !== 0) {
      writer.uint32(112).uint32(message.hpaParkOutMapRebuildButtonEnum);
    }
    if (message.hpaParkInButtonEnum !== 0) {
      writer.uint32(120).uint32(message.hpaParkInButtonEnum);
    }
    if (message.hpaParkOutButtonEnum !== 0) {
      writer.uint32(128).uint32(message.hpaParkOutButtonEnum);
    }
    if (message.hpaPauseButtonEnum !== 0) {
      writer.uint32(136).uint32(message.hpaPauseButtonEnum);
    }
    if (message.hpaContinueButtonEnum !== 0) {
      writer.uint32(144).uint32(message.hpaContinueButtonEnum);
    }
    if (message.hpaExitButtonEnum !== 0) {
      writer.uint32(152).uint32(message.hpaExitButtonEnum);
    }
    if (message.hpaAppControlButtonEnum !== 0) {
      writer.uint32(160).uint32(message.hpaAppControlButtonEnum);
    }
    if (message.rpaAppSlotTypeEnum !== 0) {
      writer.uint32(168).uint32(message.rpaAppSlotTypeEnum);
    }
    if (message.userDefinedSlotStsEnum !== 0) {
      writer.uint32(176).uint32(message.userDefinedSlotStsEnum);
    }
    if (message.apaRemainDistM !== 0) {
      writer.uint32(189).float(message.apaRemainDistM);
    }
    if (message.apaProcessRatio !== 0) {
      writer.uint32(192).uint32(message.apaProcessRatio);
    }
    if (message.apaCurrentStep !== 0) {
      writer.uint32(200).uint32(message.apaCurrentStep);
    }
    if (message.apaTotalStep !== 0) {
      writer.uint32(208).uint32(message.apaTotalStep);
    }
    if (message.apaUsedTotalTimeS !== 0) {
      writer.uint32(216).uint32(message.apaUsedTotalTimeS);
    }
    if (message.hpaLearningDistM !== 0) {
      writer.uint32(229).float(message.hpaLearningDistM);
    }
    if (message.hpaRemainPathDistM !== 0) {
      writer.uint32(237).float(message.hpaRemainPathDistM);
    }
    if (message.hpaMapBuildProcessRatio !== 0) {
      writer.uint32(240).uint32(message.hpaMapBuildProcessRatio);
    }
    if (message.hpaDrivedProcessRatio !== 0) {
      writer.uint32(248).uint32(message.hpaDrivedProcessRatio);
    }
    if (message.hpaUsedTotalTimeS !== 0) {
      writer.uint32(256).uint32(message.hpaUsedTotalTimeS);
    }
    if (message.parkOutDirectionBits !== 0) {
      writer.uint32(264).uint32(message.parkOutDirectionBits);
    }
    if (message.apaGearIconEnum !== 0) {
      writer.uint32(272).uint32(message.apaGearIconEnum);
    }
    if (message.hpaIconColorEnum !== 0) {
      writer.uint32(280).uint32(message.hpaIconColorEnum);
    }
    if (message.closeButtonStsEnum !== 0) {
      writer.uint32(288).uint32(message.closeButtonStsEnum);
    }
    if (message.apaParkInButtonEnum !== 0) {
      writer.uint32(296).uint32(message.apaParkInButtonEnum);
    }
    if (message.apaParkOutButtonEnum !== 0) {
      writer.uint32(304).uint32(message.apaParkOutButtonEnum);
    }
    if (message.apaSelfSelectButtonEnum !== 0) {
      writer.uint32(312).uint32(message.apaSelfSelectButtonEnum);
    }
    if (message.rpaButtonEnum !== 0) {
      writer.uint32(320).uint32(message.rpaButtonEnum);
    }
    if (message.lpaButtonEnum !== 0) {
      writer.uint32(328).uint32(message.lpaButtonEnum);
    }
    if (message.pawButtonEnum !== 0) {
      writer.uint32(336).uint32(message.pawButtonEnum);
    }
    if (message.apaParkOutPathEnum !== 0) {
      writer.uint32(344).uint32(message.apaParkOutPathEnum);
    }
    if (message.hpaMapBuildConfirmButtonEnum !== 0) {
      writer.uint32(352).uint32(message.hpaMapBuildConfirmButtonEnum);
    }
    if (message.hpaMapBuildRecommandIconEnum !== 0) {
      writer.uint32(360).uint32(message.hpaMapBuildRecommandIconEnum);
    }
    if (message.hpaButtonEnum !== 0) {
      writer.uint32(368).uint32(message.hpaButtonEnum);
    }
    if (message.tbaButtonEnum !== 0) {
      writer.uint32(376).uint32(message.tbaButtonEnum);
    }
    if (message.tbaStartParkButtonEnum !== 0) {
      writer.uint32(384).uint32(message.tbaStartParkButtonEnum);
    }
    if (message.tbaPauseButtonEnum !== 0) {
      writer.uint32(392).uint32(message.tbaPauseButtonEnum);
    }
    if (message.tbaContinueButtonEnum !== 0) {
      writer.uint32(400).uint32(message.tbaContinueButtonEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingFunctionIcon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingFunctionIcon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.apaBackStageIconEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.apaParkModeEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rpaParkModeEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hpaParkModeEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hpaRecommendIconEnum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.apaStartParkInButtonEnum = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.apaStartParkOutButtonEnum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.apaPauseButtonEnum = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.apaContinueButtonEnum = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.apaExitButtonEnum = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.hpaParkInMapBuildButtonEnum = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.hpaParkOutMapBuildButtonEnum = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.hpaParkInMapRebuildButtonEnum = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.hpaParkOutMapRebuildButtonEnum = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.hpaParkInButtonEnum = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.hpaParkOutButtonEnum = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.hpaPauseButtonEnum = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.hpaContinueButtonEnum = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.hpaExitButtonEnum = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.hpaAppControlButtonEnum = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.rpaAppSlotTypeEnum = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.userDefinedSlotStsEnum = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 189) {
            break;
          }

          message.apaRemainDistM = reader.float();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.apaProcessRatio = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.apaCurrentStep = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.apaTotalStep = reader.uint32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.apaUsedTotalTimeS = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 229) {
            break;
          }

          message.hpaLearningDistM = reader.float();
          continue;
        }
        case 29: {
          if (tag !== 237) {
            break;
          }

          message.hpaRemainPathDistM = reader.float();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.hpaMapBuildProcessRatio = reader.uint32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.hpaDrivedProcessRatio = reader.uint32();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.hpaUsedTotalTimeS = reader.uint32();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.parkOutDirectionBits = reader.uint32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.apaGearIconEnum = reader.uint32();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.hpaIconColorEnum = reader.uint32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.closeButtonStsEnum = reader.uint32();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.apaParkInButtonEnum = reader.uint32();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.apaParkOutButtonEnum = reader.uint32();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.apaSelfSelectButtonEnum = reader.uint32();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.rpaButtonEnum = reader.uint32();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.lpaButtonEnum = reader.uint32();
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }

          message.pawButtonEnum = reader.uint32();
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }

          message.apaParkOutPathEnum = reader.uint32();
          continue;
        }
        case 44: {
          if (tag !== 352) {
            break;
          }

          message.hpaMapBuildConfirmButtonEnum = reader.uint32();
          continue;
        }
        case 45: {
          if (tag !== 360) {
            break;
          }

          message.hpaMapBuildRecommandIconEnum = reader.uint32();
          continue;
        }
        case 46: {
          if (tag !== 368) {
            break;
          }

          message.hpaButtonEnum = reader.uint32();
          continue;
        }
        case 47: {
          if (tag !== 376) {
            break;
          }

          message.tbaButtonEnum = reader.uint32();
          continue;
        }
        case 48: {
          if (tag !== 384) {
            break;
          }

          message.tbaStartParkButtonEnum = reader.uint32();
          continue;
        }
        case 49: {
          if (tag !== 392) {
            break;
          }

          message.tbaPauseButtonEnum = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 400) {
            break;
          }

          message.tbaContinueButtonEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingFunctionIcon {
    return {
      apaBackStageIconEnum: isSet(object.apaBackStageIconEnum) ? globalThis.Number(object.apaBackStageIconEnum) : 0,
      apaParkModeEnum: isSet(object.apaParkModeEnum) ? globalThis.Number(object.apaParkModeEnum) : 0,
      rpaParkModeEnum: isSet(object.rpaParkModeEnum) ? globalThis.Number(object.rpaParkModeEnum) : 0,
      hpaParkModeEnum: isSet(object.hpaParkModeEnum) ? globalThis.Number(object.hpaParkModeEnum) : 0,
      hpaRecommendIconEnum: isSet(object.hpaRecommendIconEnum) ? globalThis.Number(object.hpaRecommendIconEnum) : 0,
      apaStartParkInButtonEnum: isSet(object.apaStartParkInButtonEnum)
        ? globalThis.Number(object.apaStartParkInButtonEnum)
        : 0,
      apaStartParkOutButtonEnum: isSet(object.apaStartParkOutButtonEnum)
        ? globalThis.Number(object.apaStartParkOutButtonEnum)
        : 0,
      apaPauseButtonEnum: isSet(object.apaPauseButtonEnum) ? globalThis.Number(object.apaPauseButtonEnum) : 0,
      apaContinueButtonEnum: isSet(object.apaContinueButtonEnum) ? globalThis.Number(object.apaContinueButtonEnum) : 0,
      apaExitButtonEnum: isSet(object.apaExitButtonEnum) ? globalThis.Number(object.apaExitButtonEnum) : 0,
      hpaParkInMapBuildButtonEnum: isSet(object.hpaParkInMapBuildButtonEnum)
        ? globalThis.Number(object.hpaParkInMapBuildButtonEnum)
        : 0,
      hpaParkOutMapBuildButtonEnum: isSet(object.hpaParkOutMapBuildButtonEnum)
        ? globalThis.Number(object.hpaParkOutMapBuildButtonEnum)
        : 0,
      hpaParkInMapRebuildButtonEnum: isSet(object.hpaParkInMapRebuildButtonEnum)
        ? globalThis.Number(object.hpaParkInMapRebuildButtonEnum)
        : 0,
      hpaParkOutMapRebuildButtonEnum: isSet(object.hpaParkOutMapRebuildButtonEnum)
        ? globalThis.Number(object.hpaParkOutMapRebuildButtonEnum)
        : 0,
      hpaParkInButtonEnum: isSet(object.hpaParkInButtonEnum) ? globalThis.Number(object.hpaParkInButtonEnum) : 0,
      hpaParkOutButtonEnum: isSet(object.hpaParkOutButtonEnum) ? globalThis.Number(object.hpaParkOutButtonEnum) : 0,
      hpaPauseButtonEnum: isSet(object.hpaPauseButtonEnum) ? globalThis.Number(object.hpaPauseButtonEnum) : 0,
      hpaContinueButtonEnum: isSet(object.hpaContinueButtonEnum) ? globalThis.Number(object.hpaContinueButtonEnum) : 0,
      hpaExitButtonEnum: isSet(object.hpaExitButtonEnum) ? globalThis.Number(object.hpaExitButtonEnum) : 0,
      hpaAppControlButtonEnum: isSet(object.hpaAppControlButtonEnum)
        ? globalThis.Number(object.hpaAppControlButtonEnum)
        : 0,
      rpaAppSlotTypeEnum: isSet(object.rpaAppSlotTypeEnum) ? globalThis.Number(object.rpaAppSlotTypeEnum) : 0,
      userDefinedSlotStsEnum: isSet(object.userDefinedSlotStsEnum)
        ? globalThis.Number(object.userDefinedSlotStsEnum)
        : 0,
      apaRemainDistM: isSet(object.apaRemainDistM) ? globalThis.Number(object.apaRemainDistM) : 0,
      apaProcessRatio: isSet(object.apaProcessRatio) ? globalThis.Number(object.apaProcessRatio) : 0,
      apaCurrentStep: isSet(object.apaCurrentStep) ? globalThis.Number(object.apaCurrentStep) : 0,
      apaTotalStep: isSet(object.apaTotalStep) ? globalThis.Number(object.apaTotalStep) : 0,
      apaUsedTotalTimeS: isSet(object.apaUsedTotalTimeS) ? globalThis.Number(object.apaUsedTotalTimeS) : 0,
      hpaLearningDistM: isSet(object.hpaLearningDistM) ? globalThis.Number(object.hpaLearningDistM) : 0,
      hpaRemainPathDistM: isSet(object.hpaRemainPathDistM) ? globalThis.Number(object.hpaRemainPathDistM) : 0,
      hpaMapBuildProcessRatio: isSet(object.hpaMapBuildProcessRatio)
        ? globalThis.Number(object.hpaMapBuildProcessRatio)
        : 0,
      hpaDrivedProcessRatio: isSet(object.hpaDrivedProcessRatio) ? globalThis.Number(object.hpaDrivedProcessRatio) : 0,
      hpaUsedTotalTimeS: isSet(object.hpaUsedTotalTimeS) ? globalThis.Number(object.hpaUsedTotalTimeS) : 0,
      parkOutDirectionBits: isSet(object.parkOutDirectionBits) ? globalThis.Number(object.parkOutDirectionBits) : 0,
      apaGearIconEnum: isSet(object.apaGearIconEnum) ? globalThis.Number(object.apaGearIconEnum) : 0,
      hpaIconColorEnum: isSet(object.hpaIconColorEnum) ? globalThis.Number(object.hpaIconColorEnum) : 0,
      closeButtonStsEnum: isSet(object.closeButtonStsEnum) ? globalThis.Number(object.closeButtonStsEnum) : 0,
      apaParkInButtonEnum: isSet(object.apaParkInButtonEnum) ? globalThis.Number(object.apaParkInButtonEnum) : 0,
      apaParkOutButtonEnum: isSet(object.apaParkOutButtonEnum) ? globalThis.Number(object.apaParkOutButtonEnum) : 0,
      apaSelfSelectButtonEnum: isSet(object.apaSelfSelectButtonEnum)
        ? globalThis.Number(object.apaSelfSelectButtonEnum)
        : 0,
      rpaButtonEnum: isSet(object.rpaButtonEnum) ? globalThis.Number(object.rpaButtonEnum) : 0,
      lpaButtonEnum: isSet(object.lpaButtonEnum) ? globalThis.Number(object.lpaButtonEnum) : 0,
      pawButtonEnum: isSet(object.pawButtonEnum) ? globalThis.Number(object.pawButtonEnum) : 0,
      apaParkOutPathEnum: isSet(object.apaParkOutPathEnum) ? globalThis.Number(object.apaParkOutPathEnum) : 0,
      hpaMapBuildConfirmButtonEnum: isSet(object.hpaMapBuildConfirmButtonEnum)
        ? globalThis.Number(object.hpaMapBuildConfirmButtonEnum)
        : 0,
      hpaMapBuildRecommandIconEnum: isSet(object.hpaMapBuildRecommandIconEnum)
        ? globalThis.Number(object.hpaMapBuildRecommandIconEnum)
        : 0,
      hpaButtonEnum: isSet(object.hpaButtonEnum) ? globalThis.Number(object.hpaButtonEnum) : 0,
      tbaButtonEnum: isSet(object.tbaButtonEnum) ? globalThis.Number(object.tbaButtonEnum) : 0,
      tbaStartParkButtonEnum: isSet(object.tbaStartParkButtonEnum)
        ? globalThis.Number(object.tbaStartParkButtonEnum)
        : 0,
      tbaPauseButtonEnum: isSet(object.tbaPauseButtonEnum) ? globalThis.Number(object.tbaPauseButtonEnum) : 0,
      tbaContinueButtonEnum: isSet(object.tbaContinueButtonEnum) ? globalThis.Number(object.tbaContinueButtonEnum) : 0,
    };
  },

  toJSON(message: ParkingFunctionIcon): unknown {
    const obj: any = {};
    if (message.apaBackStageIconEnum !== 0) {
      obj.apaBackStageIconEnum = Math.round(message.apaBackStageIconEnum);
    }
    if (message.apaParkModeEnum !== 0) {
      obj.apaParkModeEnum = Math.round(message.apaParkModeEnum);
    }
    if (message.rpaParkModeEnum !== 0) {
      obj.rpaParkModeEnum = Math.round(message.rpaParkModeEnum);
    }
    if (message.hpaParkModeEnum !== 0) {
      obj.hpaParkModeEnum = Math.round(message.hpaParkModeEnum);
    }
    if (message.hpaRecommendIconEnum !== 0) {
      obj.hpaRecommendIconEnum = Math.round(message.hpaRecommendIconEnum);
    }
    if (message.apaStartParkInButtonEnum !== 0) {
      obj.apaStartParkInButtonEnum = Math.round(message.apaStartParkInButtonEnum);
    }
    if (message.apaStartParkOutButtonEnum !== 0) {
      obj.apaStartParkOutButtonEnum = Math.round(message.apaStartParkOutButtonEnum);
    }
    if (message.apaPauseButtonEnum !== 0) {
      obj.apaPauseButtonEnum = Math.round(message.apaPauseButtonEnum);
    }
    if (message.apaContinueButtonEnum !== 0) {
      obj.apaContinueButtonEnum = Math.round(message.apaContinueButtonEnum);
    }
    if (message.apaExitButtonEnum !== 0) {
      obj.apaExitButtonEnum = Math.round(message.apaExitButtonEnum);
    }
    if (message.hpaParkInMapBuildButtonEnum !== 0) {
      obj.hpaParkInMapBuildButtonEnum = Math.round(message.hpaParkInMapBuildButtonEnum);
    }
    if (message.hpaParkOutMapBuildButtonEnum !== 0) {
      obj.hpaParkOutMapBuildButtonEnum = Math.round(message.hpaParkOutMapBuildButtonEnum);
    }
    if (message.hpaParkInMapRebuildButtonEnum !== 0) {
      obj.hpaParkInMapRebuildButtonEnum = Math.round(message.hpaParkInMapRebuildButtonEnum);
    }
    if (message.hpaParkOutMapRebuildButtonEnum !== 0) {
      obj.hpaParkOutMapRebuildButtonEnum = Math.round(message.hpaParkOutMapRebuildButtonEnum);
    }
    if (message.hpaParkInButtonEnum !== 0) {
      obj.hpaParkInButtonEnum = Math.round(message.hpaParkInButtonEnum);
    }
    if (message.hpaParkOutButtonEnum !== 0) {
      obj.hpaParkOutButtonEnum = Math.round(message.hpaParkOutButtonEnum);
    }
    if (message.hpaPauseButtonEnum !== 0) {
      obj.hpaPauseButtonEnum = Math.round(message.hpaPauseButtonEnum);
    }
    if (message.hpaContinueButtonEnum !== 0) {
      obj.hpaContinueButtonEnum = Math.round(message.hpaContinueButtonEnum);
    }
    if (message.hpaExitButtonEnum !== 0) {
      obj.hpaExitButtonEnum = Math.round(message.hpaExitButtonEnum);
    }
    if (message.hpaAppControlButtonEnum !== 0) {
      obj.hpaAppControlButtonEnum = Math.round(message.hpaAppControlButtonEnum);
    }
    if (message.rpaAppSlotTypeEnum !== 0) {
      obj.rpaAppSlotTypeEnum = Math.round(message.rpaAppSlotTypeEnum);
    }
    if (message.userDefinedSlotStsEnum !== 0) {
      obj.userDefinedSlotStsEnum = Math.round(message.userDefinedSlotStsEnum);
    }
    if (message.apaRemainDistM !== 0) {
      obj.apaRemainDistM = message.apaRemainDistM;
    }
    if (message.apaProcessRatio !== 0) {
      obj.apaProcessRatio = Math.round(message.apaProcessRatio);
    }
    if (message.apaCurrentStep !== 0) {
      obj.apaCurrentStep = Math.round(message.apaCurrentStep);
    }
    if (message.apaTotalStep !== 0) {
      obj.apaTotalStep = Math.round(message.apaTotalStep);
    }
    if (message.apaUsedTotalTimeS !== 0) {
      obj.apaUsedTotalTimeS = Math.round(message.apaUsedTotalTimeS);
    }
    if (message.hpaLearningDistM !== 0) {
      obj.hpaLearningDistM = message.hpaLearningDistM;
    }
    if (message.hpaRemainPathDistM !== 0) {
      obj.hpaRemainPathDistM = message.hpaRemainPathDistM;
    }
    if (message.hpaMapBuildProcessRatio !== 0) {
      obj.hpaMapBuildProcessRatio = Math.round(message.hpaMapBuildProcessRatio);
    }
    if (message.hpaDrivedProcessRatio !== 0) {
      obj.hpaDrivedProcessRatio = Math.round(message.hpaDrivedProcessRatio);
    }
    if (message.hpaUsedTotalTimeS !== 0) {
      obj.hpaUsedTotalTimeS = Math.round(message.hpaUsedTotalTimeS);
    }
    if (message.parkOutDirectionBits !== 0) {
      obj.parkOutDirectionBits = Math.round(message.parkOutDirectionBits);
    }
    if (message.apaGearIconEnum !== 0) {
      obj.apaGearIconEnum = Math.round(message.apaGearIconEnum);
    }
    if (message.hpaIconColorEnum !== 0) {
      obj.hpaIconColorEnum = Math.round(message.hpaIconColorEnum);
    }
    if (message.closeButtonStsEnum !== 0) {
      obj.closeButtonStsEnum = Math.round(message.closeButtonStsEnum);
    }
    if (message.apaParkInButtonEnum !== 0) {
      obj.apaParkInButtonEnum = Math.round(message.apaParkInButtonEnum);
    }
    if (message.apaParkOutButtonEnum !== 0) {
      obj.apaParkOutButtonEnum = Math.round(message.apaParkOutButtonEnum);
    }
    if (message.apaSelfSelectButtonEnum !== 0) {
      obj.apaSelfSelectButtonEnum = Math.round(message.apaSelfSelectButtonEnum);
    }
    if (message.rpaButtonEnum !== 0) {
      obj.rpaButtonEnum = Math.round(message.rpaButtonEnum);
    }
    if (message.lpaButtonEnum !== 0) {
      obj.lpaButtonEnum = Math.round(message.lpaButtonEnum);
    }
    if (message.pawButtonEnum !== 0) {
      obj.pawButtonEnum = Math.round(message.pawButtonEnum);
    }
    if (message.apaParkOutPathEnum !== 0) {
      obj.apaParkOutPathEnum = Math.round(message.apaParkOutPathEnum);
    }
    if (message.hpaMapBuildConfirmButtonEnum !== 0) {
      obj.hpaMapBuildConfirmButtonEnum = Math.round(message.hpaMapBuildConfirmButtonEnum);
    }
    if (message.hpaMapBuildRecommandIconEnum !== 0) {
      obj.hpaMapBuildRecommandIconEnum = Math.round(message.hpaMapBuildRecommandIconEnum);
    }
    if (message.hpaButtonEnum !== 0) {
      obj.hpaButtonEnum = Math.round(message.hpaButtonEnum);
    }
    if (message.tbaButtonEnum !== 0) {
      obj.tbaButtonEnum = Math.round(message.tbaButtonEnum);
    }
    if (message.tbaStartParkButtonEnum !== 0) {
      obj.tbaStartParkButtonEnum = Math.round(message.tbaStartParkButtonEnum);
    }
    if (message.tbaPauseButtonEnum !== 0) {
      obj.tbaPauseButtonEnum = Math.round(message.tbaPauseButtonEnum);
    }
    if (message.tbaContinueButtonEnum !== 0) {
      obj.tbaContinueButtonEnum = Math.round(message.tbaContinueButtonEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingFunctionIcon>, I>>(base?: I): ParkingFunctionIcon {
    return ParkingFunctionIcon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingFunctionIcon>, I>>(object: I): ParkingFunctionIcon {
    const message = createBaseParkingFunctionIcon();
    message.apaBackStageIconEnum = object.apaBackStageIconEnum ?? 0;
    message.apaParkModeEnum = object.apaParkModeEnum ?? 0;
    message.rpaParkModeEnum = object.rpaParkModeEnum ?? 0;
    message.hpaParkModeEnum = object.hpaParkModeEnum ?? 0;
    message.hpaRecommendIconEnum = object.hpaRecommendIconEnum ?? 0;
    message.apaStartParkInButtonEnum = object.apaStartParkInButtonEnum ?? 0;
    message.apaStartParkOutButtonEnum = object.apaStartParkOutButtonEnum ?? 0;
    message.apaPauseButtonEnum = object.apaPauseButtonEnum ?? 0;
    message.apaContinueButtonEnum = object.apaContinueButtonEnum ?? 0;
    message.apaExitButtonEnum = object.apaExitButtonEnum ?? 0;
    message.hpaParkInMapBuildButtonEnum = object.hpaParkInMapBuildButtonEnum ?? 0;
    message.hpaParkOutMapBuildButtonEnum = object.hpaParkOutMapBuildButtonEnum ?? 0;
    message.hpaParkInMapRebuildButtonEnum = object.hpaParkInMapRebuildButtonEnum ?? 0;
    message.hpaParkOutMapRebuildButtonEnum = object.hpaParkOutMapRebuildButtonEnum ?? 0;
    message.hpaParkInButtonEnum = object.hpaParkInButtonEnum ?? 0;
    message.hpaParkOutButtonEnum = object.hpaParkOutButtonEnum ?? 0;
    message.hpaPauseButtonEnum = object.hpaPauseButtonEnum ?? 0;
    message.hpaContinueButtonEnum = object.hpaContinueButtonEnum ?? 0;
    message.hpaExitButtonEnum = object.hpaExitButtonEnum ?? 0;
    message.hpaAppControlButtonEnum = object.hpaAppControlButtonEnum ?? 0;
    message.rpaAppSlotTypeEnum = object.rpaAppSlotTypeEnum ?? 0;
    message.userDefinedSlotStsEnum = object.userDefinedSlotStsEnum ?? 0;
    message.apaRemainDistM = object.apaRemainDistM ?? 0;
    message.apaProcessRatio = object.apaProcessRatio ?? 0;
    message.apaCurrentStep = object.apaCurrentStep ?? 0;
    message.apaTotalStep = object.apaTotalStep ?? 0;
    message.apaUsedTotalTimeS = object.apaUsedTotalTimeS ?? 0;
    message.hpaLearningDistM = object.hpaLearningDistM ?? 0;
    message.hpaRemainPathDistM = object.hpaRemainPathDistM ?? 0;
    message.hpaMapBuildProcessRatio = object.hpaMapBuildProcessRatio ?? 0;
    message.hpaDrivedProcessRatio = object.hpaDrivedProcessRatio ?? 0;
    message.hpaUsedTotalTimeS = object.hpaUsedTotalTimeS ?? 0;
    message.parkOutDirectionBits = object.parkOutDirectionBits ?? 0;
    message.apaGearIconEnum = object.apaGearIconEnum ?? 0;
    message.hpaIconColorEnum = object.hpaIconColorEnum ?? 0;
    message.closeButtonStsEnum = object.closeButtonStsEnum ?? 0;
    message.apaParkInButtonEnum = object.apaParkInButtonEnum ?? 0;
    message.apaParkOutButtonEnum = object.apaParkOutButtonEnum ?? 0;
    message.apaSelfSelectButtonEnum = object.apaSelfSelectButtonEnum ?? 0;
    message.rpaButtonEnum = object.rpaButtonEnum ?? 0;
    message.lpaButtonEnum = object.lpaButtonEnum ?? 0;
    message.pawButtonEnum = object.pawButtonEnum ?? 0;
    message.apaParkOutPathEnum = object.apaParkOutPathEnum ?? 0;
    message.hpaMapBuildConfirmButtonEnum = object.hpaMapBuildConfirmButtonEnum ?? 0;
    message.hpaMapBuildRecommandIconEnum = object.hpaMapBuildRecommandIconEnum ?? 0;
    message.hpaButtonEnum = object.hpaButtonEnum ?? 0;
    message.tbaButtonEnum = object.tbaButtonEnum ?? 0;
    message.tbaStartParkButtonEnum = object.tbaStartParkButtonEnum ?? 0;
    message.tbaPauseButtonEnum = object.tbaPauseButtonEnum ?? 0;
    message.tbaContinueButtonEnum = object.tbaContinueButtonEnum ?? 0;
    return message;
  },
};

function createBaseParkingFunctionText(): ParkingFunctionText {
  return {
    parkingFailureReasonEnum: 0,
    parkingPassiveReasonEnum: 0,
    parkingAbortReasonEnum: 0,
    parkingSuspendReasonEnum: 0,
    parkingDispInfoEnum: 0,
  };
}

export const ParkingFunctionText: MessageFns<ParkingFunctionText> = {
  encode(message: ParkingFunctionText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parkingFailureReasonEnum !== 0) {
      writer.uint32(8).uint32(message.parkingFailureReasonEnum);
    }
    if (message.parkingPassiveReasonEnum !== 0) {
      writer.uint32(16).uint32(message.parkingPassiveReasonEnum);
    }
    if (message.parkingAbortReasonEnum !== 0) {
      writer.uint32(24).uint32(message.parkingAbortReasonEnum);
    }
    if (message.parkingSuspendReasonEnum !== 0) {
      writer.uint32(32).uint32(message.parkingSuspendReasonEnum);
    }
    if (message.parkingDispInfoEnum !== 0) {
      writer.uint32(40).uint32(message.parkingDispInfoEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingFunctionText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingFunctionText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.parkingFailureReasonEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.parkingPassiveReasonEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.parkingAbortReasonEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.parkingSuspendReasonEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.parkingDispInfoEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingFunctionText {
    return {
      parkingFailureReasonEnum: isSet(object.parkingFailureReasonEnum)
        ? globalThis.Number(object.parkingFailureReasonEnum)
        : 0,
      parkingPassiveReasonEnum: isSet(object.parkingPassiveReasonEnum)
        ? globalThis.Number(object.parkingPassiveReasonEnum)
        : 0,
      parkingAbortReasonEnum: isSet(object.parkingAbortReasonEnum)
        ? globalThis.Number(object.parkingAbortReasonEnum)
        : 0,
      parkingSuspendReasonEnum: isSet(object.parkingSuspendReasonEnum)
        ? globalThis.Number(object.parkingSuspendReasonEnum)
        : 0,
      parkingDispInfoEnum: isSet(object.parkingDispInfoEnum) ? globalThis.Number(object.parkingDispInfoEnum) : 0,
    };
  },

  toJSON(message: ParkingFunctionText): unknown {
    const obj: any = {};
    if (message.parkingFailureReasonEnum !== 0) {
      obj.parkingFailureReasonEnum = Math.round(message.parkingFailureReasonEnum);
    }
    if (message.parkingPassiveReasonEnum !== 0) {
      obj.parkingPassiveReasonEnum = Math.round(message.parkingPassiveReasonEnum);
    }
    if (message.parkingAbortReasonEnum !== 0) {
      obj.parkingAbortReasonEnum = Math.round(message.parkingAbortReasonEnum);
    }
    if (message.parkingSuspendReasonEnum !== 0) {
      obj.parkingSuspendReasonEnum = Math.round(message.parkingSuspendReasonEnum);
    }
    if (message.parkingDispInfoEnum !== 0) {
      obj.parkingDispInfoEnum = Math.round(message.parkingDispInfoEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingFunctionText>, I>>(base?: I): ParkingFunctionText {
    return ParkingFunctionText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingFunctionText>, I>>(object: I): ParkingFunctionText {
    const message = createBaseParkingFunctionText();
    message.parkingFailureReasonEnum = object.parkingFailureReasonEnum ?? 0;
    message.parkingPassiveReasonEnum = object.parkingPassiveReasonEnum ?? 0;
    message.parkingAbortReasonEnum = object.parkingAbortReasonEnum ?? 0;
    message.parkingSuspendReasonEnum = object.parkingSuspendReasonEnum ?? 0;
    message.parkingDispInfoEnum = object.parkingDispInfoEnum ?? 0;
    return message;
  },
};

function createBaseParkingFunctionStatus(): ParkingFunctionStatus {
  return { apaStsEnum: 0, rpaStsEnum: 0, hpaStsEnum: 0, mebStsEnum: 0, pasStsEnum: 0, tbaStsEnum: 0 };
}

export const ParkingFunctionStatus: MessageFns<ParkingFunctionStatus> = {
  encode(message: ParkingFunctionStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apaStsEnum !== 0) {
      writer.uint32(8).uint32(message.apaStsEnum);
    }
    if (message.rpaStsEnum !== 0) {
      writer.uint32(16).uint32(message.rpaStsEnum);
    }
    if (message.hpaStsEnum !== 0) {
      writer.uint32(24).uint32(message.hpaStsEnum);
    }
    if (message.mebStsEnum !== 0) {
      writer.uint32(32).uint32(message.mebStsEnum);
    }
    if (message.pasStsEnum !== 0) {
      writer.uint32(40).uint32(message.pasStsEnum);
    }
    if (message.tbaStsEnum !== 0) {
      writer.uint32(48).uint32(message.tbaStsEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingFunctionStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingFunctionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.apaStsEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rpaStsEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hpaStsEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mebStsEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pasStsEnum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.tbaStsEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingFunctionStatus {
    return {
      apaStsEnum: isSet(object.apaStsEnum) ? globalThis.Number(object.apaStsEnum) : 0,
      rpaStsEnum: isSet(object.rpaStsEnum) ? globalThis.Number(object.rpaStsEnum) : 0,
      hpaStsEnum: isSet(object.hpaStsEnum) ? globalThis.Number(object.hpaStsEnum) : 0,
      mebStsEnum: isSet(object.mebStsEnum) ? globalThis.Number(object.mebStsEnum) : 0,
      pasStsEnum: isSet(object.pasStsEnum) ? globalThis.Number(object.pasStsEnum) : 0,
      tbaStsEnum: isSet(object.tbaStsEnum) ? globalThis.Number(object.tbaStsEnum) : 0,
    };
  },

  toJSON(message: ParkingFunctionStatus): unknown {
    const obj: any = {};
    if (message.apaStsEnum !== 0) {
      obj.apaStsEnum = Math.round(message.apaStsEnum);
    }
    if (message.rpaStsEnum !== 0) {
      obj.rpaStsEnum = Math.round(message.rpaStsEnum);
    }
    if (message.hpaStsEnum !== 0) {
      obj.hpaStsEnum = Math.round(message.hpaStsEnum);
    }
    if (message.mebStsEnum !== 0) {
      obj.mebStsEnum = Math.round(message.mebStsEnum);
    }
    if (message.pasStsEnum !== 0) {
      obj.pasStsEnum = Math.round(message.pasStsEnum);
    }
    if (message.tbaStsEnum !== 0) {
      obj.tbaStsEnum = Math.round(message.tbaStsEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingFunctionStatus>, I>>(base?: I): ParkingFunctionStatus {
    return ParkingFunctionStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingFunctionStatus>, I>>(object: I): ParkingFunctionStatus {
    const message = createBaseParkingFunctionStatus();
    message.apaStsEnum = object.apaStsEnum ?? 0;
    message.rpaStsEnum = object.rpaStsEnum ?? 0;
    message.hpaStsEnum = object.hpaStsEnum ?? 0;
    message.mebStsEnum = object.mebStsEnum ?? 0;
    message.pasStsEnum = object.pasStsEnum ?? 0;
    message.tbaStsEnum = object.tbaStsEnum ?? 0;
    return message;
  },
};

function createBaseParkingFunctionSwitch(): ParkingFunctionSwitch {
  return {
    apaDispRespEnum: 0,
    hpaDispRespEnum: 0,
    apaViewModeEnum: 0,
    parkOutDirectionRespEnum: 0,
    apaSpdTypeRespEnum: 0,
    hpaSpdTypeRespEnum: 0,
    parkingVoiceBroadcastTypeRespEnum: 0,
  };
}

export const ParkingFunctionSwitch: MessageFns<ParkingFunctionSwitch> = {
  encode(message: ParkingFunctionSwitch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apaDispRespEnum !== 0) {
      writer.uint32(8).uint32(message.apaDispRespEnum);
    }
    if (message.hpaDispRespEnum !== 0) {
      writer.uint32(16).uint32(message.hpaDispRespEnum);
    }
    if (message.apaViewModeEnum !== 0) {
      writer.uint32(24).uint32(message.apaViewModeEnum);
    }
    if (message.parkOutDirectionRespEnum !== 0) {
      writer.uint32(32).uint32(message.parkOutDirectionRespEnum);
    }
    if (message.apaSpdTypeRespEnum !== 0) {
      writer.uint32(40).uint32(message.apaSpdTypeRespEnum);
    }
    if (message.hpaSpdTypeRespEnum !== 0) {
      writer.uint32(48).uint32(message.hpaSpdTypeRespEnum);
    }
    if (message.parkingVoiceBroadcastTypeRespEnum !== 0) {
      writer.uint32(56).uint32(message.parkingVoiceBroadcastTypeRespEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingFunctionSwitch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingFunctionSwitch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.apaDispRespEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hpaDispRespEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.apaViewModeEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.parkOutDirectionRespEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.apaSpdTypeRespEnum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.hpaSpdTypeRespEnum = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.parkingVoiceBroadcastTypeRespEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingFunctionSwitch {
    return {
      apaDispRespEnum: isSet(object.apaDispRespEnum) ? globalThis.Number(object.apaDispRespEnum) : 0,
      hpaDispRespEnum: isSet(object.hpaDispRespEnum) ? globalThis.Number(object.hpaDispRespEnum) : 0,
      apaViewModeEnum: isSet(object.apaViewModeEnum) ? globalThis.Number(object.apaViewModeEnum) : 0,
      parkOutDirectionRespEnum: isSet(object.parkOutDirectionRespEnum)
        ? globalThis.Number(object.parkOutDirectionRespEnum)
        : 0,
      apaSpdTypeRespEnum: isSet(object.apaSpdTypeRespEnum) ? globalThis.Number(object.apaSpdTypeRespEnum) : 0,
      hpaSpdTypeRespEnum: isSet(object.hpaSpdTypeRespEnum) ? globalThis.Number(object.hpaSpdTypeRespEnum) : 0,
      parkingVoiceBroadcastTypeRespEnum: isSet(object.parkingVoiceBroadcastTypeRespEnum)
        ? globalThis.Number(object.parkingVoiceBroadcastTypeRespEnum)
        : 0,
    };
  },

  toJSON(message: ParkingFunctionSwitch): unknown {
    const obj: any = {};
    if (message.apaDispRespEnum !== 0) {
      obj.apaDispRespEnum = Math.round(message.apaDispRespEnum);
    }
    if (message.hpaDispRespEnum !== 0) {
      obj.hpaDispRespEnum = Math.round(message.hpaDispRespEnum);
    }
    if (message.apaViewModeEnum !== 0) {
      obj.apaViewModeEnum = Math.round(message.apaViewModeEnum);
    }
    if (message.parkOutDirectionRespEnum !== 0) {
      obj.parkOutDirectionRespEnum = Math.round(message.parkOutDirectionRespEnum);
    }
    if (message.apaSpdTypeRespEnum !== 0) {
      obj.apaSpdTypeRespEnum = Math.round(message.apaSpdTypeRespEnum);
    }
    if (message.hpaSpdTypeRespEnum !== 0) {
      obj.hpaSpdTypeRespEnum = Math.round(message.hpaSpdTypeRespEnum);
    }
    if (message.parkingVoiceBroadcastTypeRespEnum !== 0) {
      obj.parkingVoiceBroadcastTypeRespEnum = Math.round(message.parkingVoiceBroadcastTypeRespEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingFunctionSwitch>, I>>(base?: I): ParkingFunctionSwitch {
    return ParkingFunctionSwitch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingFunctionSwitch>, I>>(object: I): ParkingFunctionSwitch {
    const message = createBaseParkingFunctionSwitch();
    message.apaDispRespEnum = object.apaDispRespEnum ?? 0;
    message.hpaDispRespEnum = object.hpaDispRespEnum ?? 0;
    message.apaViewModeEnum = object.apaViewModeEnum ?? 0;
    message.parkOutDirectionRespEnum = object.parkOutDirectionRespEnum ?? 0;
    message.apaSpdTypeRespEnum = object.apaSpdTypeRespEnum ?? 0;
    message.hpaSpdTypeRespEnum = object.hpaSpdTypeRespEnum ?? 0;
    message.parkingVoiceBroadcastTypeRespEnum = object.parkingVoiceBroadcastTypeRespEnum ?? 0;
    return message;
  },
};

function createBaseParkingFunctionVoice(): ParkingFunctionVoice {
  return { apaSlotFoundPromptEnum: 0, apaVoiceReminderEnum: 0 };
}

export const ParkingFunctionVoice: MessageFns<ParkingFunctionVoice> = {
  encode(message: ParkingFunctionVoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apaSlotFoundPromptEnum !== 0) {
      writer.uint32(8).uint32(message.apaSlotFoundPromptEnum);
    }
    if (message.apaVoiceReminderEnum !== 0) {
      writer.uint32(16).uint32(message.apaVoiceReminderEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingFunctionVoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingFunctionVoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.apaSlotFoundPromptEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.apaVoiceReminderEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingFunctionVoice {
    return {
      apaSlotFoundPromptEnum: isSet(object.apaSlotFoundPromptEnum)
        ? globalThis.Number(object.apaSlotFoundPromptEnum)
        : 0,
      apaVoiceReminderEnum: isSet(object.apaVoiceReminderEnum) ? globalThis.Number(object.apaVoiceReminderEnum) : 0,
    };
  },

  toJSON(message: ParkingFunctionVoice): unknown {
    const obj: any = {};
    if (message.apaSlotFoundPromptEnum !== 0) {
      obj.apaSlotFoundPromptEnum = Math.round(message.apaSlotFoundPromptEnum);
    }
    if (message.apaVoiceReminderEnum !== 0) {
      obj.apaVoiceReminderEnum = Math.round(message.apaVoiceReminderEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingFunctionVoice>, I>>(base?: I): ParkingFunctionVoice {
    return ParkingFunctionVoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingFunctionVoice>, I>>(object: I): ParkingFunctionVoice {
    const message = createBaseParkingFunctionVoice();
    message.apaSlotFoundPromptEnum = object.apaSlotFoundPromptEnum ?? 0;
    message.apaVoiceReminderEnum = object.apaVoiceReminderEnum ?? 0;
    return message;
  },
};

function createBaseParkingFunctionSR(): ParkingFunctionSR {
  return { parkingSlotNum: 0, parkingSlotList: [] };
}

export const ParkingFunctionSR: MessageFns<ParkingFunctionSR> = {
  encode(message: ParkingFunctionSR, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parkingSlotNum !== 0) {
      writer.uint32(8).uint32(message.parkingSlotNum);
    }
    for (const v of message.parkingSlotList) {
      ParkingSlotInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingFunctionSR {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingFunctionSR();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.parkingSlotNum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parkingSlotList.push(ParkingSlotInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingFunctionSR {
    return {
      parkingSlotNum: isSet(object.parkingSlotNum) ? globalThis.Number(object.parkingSlotNum) : 0,
      parkingSlotList: globalThis.Array.isArray(object?.parkingSlotList)
        ? object.parkingSlotList.map((e: any) => ParkingSlotInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ParkingFunctionSR): unknown {
    const obj: any = {};
    if (message.parkingSlotNum !== 0) {
      obj.parkingSlotNum = Math.round(message.parkingSlotNum);
    }
    if (message.parkingSlotList?.length) {
      obj.parkingSlotList = message.parkingSlotList.map((e) => ParkingSlotInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingFunctionSR>, I>>(base?: I): ParkingFunctionSR {
    return ParkingFunctionSR.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingFunctionSR>, I>>(object: I): ParkingFunctionSR {
    const message = createBaseParkingFunctionSR();
    message.parkingSlotNum = object.parkingSlotNum ?? 0;
    message.parkingSlotList = object.parkingSlotList?.map((e) => ParkingSlotInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseParkingSlotInfo(): ParkingSlotInfo {
  return {
    slotId: 0,
    slotNumber: 0,
    slotStsEnum: 0,
    slotTypeEnum: 0,
    slotDetectedEnum: 0,
    slotCentralPointXM: 0,
    slotCentralPointYM: 0,
    slotYawDeg: 0,
    slotEdgeDeg: 0,
    slotLengthM: 0,
    slotWidthM: 0,
    slotPoint1XM: 0,
    slotPoint1YM: 0,
    slotPoint2XM: 0,
    slotPoint2YM: 0,
    slotPoint3XM: 0,
    slotPoint3YM: 0,
    slotPoint4XM: 0,
    slotPoint4YM: 0,
  };
}

export const ParkingSlotInfo: MessageFns<ParkingSlotInfo> = {
  encode(message: ParkingSlotInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slotId !== 0) {
      writer.uint32(8).uint32(message.slotId);
    }
    if (message.slotNumber !== 0) {
      writer.uint32(16).uint32(message.slotNumber);
    }
    if (message.slotStsEnum !== 0) {
      writer.uint32(24).uint32(message.slotStsEnum);
    }
    if (message.slotTypeEnum !== 0) {
      writer.uint32(32).uint32(message.slotTypeEnum);
    }
    if (message.slotDetectedEnum !== 0) {
      writer.uint32(40).uint32(message.slotDetectedEnum);
    }
    if (message.slotCentralPointXM !== 0) {
      writer.uint32(53).float(message.slotCentralPointXM);
    }
    if (message.slotCentralPointYM !== 0) {
      writer.uint32(61).float(message.slotCentralPointYM);
    }
    if (message.slotYawDeg !== 0) {
      writer.uint32(69).float(message.slotYawDeg);
    }
    if (message.slotEdgeDeg !== 0) {
      writer.uint32(77).float(message.slotEdgeDeg);
    }
    if (message.slotLengthM !== 0) {
      writer.uint32(85).float(message.slotLengthM);
    }
    if (message.slotWidthM !== 0) {
      writer.uint32(93).float(message.slotWidthM);
    }
    if (message.slotPoint1XM !== 0) {
      writer.uint32(101).float(message.slotPoint1XM);
    }
    if (message.slotPoint1YM !== 0) {
      writer.uint32(109).float(message.slotPoint1YM);
    }
    if (message.slotPoint2XM !== 0) {
      writer.uint32(117).float(message.slotPoint2XM);
    }
    if (message.slotPoint2YM !== 0) {
      writer.uint32(125).float(message.slotPoint2YM);
    }
    if (message.slotPoint3XM !== 0) {
      writer.uint32(133).float(message.slotPoint3XM);
    }
    if (message.slotPoint3YM !== 0) {
      writer.uint32(141).float(message.slotPoint3YM);
    }
    if (message.slotPoint4XM !== 0) {
      writer.uint32(149).float(message.slotPoint4XM);
    }
    if (message.slotPoint4YM !== 0) {
      writer.uint32(157).float(message.slotPoint4YM);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingSlotInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingSlotInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.slotNumber = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.slotStsEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.slotTypeEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.slotDetectedEnum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.slotCentralPointXM = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.slotCentralPointYM = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.slotYawDeg = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.slotEdgeDeg = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.slotLengthM = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.slotWidthM = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.slotPoint1XM = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.slotPoint1YM = reader.float();
          continue;
        }
        case 14: {
          if (tag !== 117) {
            break;
          }

          message.slotPoint2XM = reader.float();
          continue;
        }
        case 15: {
          if (tag !== 125) {
            break;
          }

          message.slotPoint2YM = reader.float();
          continue;
        }
        case 16: {
          if (tag !== 133) {
            break;
          }

          message.slotPoint3XM = reader.float();
          continue;
        }
        case 17: {
          if (tag !== 141) {
            break;
          }

          message.slotPoint3YM = reader.float();
          continue;
        }
        case 18: {
          if (tag !== 149) {
            break;
          }

          message.slotPoint4XM = reader.float();
          continue;
        }
        case 19: {
          if (tag !== 157) {
            break;
          }

          message.slotPoint4YM = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingSlotInfo {
    return {
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      slotNumber: isSet(object.slotNumber) ? globalThis.Number(object.slotNumber) : 0,
      slotStsEnum: isSet(object.slotStsEnum) ? globalThis.Number(object.slotStsEnum) : 0,
      slotTypeEnum: isSet(object.slotTypeEnum) ? globalThis.Number(object.slotTypeEnum) : 0,
      slotDetectedEnum: isSet(object.slotDetectedEnum) ? globalThis.Number(object.slotDetectedEnum) : 0,
      slotCentralPointXM: isSet(object.slotCentralPointXM) ? globalThis.Number(object.slotCentralPointXM) : 0,
      slotCentralPointYM: isSet(object.slotCentralPointYM) ? globalThis.Number(object.slotCentralPointYM) : 0,
      slotYawDeg: isSet(object.slotYawDeg) ? globalThis.Number(object.slotYawDeg) : 0,
      slotEdgeDeg: isSet(object.slotEdgeDeg) ? globalThis.Number(object.slotEdgeDeg) : 0,
      slotLengthM: isSet(object.slotLengthM) ? globalThis.Number(object.slotLengthM) : 0,
      slotWidthM: isSet(object.slotWidthM) ? globalThis.Number(object.slotWidthM) : 0,
      slotPoint1XM: isSet(object.slotPoint1XM) ? globalThis.Number(object.slotPoint1XM) : 0,
      slotPoint1YM: isSet(object.slotPoint1YM) ? globalThis.Number(object.slotPoint1YM) : 0,
      slotPoint2XM: isSet(object.slotPoint2XM) ? globalThis.Number(object.slotPoint2XM) : 0,
      slotPoint2YM: isSet(object.slotPoint2YM) ? globalThis.Number(object.slotPoint2YM) : 0,
      slotPoint3XM: isSet(object.slotPoint3XM) ? globalThis.Number(object.slotPoint3XM) : 0,
      slotPoint3YM: isSet(object.slotPoint3YM) ? globalThis.Number(object.slotPoint3YM) : 0,
      slotPoint4XM: isSet(object.slotPoint4XM) ? globalThis.Number(object.slotPoint4XM) : 0,
      slotPoint4YM: isSet(object.slotPoint4YM) ? globalThis.Number(object.slotPoint4YM) : 0,
    };
  },

  toJSON(message: ParkingSlotInfo): unknown {
    const obj: any = {};
    if (message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.slotNumber !== 0) {
      obj.slotNumber = Math.round(message.slotNumber);
    }
    if (message.slotStsEnum !== 0) {
      obj.slotStsEnum = Math.round(message.slotStsEnum);
    }
    if (message.slotTypeEnum !== 0) {
      obj.slotTypeEnum = Math.round(message.slotTypeEnum);
    }
    if (message.slotDetectedEnum !== 0) {
      obj.slotDetectedEnum = Math.round(message.slotDetectedEnum);
    }
    if (message.slotCentralPointXM !== 0) {
      obj.slotCentralPointXM = message.slotCentralPointXM;
    }
    if (message.slotCentralPointYM !== 0) {
      obj.slotCentralPointYM = message.slotCentralPointYM;
    }
    if (message.slotYawDeg !== 0) {
      obj.slotYawDeg = message.slotYawDeg;
    }
    if (message.slotEdgeDeg !== 0) {
      obj.slotEdgeDeg = message.slotEdgeDeg;
    }
    if (message.slotLengthM !== 0) {
      obj.slotLengthM = message.slotLengthM;
    }
    if (message.slotWidthM !== 0) {
      obj.slotWidthM = message.slotWidthM;
    }
    if (message.slotPoint1XM !== 0) {
      obj.slotPoint1XM = message.slotPoint1XM;
    }
    if (message.slotPoint1YM !== 0) {
      obj.slotPoint1YM = message.slotPoint1YM;
    }
    if (message.slotPoint2XM !== 0) {
      obj.slotPoint2XM = message.slotPoint2XM;
    }
    if (message.slotPoint2YM !== 0) {
      obj.slotPoint2YM = message.slotPoint2YM;
    }
    if (message.slotPoint3XM !== 0) {
      obj.slotPoint3XM = message.slotPoint3XM;
    }
    if (message.slotPoint3YM !== 0) {
      obj.slotPoint3YM = message.slotPoint3YM;
    }
    if (message.slotPoint4XM !== 0) {
      obj.slotPoint4XM = message.slotPoint4XM;
    }
    if (message.slotPoint4YM !== 0) {
      obj.slotPoint4YM = message.slotPoint4YM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingSlotInfo>, I>>(base?: I): ParkingSlotInfo {
    return ParkingSlotInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingSlotInfo>, I>>(object: I): ParkingSlotInfo {
    const message = createBaseParkingSlotInfo();
    message.slotId = object.slotId ?? 0;
    message.slotNumber = object.slotNumber ?? 0;
    message.slotStsEnum = object.slotStsEnum ?? 0;
    message.slotTypeEnum = object.slotTypeEnum ?? 0;
    message.slotDetectedEnum = object.slotDetectedEnum ?? 0;
    message.slotCentralPointXM = object.slotCentralPointXM ?? 0;
    message.slotCentralPointYM = object.slotCentralPointYM ?? 0;
    message.slotYawDeg = object.slotYawDeg ?? 0;
    message.slotEdgeDeg = object.slotEdgeDeg ?? 0;
    message.slotLengthM = object.slotLengthM ?? 0;
    message.slotWidthM = object.slotWidthM ?? 0;
    message.slotPoint1XM = object.slotPoint1XM ?? 0;
    message.slotPoint1YM = object.slotPoint1YM ?? 0;
    message.slotPoint2XM = object.slotPoint2XM ?? 0;
    message.slotPoint2YM = object.slotPoint2YM ?? 0;
    message.slotPoint3XM = object.slotPoint3XM ?? 0;
    message.slotPoint3YM = object.slotPoint3YM ?? 0;
    message.slotPoint4XM = object.slotPoint4XM ?? 0;
    message.slotPoint4YM = object.slotPoint4YM ?? 0;
    return message;
  },
};

function createBaseParkingFunctionAnalysis(): ParkingFunctionAnalysis {
  return {
    apaCurrentCycleSuccTimes: 0,
    apaCurrentCycleFailtimes: 0,
    hpaCurrentCycleSuccTimes: 0,
    mebCurrentCycleActimes: 0,
    hpaUseNumber: 0,
    hpaParkInSuccessNumber: 0,
    apaUseNumber: 0,
    apaParkInSuccessNumber: 0,
    apaParkInSuccessRatio: 0,
    apaParkInAverageTimeS: 0,
    apaParkOutAverageTimeS: 0,
    hpaPedestrianAvoidNumber: 0,
    hpaPassJunctionNumber: 0,
    hpaPassSpeedbumpNumber: 0,
    hpaUserInterventionNumber: 0,
  };
}

export const ParkingFunctionAnalysis: MessageFns<ParkingFunctionAnalysis> = {
  encode(message: ParkingFunctionAnalysis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apaCurrentCycleSuccTimes !== 0) {
      writer.uint32(8).uint32(message.apaCurrentCycleSuccTimes);
    }
    if (message.apaCurrentCycleFailtimes !== 0) {
      writer.uint32(16).uint32(message.apaCurrentCycleFailtimes);
    }
    if (message.hpaCurrentCycleSuccTimes !== 0) {
      writer.uint32(24).uint32(message.hpaCurrentCycleSuccTimes);
    }
    if (message.mebCurrentCycleActimes !== 0) {
      writer.uint32(32).uint32(message.mebCurrentCycleActimes);
    }
    if (message.hpaUseNumber !== 0) {
      writer.uint32(40).uint32(message.hpaUseNumber);
    }
    if (message.hpaParkInSuccessNumber !== 0) {
      writer.uint32(48).uint32(message.hpaParkInSuccessNumber);
    }
    if (message.apaUseNumber !== 0) {
      writer.uint32(56).uint32(message.apaUseNumber);
    }
    if (message.apaParkInSuccessNumber !== 0) {
      writer.uint32(64).uint32(message.apaParkInSuccessNumber);
    }
    if (message.apaParkInSuccessRatio !== 0) {
      writer.uint32(77).float(message.apaParkInSuccessRatio);
    }
    if (message.apaParkInAverageTimeS !== 0) {
      writer.uint32(85).float(message.apaParkInAverageTimeS);
    }
    if (message.apaParkOutAverageTimeS !== 0) {
      writer.uint32(93).float(message.apaParkOutAverageTimeS);
    }
    if (message.hpaPedestrianAvoidNumber !== 0) {
      writer.uint32(96).uint32(message.hpaPedestrianAvoidNumber);
    }
    if (message.hpaPassJunctionNumber !== 0) {
      writer.uint32(104).uint32(message.hpaPassJunctionNumber);
    }
    if (message.hpaPassSpeedbumpNumber !== 0) {
      writer.uint32(112).uint32(message.hpaPassSpeedbumpNumber);
    }
    if (message.hpaUserInterventionNumber !== 0) {
      writer.uint32(120).uint32(message.hpaUserInterventionNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingFunctionAnalysis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingFunctionAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.apaCurrentCycleSuccTimes = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.apaCurrentCycleFailtimes = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hpaCurrentCycleSuccTimes = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mebCurrentCycleActimes = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hpaUseNumber = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.hpaParkInSuccessNumber = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.apaUseNumber = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.apaParkInSuccessNumber = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.apaParkInSuccessRatio = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.apaParkInAverageTimeS = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.apaParkOutAverageTimeS = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.hpaPedestrianAvoidNumber = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.hpaPassJunctionNumber = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.hpaPassSpeedbumpNumber = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.hpaUserInterventionNumber = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingFunctionAnalysis {
    return {
      apaCurrentCycleSuccTimes: isSet(object.apaCurrentCycleSuccTimes)
        ? globalThis.Number(object.apaCurrentCycleSuccTimes)
        : 0,
      apaCurrentCycleFailtimes: isSet(object.apaCurrentCycleFailtimes)
        ? globalThis.Number(object.apaCurrentCycleFailtimes)
        : 0,
      hpaCurrentCycleSuccTimes: isSet(object.hpaCurrentCycleSuccTimes)
        ? globalThis.Number(object.hpaCurrentCycleSuccTimes)
        : 0,
      mebCurrentCycleActimes: isSet(object.mebCurrentCycleActimes)
        ? globalThis.Number(object.mebCurrentCycleActimes)
        : 0,
      hpaUseNumber: isSet(object.hpaUseNumber) ? globalThis.Number(object.hpaUseNumber) : 0,
      hpaParkInSuccessNumber: isSet(object.hpaParkInSuccessNumber)
        ? globalThis.Number(object.hpaParkInSuccessNumber)
        : 0,
      apaUseNumber: isSet(object.apaUseNumber) ? globalThis.Number(object.apaUseNumber) : 0,
      apaParkInSuccessNumber: isSet(object.apaParkInSuccessNumber)
        ? globalThis.Number(object.apaParkInSuccessNumber)
        : 0,
      apaParkInSuccessRatio: isSet(object.apaParkInSuccessRatio) ? globalThis.Number(object.apaParkInSuccessRatio) : 0,
      apaParkInAverageTimeS: isSet(object.apaParkInAverageTimeS) ? globalThis.Number(object.apaParkInAverageTimeS) : 0,
      apaParkOutAverageTimeS: isSet(object.apaParkOutAverageTimeS)
        ? globalThis.Number(object.apaParkOutAverageTimeS)
        : 0,
      hpaPedestrianAvoidNumber: isSet(object.hpaPedestrianAvoidNumber)
        ? globalThis.Number(object.hpaPedestrianAvoidNumber)
        : 0,
      hpaPassJunctionNumber: isSet(object.hpaPassJunctionNumber) ? globalThis.Number(object.hpaPassJunctionNumber) : 0,
      hpaPassSpeedbumpNumber: isSet(object.hpaPassSpeedbumpNumber)
        ? globalThis.Number(object.hpaPassSpeedbumpNumber)
        : 0,
      hpaUserInterventionNumber: isSet(object.hpaUserInterventionNumber)
        ? globalThis.Number(object.hpaUserInterventionNumber)
        : 0,
    };
  },

  toJSON(message: ParkingFunctionAnalysis): unknown {
    const obj: any = {};
    if (message.apaCurrentCycleSuccTimes !== 0) {
      obj.apaCurrentCycleSuccTimes = Math.round(message.apaCurrentCycleSuccTimes);
    }
    if (message.apaCurrentCycleFailtimes !== 0) {
      obj.apaCurrentCycleFailtimes = Math.round(message.apaCurrentCycleFailtimes);
    }
    if (message.hpaCurrentCycleSuccTimes !== 0) {
      obj.hpaCurrentCycleSuccTimes = Math.round(message.hpaCurrentCycleSuccTimes);
    }
    if (message.mebCurrentCycleActimes !== 0) {
      obj.mebCurrentCycleActimes = Math.round(message.mebCurrentCycleActimes);
    }
    if (message.hpaUseNumber !== 0) {
      obj.hpaUseNumber = Math.round(message.hpaUseNumber);
    }
    if (message.hpaParkInSuccessNumber !== 0) {
      obj.hpaParkInSuccessNumber = Math.round(message.hpaParkInSuccessNumber);
    }
    if (message.apaUseNumber !== 0) {
      obj.apaUseNumber = Math.round(message.apaUseNumber);
    }
    if (message.apaParkInSuccessNumber !== 0) {
      obj.apaParkInSuccessNumber = Math.round(message.apaParkInSuccessNumber);
    }
    if (message.apaParkInSuccessRatio !== 0) {
      obj.apaParkInSuccessRatio = message.apaParkInSuccessRatio;
    }
    if (message.apaParkInAverageTimeS !== 0) {
      obj.apaParkInAverageTimeS = message.apaParkInAverageTimeS;
    }
    if (message.apaParkOutAverageTimeS !== 0) {
      obj.apaParkOutAverageTimeS = message.apaParkOutAverageTimeS;
    }
    if (message.hpaPedestrianAvoidNumber !== 0) {
      obj.hpaPedestrianAvoidNumber = Math.round(message.hpaPedestrianAvoidNumber);
    }
    if (message.hpaPassJunctionNumber !== 0) {
      obj.hpaPassJunctionNumber = Math.round(message.hpaPassJunctionNumber);
    }
    if (message.hpaPassSpeedbumpNumber !== 0) {
      obj.hpaPassSpeedbumpNumber = Math.round(message.hpaPassSpeedbumpNumber);
    }
    if (message.hpaUserInterventionNumber !== 0) {
      obj.hpaUserInterventionNumber = Math.round(message.hpaUserInterventionNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingFunctionAnalysis>, I>>(base?: I): ParkingFunctionAnalysis {
    return ParkingFunctionAnalysis.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingFunctionAnalysis>, I>>(object: I): ParkingFunctionAnalysis {
    const message = createBaseParkingFunctionAnalysis();
    message.apaCurrentCycleSuccTimes = object.apaCurrentCycleSuccTimes ?? 0;
    message.apaCurrentCycleFailtimes = object.apaCurrentCycleFailtimes ?? 0;
    message.hpaCurrentCycleSuccTimes = object.hpaCurrentCycleSuccTimes ?? 0;
    message.mebCurrentCycleActimes = object.mebCurrentCycleActimes ?? 0;
    message.hpaUseNumber = object.hpaUseNumber ?? 0;
    message.hpaParkInSuccessNumber = object.hpaParkInSuccessNumber ?? 0;
    message.apaUseNumber = object.apaUseNumber ?? 0;
    message.apaParkInSuccessNumber = object.apaParkInSuccessNumber ?? 0;
    message.apaParkInSuccessRatio = object.apaParkInSuccessRatio ?? 0;
    message.apaParkInAverageTimeS = object.apaParkInAverageTimeS ?? 0;
    message.apaParkOutAverageTimeS = object.apaParkOutAverageTimeS ?? 0;
    message.hpaPedestrianAvoidNumber = object.hpaPedestrianAvoidNumber ?? 0;
    message.hpaPassJunctionNumber = object.hpaPassJunctionNumber ?? 0;
    message.hpaPassSpeedbumpNumber = object.hpaPassSpeedbumpNumber ?? 0;
    message.hpaUserInterventionNumber = object.hpaUserInterventionNumber ?? 0;
    return message;
  },
};

function createBaseAvmPadRequest(): AvmPadRequest {
  return {
    avmChannelButtonReqEnum: 0,
    avmFrontRearWheelReqEnum: 0,
    apa360ButtonReqEnum: 0,
    apaSettingsVoicePromptReqEnum: 0,
    apaSettingsProtocalPromptReqEnum: 0,
    apaSettingsTransparentChassisReqEnum: 0,
    padVideoChannelEnum: 0,
  };
}

export const AvmPadRequest: MessageFns<AvmPadRequest> = {
  encode(message: AvmPadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.avmChannelButtonReqEnum !== 0) {
      writer.uint32(8).uint32(message.avmChannelButtonReqEnum);
    }
    if (message.avmFrontRearWheelReqEnum !== 0) {
      writer.uint32(16).uint32(message.avmFrontRearWheelReqEnum);
    }
    if (message.apa360ButtonReqEnum !== 0) {
      writer.uint32(24).uint32(message.apa360ButtonReqEnum);
    }
    if (message.apaSettingsVoicePromptReqEnum !== 0) {
      writer.uint32(32).uint32(message.apaSettingsVoicePromptReqEnum);
    }
    if (message.apaSettingsProtocalPromptReqEnum !== 0) {
      writer.uint32(40).uint32(message.apaSettingsProtocalPromptReqEnum);
    }
    if (message.apaSettingsTransparentChassisReqEnum !== 0) {
      writer.uint32(48).uint32(message.apaSettingsTransparentChassisReqEnum);
    }
    if (message.padVideoChannelEnum !== 0) {
      writer.uint32(56).uint32(message.padVideoChannelEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvmPadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvmPadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.avmChannelButtonReqEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.avmFrontRearWheelReqEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.apa360ButtonReqEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.apaSettingsVoicePromptReqEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.apaSettingsProtocalPromptReqEnum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.apaSettingsTransparentChassisReqEnum = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.padVideoChannelEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvmPadRequest {
    return {
      avmChannelButtonReqEnum: isSet(object.avmChannelButtonReqEnum)
        ? globalThis.Number(object.avmChannelButtonReqEnum)
        : 0,
      avmFrontRearWheelReqEnum: isSet(object.avmFrontRearWheelReqEnum)
        ? globalThis.Number(object.avmFrontRearWheelReqEnum)
        : 0,
      apa360ButtonReqEnum: isSet(object.apa360ButtonReqEnum) ? globalThis.Number(object.apa360ButtonReqEnum) : 0,
      apaSettingsVoicePromptReqEnum: isSet(object.apaSettingsVoicePromptReqEnum)
        ? globalThis.Number(object.apaSettingsVoicePromptReqEnum)
        : 0,
      apaSettingsProtocalPromptReqEnum: isSet(object.apaSettingsProtocalPromptReqEnum)
        ? globalThis.Number(object.apaSettingsProtocalPromptReqEnum)
        : 0,
      apaSettingsTransparentChassisReqEnum: isSet(object.apaSettingsTransparentChassisReqEnum)
        ? globalThis.Number(object.apaSettingsTransparentChassisReqEnum)
        : 0,
      padVideoChannelEnum: isSet(object.padVideoChannelEnum) ? globalThis.Number(object.padVideoChannelEnum) : 0,
    };
  },

  toJSON(message: AvmPadRequest): unknown {
    const obj: any = {};
    if (message.avmChannelButtonReqEnum !== 0) {
      obj.avmChannelButtonReqEnum = Math.round(message.avmChannelButtonReqEnum);
    }
    if (message.avmFrontRearWheelReqEnum !== 0) {
      obj.avmFrontRearWheelReqEnum = Math.round(message.avmFrontRearWheelReqEnum);
    }
    if (message.apa360ButtonReqEnum !== 0) {
      obj.apa360ButtonReqEnum = Math.round(message.apa360ButtonReqEnum);
    }
    if (message.apaSettingsVoicePromptReqEnum !== 0) {
      obj.apaSettingsVoicePromptReqEnum = Math.round(message.apaSettingsVoicePromptReqEnum);
    }
    if (message.apaSettingsProtocalPromptReqEnum !== 0) {
      obj.apaSettingsProtocalPromptReqEnum = Math.round(message.apaSettingsProtocalPromptReqEnum);
    }
    if (message.apaSettingsTransparentChassisReqEnum !== 0) {
      obj.apaSettingsTransparentChassisReqEnum = Math.round(message.apaSettingsTransparentChassisReqEnum);
    }
    if (message.padVideoChannelEnum !== 0) {
      obj.padVideoChannelEnum = Math.round(message.padVideoChannelEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AvmPadRequest>, I>>(base?: I): AvmPadRequest {
    return AvmPadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AvmPadRequest>, I>>(object: I): AvmPadRequest {
    const message = createBaseAvmPadRequest();
    message.avmChannelButtonReqEnum = object.avmChannelButtonReqEnum ?? 0;
    message.avmFrontRearWheelReqEnum = object.avmFrontRearWheelReqEnum ?? 0;
    message.apa360ButtonReqEnum = object.apa360ButtonReqEnum ?? 0;
    message.apaSettingsVoicePromptReqEnum = object.apaSettingsVoicePromptReqEnum ?? 0;
    message.apaSettingsProtocalPromptReqEnum = object.apaSettingsProtocalPromptReqEnum ?? 0;
    message.apaSettingsTransparentChassisReqEnum = object.apaSettingsTransparentChassisReqEnum ?? 0;
    message.padVideoChannelEnum = object.padVideoChannelEnum ?? 0;
    return message;
  },
};

function createBaseParkingPadRequest(): ParkingPadRequest {
  return {
    apaActReqEnum: 0,
    rpaActReqEnum: 0,
    lpaActReqEnum: 0,
    apaParkModeReqEnum: 0,
    apaParkTypeReqEnum: 0,
    apaParkSlotSelectId: 0,
    apaParkInReqEnum: 0,
    apaPauseReqEnum: 0,
    apaContinueReqEnum: 0,
    apaExitReqEnum: 0,
    apaSpdTypeReqEnum: 0,
    apaParkOutReqEnum: 0,
    apaParkOutDirectionReqEnum: 0,
    apaSelfSelectPoint0: undefined,
    apaSelfSelectPoint1: undefined,
    apaSelfSelectPoint2: undefined,
    apaSelfSelectPoint3: undefined,
    apaSelfSelectSlotAngleDeg: 0,
    apaSelfSelectSlotXM: 0,
    apaSelfSelectSlotYM: 0,
    apaSelfSelectSlotLengthM: 0,
    apaSelfSelectSlotWidthM: 0,
    apaMoveSelfSelectEnum: 0,
    parkingVoiceBroadcastTypeReqEnum: 0,
    hpaActReqEnum: 0,
    hpaParkInMapBuildReqEnum: 0,
    hpaParkOutMapBuildReqEnum: 0,
    hpaParkInMapRebuildReqEnum: 0,
    hpaParkOutMapRebuildReqEnum: 0,
    hpaMapBuildConfirmReqEnum: 0,
    hpaParkInReqEnum: 0,
    hpaParkOutReqEnum: 0,
    hpaPauseReqEnum: 0,
    hpaContinueReqEnum: 0,
    hpaExitReqEnum: 0,
    hpaBackReqEnum: 0,
    hpaAppControlReqEnum: 0,
    hpaSpdTypeReqEnum: 0,
    hpaMapId: 0,
    hpaDeleteMapReqEnum: 0,
    pawReqEnum: 0,
    tbaActReqEnum: 0,
    tbaStartParkReqEnum: 0,
    tbaPauseReqEnum: 0,
    tbaContinueReqEnum: 0,
    padDisplayModeEnum: 0,
  };
}

export const ParkingPadRequest: MessageFns<ParkingPadRequest> = {
  encode(message: ParkingPadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apaActReqEnum !== 0) {
      writer.uint32(8).uint32(message.apaActReqEnum);
    }
    if (message.rpaActReqEnum !== 0) {
      writer.uint32(16).uint32(message.rpaActReqEnum);
    }
    if (message.lpaActReqEnum !== 0) {
      writer.uint32(24).uint32(message.lpaActReqEnum);
    }
    if (message.apaParkModeReqEnum !== 0) {
      writer.uint32(32).uint32(message.apaParkModeReqEnum);
    }
    if (message.apaParkTypeReqEnum !== 0) {
      writer.uint32(40).uint32(message.apaParkTypeReqEnum);
    }
    if (message.apaParkSlotSelectId !== 0) {
      writer.uint32(48).int64(message.apaParkSlotSelectId);
    }
    if (message.apaParkInReqEnum !== 0) {
      writer.uint32(56).uint32(message.apaParkInReqEnum);
    }
    if (message.apaPauseReqEnum !== 0) {
      writer.uint32(64).uint32(message.apaPauseReqEnum);
    }
    if (message.apaContinueReqEnum !== 0) {
      writer.uint32(72).uint32(message.apaContinueReqEnum);
    }
    if (message.apaExitReqEnum !== 0) {
      writer.uint32(80).uint32(message.apaExitReqEnum);
    }
    if (message.apaSpdTypeReqEnum !== 0) {
      writer.uint32(88).uint32(message.apaSpdTypeReqEnum);
    }
    if (message.apaParkOutReqEnum !== 0) {
      writer.uint32(96).uint32(message.apaParkOutReqEnum);
    }
    if (message.apaParkOutDirectionReqEnum !== 0) {
      writer.uint32(104).uint32(message.apaParkOutDirectionReqEnum);
    }
    if (message.apaSelfSelectPoint0 !== undefined) {
      Point3f.encode(message.apaSelfSelectPoint0, writer.uint32(114).fork()).join();
    }
    if (message.apaSelfSelectPoint1 !== undefined) {
      Point3f.encode(message.apaSelfSelectPoint1, writer.uint32(122).fork()).join();
    }
    if (message.apaSelfSelectPoint2 !== undefined) {
      Point3f.encode(message.apaSelfSelectPoint2, writer.uint32(130).fork()).join();
    }
    if (message.apaSelfSelectPoint3 !== undefined) {
      Point3f.encode(message.apaSelfSelectPoint3, writer.uint32(138).fork()).join();
    }
    if (message.apaSelfSelectSlotAngleDeg !== 0) {
      writer.uint32(149).float(message.apaSelfSelectSlotAngleDeg);
    }
    if (message.apaSelfSelectSlotXM !== 0) {
      writer.uint32(157).float(message.apaSelfSelectSlotXM);
    }
    if (message.apaSelfSelectSlotYM !== 0) {
      writer.uint32(165).float(message.apaSelfSelectSlotYM);
    }
    if (message.apaSelfSelectSlotLengthM !== 0) {
      writer.uint32(173).float(message.apaSelfSelectSlotLengthM);
    }
    if (message.apaSelfSelectSlotWidthM !== 0) {
      writer.uint32(181).float(message.apaSelfSelectSlotWidthM);
    }
    if (message.apaMoveSelfSelectEnum !== 0) {
      writer.uint32(184).uint32(message.apaMoveSelfSelectEnum);
    }
    if (message.parkingVoiceBroadcastTypeReqEnum !== 0) {
      writer.uint32(192).uint32(message.parkingVoiceBroadcastTypeReqEnum);
    }
    if (message.hpaActReqEnum !== 0) {
      writer.uint32(200).uint32(message.hpaActReqEnum);
    }
    if (message.hpaParkInMapBuildReqEnum !== 0) {
      writer.uint32(208).uint32(message.hpaParkInMapBuildReqEnum);
    }
    if (message.hpaParkOutMapBuildReqEnum !== 0) {
      writer.uint32(216).uint32(message.hpaParkOutMapBuildReqEnum);
    }
    if (message.hpaParkInMapRebuildReqEnum !== 0) {
      writer.uint32(224).uint32(message.hpaParkInMapRebuildReqEnum);
    }
    if (message.hpaParkOutMapRebuildReqEnum !== 0) {
      writer.uint32(232).uint32(message.hpaParkOutMapRebuildReqEnum);
    }
    if (message.hpaMapBuildConfirmReqEnum !== 0) {
      writer.uint32(240).uint32(message.hpaMapBuildConfirmReqEnum);
    }
    if (message.hpaParkInReqEnum !== 0) {
      writer.uint32(248).uint32(message.hpaParkInReqEnum);
    }
    if (message.hpaParkOutReqEnum !== 0) {
      writer.uint32(256).uint32(message.hpaParkOutReqEnum);
    }
    if (message.hpaPauseReqEnum !== 0) {
      writer.uint32(264).uint32(message.hpaPauseReqEnum);
    }
    if (message.hpaContinueReqEnum !== 0) {
      writer.uint32(272).uint32(message.hpaContinueReqEnum);
    }
    if (message.hpaExitReqEnum !== 0) {
      writer.uint32(280).uint32(message.hpaExitReqEnum);
    }
    if (message.hpaBackReqEnum !== 0) {
      writer.uint32(288).uint32(message.hpaBackReqEnum);
    }
    if (message.hpaAppControlReqEnum !== 0) {
      writer.uint32(296).uint32(message.hpaAppControlReqEnum);
    }
    if (message.hpaSpdTypeReqEnum !== 0) {
      writer.uint32(304).uint32(message.hpaSpdTypeReqEnum);
    }
    if (message.hpaMapId !== 0) {
      writer.uint32(312).int64(message.hpaMapId);
    }
    if (message.hpaDeleteMapReqEnum !== 0) {
      writer.uint32(320).uint32(message.hpaDeleteMapReqEnum);
    }
    if (message.pawReqEnum !== 0) {
      writer.uint32(328).uint32(message.pawReqEnum);
    }
    if (message.tbaActReqEnum !== 0) {
      writer.uint32(336).uint32(message.tbaActReqEnum);
    }
    if (message.tbaStartParkReqEnum !== 0) {
      writer.uint32(344).uint32(message.tbaStartParkReqEnum);
    }
    if (message.tbaPauseReqEnum !== 0) {
      writer.uint32(352).uint32(message.tbaPauseReqEnum);
    }
    if (message.tbaContinueReqEnum !== 0) {
      writer.uint32(360).uint32(message.tbaContinueReqEnum);
    }
    if (message.padDisplayModeEnum !== 0) {
      writer.uint32(368).uint32(message.padDisplayModeEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingPadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingPadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.apaActReqEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rpaActReqEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lpaActReqEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.apaParkModeReqEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.apaParkTypeReqEnum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.apaParkSlotSelectId = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.apaParkInReqEnum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.apaPauseReqEnum = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.apaContinueReqEnum = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.apaExitReqEnum = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.apaSpdTypeReqEnum = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.apaParkOutReqEnum = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.apaParkOutDirectionReqEnum = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.apaSelfSelectPoint0 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.apaSelfSelectPoint1 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.apaSelfSelectPoint2 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.apaSelfSelectPoint3 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 149) {
            break;
          }

          message.apaSelfSelectSlotAngleDeg = reader.float();
          continue;
        }
        case 19: {
          if (tag !== 157) {
            break;
          }

          message.apaSelfSelectSlotXM = reader.float();
          continue;
        }
        case 20: {
          if (tag !== 165) {
            break;
          }

          message.apaSelfSelectSlotYM = reader.float();
          continue;
        }
        case 21: {
          if (tag !== 173) {
            break;
          }

          message.apaSelfSelectSlotLengthM = reader.float();
          continue;
        }
        case 22: {
          if (tag !== 181) {
            break;
          }

          message.apaSelfSelectSlotWidthM = reader.float();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.apaMoveSelfSelectEnum = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.parkingVoiceBroadcastTypeReqEnum = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.hpaActReqEnum = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.hpaParkInMapBuildReqEnum = reader.uint32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.hpaParkOutMapBuildReqEnum = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.hpaParkInMapRebuildReqEnum = reader.uint32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.hpaParkOutMapRebuildReqEnum = reader.uint32();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.hpaMapBuildConfirmReqEnum = reader.uint32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.hpaParkInReqEnum = reader.uint32();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.hpaParkOutReqEnum = reader.uint32();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.hpaPauseReqEnum = reader.uint32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.hpaContinueReqEnum = reader.uint32();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.hpaExitReqEnum = reader.uint32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.hpaBackReqEnum = reader.uint32();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.hpaAppControlReqEnum = reader.uint32();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.hpaSpdTypeReqEnum = reader.uint32();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.hpaMapId = longToNumber(reader.int64());
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.hpaDeleteMapReqEnum = reader.uint32();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.pawReqEnum = reader.uint32();
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }

          message.tbaActReqEnum = reader.uint32();
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }

          message.tbaStartParkReqEnum = reader.uint32();
          continue;
        }
        case 44: {
          if (tag !== 352) {
            break;
          }

          message.tbaPauseReqEnum = reader.uint32();
          continue;
        }
        case 45: {
          if (tag !== 360) {
            break;
          }

          message.tbaContinueReqEnum = reader.uint32();
          continue;
        }
        case 46: {
          if (tag !== 368) {
            break;
          }

          message.padDisplayModeEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingPadRequest {
    return {
      apaActReqEnum: isSet(object.apaActReqEnum) ? globalThis.Number(object.apaActReqEnum) : 0,
      rpaActReqEnum: isSet(object.rpaActReqEnum) ? globalThis.Number(object.rpaActReqEnum) : 0,
      lpaActReqEnum: isSet(object.lpaActReqEnum) ? globalThis.Number(object.lpaActReqEnum) : 0,
      apaParkModeReqEnum: isSet(object.apaParkModeReqEnum) ? globalThis.Number(object.apaParkModeReqEnum) : 0,
      apaParkTypeReqEnum: isSet(object.apaParkTypeReqEnum) ? globalThis.Number(object.apaParkTypeReqEnum) : 0,
      apaParkSlotSelectId: isSet(object.apaParkSlotSelectId) ? globalThis.Number(object.apaParkSlotSelectId) : 0,
      apaParkInReqEnum: isSet(object.apaParkInReqEnum) ? globalThis.Number(object.apaParkInReqEnum) : 0,
      apaPauseReqEnum: isSet(object.apaPauseReqEnum) ? globalThis.Number(object.apaPauseReqEnum) : 0,
      apaContinueReqEnum: isSet(object.apaContinueReqEnum) ? globalThis.Number(object.apaContinueReqEnum) : 0,
      apaExitReqEnum: isSet(object.apaExitReqEnum) ? globalThis.Number(object.apaExitReqEnum) : 0,
      apaSpdTypeReqEnum: isSet(object.apaSpdTypeReqEnum) ? globalThis.Number(object.apaSpdTypeReqEnum) : 0,
      apaParkOutReqEnum: isSet(object.apaParkOutReqEnum) ? globalThis.Number(object.apaParkOutReqEnum) : 0,
      apaParkOutDirectionReqEnum: isSet(object.apaParkOutDirectionReqEnum)
        ? globalThis.Number(object.apaParkOutDirectionReqEnum)
        : 0,
      apaSelfSelectPoint0: isSet(object.apaSelfSelectPoint0) ? Point3f.fromJSON(object.apaSelfSelectPoint0) : undefined,
      apaSelfSelectPoint1: isSet(object.apaSelfSelectPoint1) ? Point3f.fromJSON(object.apaSelfSelectPoint1) : undefined,
      apaSelfSelectPoint2: isSet(object.apaSelfSelectPoint2) ? Point3f.fromJSON(object.apaSelfSelectPoint2) : undefined,
      apaSelfSelectPoint3: isSet(object.apaSelfSelectPoint3) ? Point3f.fromJSON(object.apaSelfSelectPoint3) : undefined,
      apaSelfSelectSlotAngleDeg: isSet(object.apaSelfSelectSlotAngleDeg)
        ? globalThis.Number(object.apaSelfSelectSlotAngleDeg)
        : 0,
      apaSelfSelectSlotXM: isSet(object.apaSelfSelectSlotXM) ? globalThis.Number(object.apaSelfSelectSlotXM) : 0,
      apaSelfSelectSlotYM: isSet(object.apaSelfSelectSlotYM) ? globalThis.Number(object.apaSelfSelectSlotYM) : 0,
      apaSelfSelectSlotLengthM: isSet(object.apaSelfSelectSlotLengthM)
        ? globalThis.Number(object.apaSelfSelectSlotLengthM)
        : 0,
      apaSelfSelectSlotWidthM: isSet(object.apaSelfSelectSlotWidthM)
        ? globalThis.Number(object.apaSelfSelectSlotWidthM)
        : 0,
      apaMoveSelfSelectEnum: isSet(object.apaMoveSelfSelectEnum) ? globalThis.Number(object.apaMoveSelfSelectEnum) : 0,
      parkingVoiceBroadcastTypeReqEnum: isSet(object.parkingVoiceBroadcastTypeReqEnum)
        ? globalThis.Number(object.parkingVoiceBroadcastTypeReqEnum)
        : 0,
      hpaActReqEnum: isSet(object.hpaActReqEnum) ? globalThis.Number(object.hpaActReqEnum) : 0,
      hpaParkInMapBuildReqEnum: isSet(object.hpaParkInMapBuildReqEnum)
        ? globalThis.Number(object.hpaParkInMapBuildReqEnum)
        : 0,
      hpaParkOutMapBuildReqEnum: isSet(object.hpaParkOutMapBuildReqEnum)
        ? globalThis.Number(object.hpaParkOutMapBuildReqEnum)
        : 0,
      hpaParkInMapRebuildReqEnum: isSet(object.hpaParkInMapRebuildReqEnum)
        ? globalThis.Number(object.hpaParkInMapRebuildReqEnum)
        : 0,
      hpaParkOutMapRebuildReqEnum: isSet(object.hpaParkOutMapRebuildReqEnum)
        ? globalThis.Number(object.hpaParkOutMapRebuildReqEnum)
        : 0,
      hpaMapBuildConfirmReqEnum: isSet(object.hpaMapBuildConfirmReqEnum)
        ? globalThis.Number(object.hpaMapBuildConfirmReqEnum)
        : 0,
      hpaParkInReqEnum: isSet(object.hpaParkInReqEnum) ? globalThis.Number(object.hpaParkInReqEnum) : 0,
      hpaParkOutReqEnum: isSet(object.hpaParkOutReqEnum) ? globalThis.Number(object.hpaParkOutReqEnum) : 0,
      hpaPauseReqEnum: isSet(object.hpaPauseReqEnum) ? globalThis.Number(object.hpaPauseReqEnum) : 0,
      hpaContinueReqEnum: isSet(object.hpaContinueReqEnum) ? globalThis.Number(object.hpaContinueReqEnum) : 0,
      hpaExitReqEnum: isSet(object.hpaExitReqEnum) ? globalThis.Number(object.hpaExitReqEnum) : 0,
      hpaBackReqEnum: isSet(object.hpaBackReqEnum) ? globalThis.Number(object.hpaBackReqEnum) : 0,
      hpaAppControlReqEnum: isSet(object.hpaAppControlReqEnum) ? globalThis.Number(object.hpaAppControlReqEnum) : 0,
      hpaSpdTypeReqEnum: isSet(object.hpaSpdTypeReqEnum) ? globalThis.Number(object.hpaSpdTypeReqEnum) : 0,
      hpaMapId: isSet(object.hpaMapId) ? globalThis.Number(object.hpaMapId) : 0,
      hpaDeleteMapReqEnum: isSet(object.hpaDeleteMapReqEnum) ? globalThis.Number(object.hpaDeleteMapReqEnum) : 0,
      pawReqEnum: isSet(object.pawReqEnum) ? globalThis.Number(object.pawReqEnum) : 0,
      tbaActReqEnum: isSet(object.tbaActReqEnum) ? globalThis.Number(object.tbaActReqEnum) : 0,
      tbaStartParkReqEnum: isSet(object.tbaStartParkReqEnum) ? globalThis.Number(object.tbaStartParkReqEnum) : 0,
      tbaPauseReqEnum: isSet(object.tbaPauseReqEnum) ? globalThis.Number(object.tbaPauseReqEnum) : 0,
      tbaContinueReqEnum: isSet(object.tbaContinueReqEnum) ? globalThis.Number(object.tbaContinueReqEnum) : 0,
      padDisplayModeEnum: isSet(object.padDisplayModeEnum) ? globalThis.Number(object.padDisplayModeEnum) : 0,
    };
  },

  toJSON(message: ParkingPadRequest): unknown {
    const obj: any = {};
    if (message.apaActReqEnum !== 0) {
      obj.apaActReqEnum = Math.round(message.apaActReqEnum);
    }
    if (message.rpaActReqEnum !== 0) {
      obj.rpaActReqEnum = Math.round(message.rpaActReqEnum);
    }
    if (message.lpaActReqEnum !== 0) {
      obj.lpaActReqEnum = Math.round(message.lpaActReqEnum);
    }
    if (message.apaParkModeReqEnum !== 0) {
      obj.apaParkModeReqEnum = Math.round(message.apaParkModeReqEnum);
    }
    if (message.apaParkTypeReqEnum !== 0) {
      obj.apaParkTypeReqEnum = Math.round(message.apaParkTypeReqEnum);
    }
    if (message.apaParkSlotSelectId !== 0) {
      obj.apaParkSlotSelectId = Math.round(message.apaParkSlotSelectId);
    }
    if (message.apaParkInReqEnum !== 0) {
      obj.apaParkInReqEnum = Math.round(message.apaParkInReqEnum);
    }
    if (message.apaPauseReqEnum !== 0) {
      obj.apaPauseReqEnum = Math.round(message.apaPauseReqEnum);
    }
    if (message.apaContinueReqEnum !== 0) {
      obj.apaContinueReqEnum = Math.round(message.apaContinueReqEnum);
    }
    if (message.apaExitReqEnum !== 0) {
      obj.apaExitReqEnum = Math.round(message.apaExitReqEnum);
    }
    if (message.apaSpdTypeReqEnum !== 0) {
      obj.apaSpdTypeReqEnum = Math.round(message.apaSpdTypeReqEnum);
    }
    if (message.apaParkOutReqEnum !== 0) {
      obj.apaParkOutReqEnum = Math.round(message.apaParkOutReqEnum);
    }
    if (message.apaParkOutDirectionReqEnum !== 0) {
      obj.apaParkOutDirectionReqEnum = Math.round(message.apaParkOutDirectionReqEnum);
    }
    if (message.apaSelfSelectPoint0 !== undefined) {
      obj.apaSelfSelectPoint0 = Point3f.toJSON(message.apaSelfSelectPoint0);
    }
    if (message.apaSelfSelectPoint1 !== undefined) {
      obj.apaSelfSelectPoint1 = Point3f.toJSON(message.apaSelfSelectPoint1);
    }
    if (message.apaSelfSelectPoint2 !== undefined) {
      obj.apaSelfSelectPoint2 = Point3f.toJSON(message.apaSelfSelectPoint2);
    }
    if (message.apaSelfSelectPoint3 !== undefined) {
      obj.apaSelfSelectPoint3 = Point3f.toJSON(message.apaSelfSelectPoint3);
    }
    if (message.apaSelfSelectSlotAngleDeg !== 0) {
      obj.apaSelfSelectSlotAngleDeg = message.apaSelfSelectSlotAngleDeg;
    }
    if (message.apaSelfSelectSlotXM !== 0) {
      obj.apaSelfSelectSlotXM = message.apaSelfSelectSlotXM;
    }
    if (message.apaSelfSelectSlotYM !== 0) {
      obj.apaSelfSelectSlotYM = message.apaSelfSelectSlotYM;
    }
    if (message.apaSelfSelectSlotLengthM !== 0) {
      obj.apaSelfSelectSlotLengthM = message.apaSelfSelectSlotLengthM;
    }
    if (message.apaSelfSelectSlotWidthM !== 0) {
      obj.apaSelfSelectSlotWidthM = message.apaSelfSelectSlotWidthM;
    }
    if (message.apaMoveSelfSelectEnum !== 0) {
      obj.apaMoveSelfSelectEnum = Math.round(message.apaMoveSelfSelectEnum);
    }
    if (message.parkingVoiceBroadcastTypeReqEnum !== 0) {
      obj.parkingVoiceBroadcastTypeReqEnum = Math.round(message.parkingVoiceBroadcastTypeReqEnum);
    }
    if (message.hpaActReqEnum !== 0) {
      obj.hpaActReqEnum = Math.round(message.hpaActReqEnum);
    }
    if (message.hpaParkInMapBuildReqEnum !== 0) {
      obj.hpaParkInMapBuildReqEnum = Math.round(message.hpaParkInMapBuildReqEnum);
    }
    if (message.hpaParkOutMapBuildReqEnum !== 0) {
      obj.hpaParkOutMapBuildReqEnum = Math.round(message.hpaParkOutMapBuildReqEnum);
    }
    if (message.hpaParkInMapRebuildReqEnum !== 0) {
      obj.hpaParkInMapRebuildReqEnum = Math.round(message.hpaParkInMapRebuildReqEnum);
    }
    if (message.hpaParkOutMapRebuildReqEnum !== 0) {
      obj.hpaParkOutMapRebuildReqEnum = Math.round(message.hpaParkOutMapRebuildReqEnum);
    }
    if (message.hpaMapBuildConfirmReqEnum !== 0) {
      obj.hpaMapBuildConfirmReqEnum = Math.round(message.hpaMapBuildConfirmReqEnum);
    }
    if (message.hpaParkInReqEnum !== 0) {
      obj.hpaParkInReqEnum = Math.round(message.hpaParkInReqEnum);
    }
    if (message.hpaParkOutReqEnum !== 0) {
      obj.hpaParkOutReqEnum = Math.round(message.hpaParkOutReqEnum);
    }
    if (message.hpaPauseReqEnum !== 0) {
      obj.hpaPauseReqEnum = Math.round(message.hpaPauseReqEnum);
    }
    if (message.hpaContinueReqEnum !== 0) {
      obj.hpaContinueReqEnum = Math.round(message.hpaContinueReqEnum);
    }
    if (message.hpaExitReqEnum !== 0) {
      obj.hpaExitReqEnum = Math.round(message.hpaExitReqEnum);
    }
    if (message.hpaBackReqEnum !== 0) {
      obj.hpaBackReqEnum = Math.round(message.hpaBackReqEnum);
    }
    if (message.hpaAppControlReqEnum !== 0) {
      obj.hpaAppControlReqEnum = Math.round(message.hpaAppControlReqEnum);
    }
    if (message.hpaSpdTypeReqEnum !== 0) {
      obj.hpaSpdTypeReqEnum = Math.round(message.hpaSpdTypeReqEnum);
    }
    if (message.hpaMapId !== 0) {
      obj.hpaMapId = Math.round(message.hpaMapId);
    }
    if (message.hpaDeleteMapReqEnum !== 0) {
      obj.hpaDeleteMapReqEnum = Math.round(message.hpaDeleteMapReqEnum);
    }
    if (message.pawReqEnum !== 0) {
      obj.pawReqEnum = Math.round(message.pawReqEnum);
    }
    if (message.tbaActReqEnum !== 0) {
      obj.tbaActReqEnum = Math.round(message.tbaActReqEnum);
    }
    if (message.tbaStartParkReqEnum !== 0) {
      obj.tbaStartParkReqEnum = Math.round(message.tbaStartParkReqEnum);
    }
    if (message.tbaPauseReqEnum !== 0) {
      obj.tbaPauseReqEnum = Math.round(message.tbaPauseReqEnum);
    }
    if (message.tbaContinueReqEnum !== 0) {
      obj.tbaContinueReqEnum = Math.round(message.tbaContinueReqEnum);
    }
    if (message.padDisplayModeEnum !== 0) {
      obj.padDisplayModeEnum = Math.round(message.padDisplayModeEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingPadRequest>, I>>(base?: I): ParkingPadRequest {
    return ParkingPadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingPadRequest>, I>>(object: I): ParkingPadRequest {
    const message = createBaseParkingPadRequest();
    message.apaActReqEnum = object.apaActReqEnum ?? 0;
    message.rpaActReqEnum = object.rpaActReqEnum ?? 0;
    message.lpaActReqEnum = object.lpaActReqEnum ?? 0;
    message.apaParkModeReqEnum = object.apaParkModeReqEnum ?? 0;
    message.apaParkTypeReqEnum = object.apaParkTypeReqEnum ?? 0;
    message.apaParkSlotSelectId = object.apaParkSlotSelectId ?? 0;
    message.apaParkInReqEnum = object.apaParkInReqEnum ?? 0;
    message.apaPauseReqEnum = object.apaPauseReqEnum ?? 0;
    message.apaContinueReqEnum = object.apaContinueReqEnum ?? 0;
    message.apaExitReqEnum = object.apaExitReqEnum ?? 0;
    message.apaSpdTypeReqEnum = object.apaSpdTypeReqEnum ?? 0;
    message.apaParkOutReqEnum = object.apaParkOutReqEnum ?? 0;
    message.apaParkOutDirectionReqEnum = object.apaParkOutDirectionReqEnum ?? 0;
    message.apaSelfSelectPoint0 = (object.apaSelfSelectPoint0 !== undefined && object.apaSelfSelectPoint0 !== null)
      ? Point3f.fromPartial(object.apaSelfSelectPoint0)
      : undefined;
    message.apaSelfSelectPoint1 = (object.apaSelfSelectPoint1 !== undefined && object.apaSelfSelectPoint1 !== null)
      ? Point3f.fromPartial(object.apaSelfSelectPoint1)
      : undefined;
    message.apaSelfSelectPoint2 = (object.apaSelfSelectPoint2 !== undefined && object.apaSelfSelectPoint2 !== null)
      ? Point3f.fromPartial(object.apaSelfSelectPoint2)
      : undefined;
    message.apaSelfSelectPoint3 = (object.apaSelfSelectPoint3 !== undefined && object.apaSelfSelectPoint3 !== null)
      ? Point3f.fromPartial(object.apaSelfSelectPoint3)
      : undefined;
    message.apaSelfSelectSlotAngleDeg = object.apaSelfSelectSlotAngleDeg ?? 0;
    message.apaSelfSelectSlotXM = object.apaSelfSelectSlotXM ?? 0;
    message.apaSelfSelectSlotYM = object.apaSelfSelectSlotYM ?? 0;
    message.apaSelfSelectSlotLengthM = object.apaSelfSelectSlotLengthM ?? 0;
    message.apaSelfSelectSlotWidthM = object.apaSelfSelectSlotWidthM ?? 0;
    message.apaMoveSelfSelectEnum = object.apaMoveSelfSelectEnum ?? 0;
    message.parkingVoiceBroadcastTypeReqEnum = object.parkingVoiceBroadcastTypeReqEnum ?? 0;
    message.hpaActReqEnum = object.hpaActReqEnum ?? 0;
    message.hpaParkInMapBuildReqEnum = object.hpaParkInMapBuildReqEnum ?? 0;
    message.hpaParkOutMapBuildReqEnum = object.hpaParkOutMapBuildReqEnum ?? 0;
    message.hpaParkInMapRebuildReqEnum = object.hpaParkInMapRebuildReqEnum ?? 0;
    message.hpaParkOutMapRebuildReqEnum = object.hpaParkOutMapRebuildReqEnum ?? 0;
    message.hpaMapBuildConfirmReqEnum = object.hpaMapBuildConfirmReqEnum ?? 0;
    message.hpaParkInReqEnum = object.hpaParkInReqEnum ?? 0;
    message.hpaParkOutReqEnum = object.hpaParkOutReqEnum ?? 0;
    message.hpaPauseReqEnum = object.hpaPauseReqEnum ?? 0;
    message.hpaContinueReqEnum = object.hpaContinueReqEnum ?? 0;
    message.hpaExitReqEnum = object.hpaExitReqEnum ?? 0;
    message.hpaBackReqEnum = object.hpaBackReqEnum ?? 0;
    message.hpaAppControlReqEnum = object.hpaAppControlReqEnum ?? 0;
    message.hpaSpdTypeReqEnum = object.hpaSpdTypeReqEnum ?? 0;
    message.hpaMapId = object.hpaMapId ?? 0;
    message.hpaDeleteMapReqEnum = object.hpaDeleteMapReqEnum ?? 0;
    message.pawReqEnum = object.pawReqEnum ?? 0;
    message.tbaActReqEnum = object.tbaActReqEnum ?? 0;
    message.tbaStartParkReqEnum = object.tbaStartParkReqEnum ?? 0;
    message.tbaPauseReqEnum = object.tbaPauseReqEnum ?? 0;
    message.tbaContinueReqEnum = object.tbaContinueReqEnum ?? 0;
    message.padDisplayModeEnum = object.padDisplayModeEnum ?? 0;
    return message;
  },
};

function createBaseVehicleSpeed(): VehicleSpeed {
  return { dspVehSpdKph: 0 };
}

export const VehicleSpeed: MessageFns<VehicleSpeed> = {
  encode(message: VehicleSpeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dspVehSpdKph !== 0) {
      writer.uint32(13).float(message.dspVehSpdKph);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleSpeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleSpeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.dspVehSpdKph = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleSpeed {
    return { dspVehSpdKph: isSet(object.dspVehSpdKph) ? globalThis.Number(object.dspVehSpdKph) : 0 };
  },

  toJSON(message: VehicleSpeed): unknown {
    const obj: any = {};
    if (message.dspVehSpdKph !== 0) {
      obj.dspVehSpdKph = message.dspVehSpdKph;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VehicleSpeed>, I>>(base?: I): VehicleSpeed {
    return VehicleSpeed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VehicleSpeed>, I>>(object: I): VehicleSpeed {
    const message = createBaseVehicleSpeed();
    message.dspVehSpdKph = object.dspVehSpdKph ?? 0;
    return message;
  },
};

function createBaseLightStatus(): LightStatus {
  return {
    isLeftDircnIndLampOn: false,
    isRightDircnIndLampOn: false,
    isMainBeamLightOn: false,
    isDippedBeamLightOn: false,
    isFrtFogLightOn: false,
    isRrFogLightOn: false,
    sideBrakeLightStsEnum: 0,
    centreHightBrakeLightStsEnum: 0,
  };
}

export const LightStatus: MessageFns<LightStatus> = {
  encode(message: LightStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isLeftDircnIndLampOn !== false) {
      writer.uint32(8).bool(message.isLeftDircnIndLampOn);
    }
    if (message.isRightDircnIndLampOn !== false) {
      writer.uint32(16).bool(message.isRightDircnIndLampOn);
    }
    if (message.isMainBeamLightOn !== false) {
      writer.uint32(24).bool(message.isMainBeamLightOn);
    }
    if (message.isDippedBeamLightOn !== false) {
      writer.uint32(32).bool(message.isDippedBeamLightOn);
    }
    if (message.isFrtFogLightOn !== false) {
      writer.uint32(40).bool(message.isFrtFogLightOn);
    }
    if (message.isRrFogLightOn !== false) {
      writer.uint32(48).bool(message.isRrFogLightOn);
    }
    if (message.sideBrakeLightStsEnum !== 0) {
      writer.uint32(56).uint32(message.sideBrakeLightStsEnum);
    }
    if (message.centreHightBrakeLightStsEnum !== 0) {
      writer.uint32(64).uint32(message.centreHightBrakeLightStsEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LightStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLightStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isLeftDircnIndLampOn = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isRightDircnIndLampOn = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isMainBeamLightOn = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isDippedBeamLightOn = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isFrtFogLightOn = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isRrFogLightOn = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sideBrakeLightStsEnum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.centreHightBrakeLightStsEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LightStatus {
    return {
      isLeftDircnIndLampOn: isSet(object.isLeftDircnIndLampOn)
        ? globalThis.Boolean(object.isLeftDircnIndLampOn)
        : false,
      isRightDircnIndLampOn: isSet(object.isRightDircnIndLampOn)
        ? globalThis.Boolean(object.isRightDircnIndLampOn)
        : false,
      isMainBeamLightOn: isSet(object.isMainBeamLightOn) ? globalThis.Boolean(object.isMainBeamLightOn) : false,
      isDippedBeamLightOn: isSet(object.isDippedBeamLightOn) ? globalThis.Boolean(object.isDippedBeamLightOn) : false,
      isFrtFogLightOn: isSet(object.isFrtFogLightOn) ? globalThis.Boolean(object.isFrtFogLightOn) : false,
      isRrFogLightOn: isSet(object.isRrFogLightOn) ? globalThis.Boolean(object.isRrFogLightOn) : false,
      sideBrakeLightStsEnum: isSet(object.sideBrakeLightStsEnum) ? globalThis.Number(object.sideBrakeLightStsEnum) : 0,
      centreHightBrakeLightStsEnum: isSet(object.centreHightBrakeLightStsEnum)
        ? globalThis.Number(object.centreHightBrakeLightStsEnum)
        : 0,
    };
  },

  toJSON(message: LightStatus): unknown {
    const obj: any = {};
    if (message.isLeftDircnIndLampOn !== false) {
      obj.isLeftDircnIndLampOn = message.isLeftDircnIndLampOn;
    }
    if (message.isRightDircnIndLampOn !== false) {
      obj.isRightDircnIndLampOn = message.isRightDircnIndLampOn;
    }
    if (message.isMainBeamLightOn !== false) {
      obj.isMainBeamLightOn = message.isMainBeamLightOn;
    }
    if (message.isDippedBeamLightOn !== false) {
      obj.isDippedBeamLightOn = message.isDippedBeamLightOn;
    }
    if (message.isFrtFogLightOn !== false) {
      obj.isFrtFogLightOn = message.isFrtFogLightOn;
    }
    if (message.isRrFogLightOn !== false) {
      obj.isRrFogLightOn = message.isRrFogLightOn;
    }
    if (message.sideBrakeLightStsEnum !== 0) {
      obj.sideBrakeLightStsEnum = Math.round(message.sideBrakeLightStsEnum);
    }
    if (message.centreHightBrakeLightStsEnum !== 0) {
      obj.centreHightBrakeLightStsEnum = Math.round(message.centreHightBrakeLightStsEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LightStatus>, I>>(base?: I): LightStatus {
    return LightStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LightStatus>, I>>(object: I): LightStatus {
    const message = createBaseLightStatus();
    message.isLeftDircnIndLampOn = object.isLeftDircnIndLampOn ?? false;
    message.isRightDircnIndLampOn = object.isRightDircnIndLampOn ?? false;
    message.isMainBeamLightOn = object.isMainBeamLightOn ?? false;
    message.isDippedBeamLightOn = object.isDippedBeamLightOn ?? false;
    message.isFrtFogLightOn = object.isFrtFogLightOn ?? false;
    message.isRrFogLightOn = object.isRrFogLightOn ?? false;
    message.sideBrakeLightStsEnum = object.sideBrakeLightStsEnum ?? 0;
    message.centreHightBrakeLightStsEnum = object.centreHightBrakeLightStsEnum ?? 0;
    return message;
  },
};

function createBaseBrakePedal(): BrakePedal {
  return { brkpdlAppdEnum: 0 };
}

export const BrakePedal: MessageFns<BrakePedal> = {
  encode(message: BrakePedal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brkpdlAppdEnum !== 0) {
      writer.uint32(8).uint32(message.brkpdlAppdEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrakePedal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrakePedal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.brkpdlAppdEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrakePedal {
    return { brkpdlAppdEnum: isSet(object.brkpdlAppdEnum) ? globalThis.Number(object.brkpdlAppdEnum) : 0 };
  },

  toJSON(message: BrakePedal): unknown {
    const obj: any = {};
    if (message.brkpdlAppdEnum !== 0) {
      obj.brkpdlAppdEnum = Math.round(message.brkpdlAppdEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrakePedal>, I>>(base?: I): BrakePedal {
    return BrakePedal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrakePedal>, I>>(object: I): BrakePedal {
    const message = createBaseBrakePedal();
    message.brkpdlAppdEnum = object.brkpdlAppdEnum ?? 0;
    return message;
  },
};

function createBaseVehicleDynamic(): VehicleDynamic {
  return { vehspd: undefined, vehaccl: undefined, movgsts: undefined };
}

export const VehicleDynamic: MessageFns<VehicleDynamic> = {
  encode(message: VehicleDynamic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vehspd !== undefined) {
      VehicleSpeed.encode(message.vehspd, writer.uint32(10).fork()).join();
    }
    if (message.vehaccl !== undefined) {
      VehicleAcceleration.encode(message.vehaccl, writer.uint32(18).fork()).join();
    }
    if (message.movgsts !== undefined) {
      MovingStatus.encode(message.movgsts, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleDynamic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleDynamic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vehspd = VehicleSpeed.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vehaccl = VehicleAcceleration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.movgsts = MovingStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleDynamic {
    return {
      vehspd: isSet(object.vehspd) ? VehicleSpeed.fromJSON(object.vehspd) : undefined,
      vehaccl: isSet(object.vehaccl) ? VehicleAcceleration.fromJSON(object.vehaccl) : undefined,
      movgsts: isSet(object.movgsts) ? MovingStatus.fromJSON(object.movgsts) : undefined,
    };
  },

  toJSON(message: VehicleDynamic): unknown {
    const obj: any = {};
    if (message.vehspd !== undefined) {
      obj.vehspd = VehicleSpeed.toJSON(message.vehspd);
    }
    if (message.vehaccl !== undefined) {
      obj.vehaccl = VehicleAcceleration.toJSON(message.vehaccl);
    }
    if (message.movgsts !== undefined) {
      obj.movgsts = MovingStatus.toJSON(message.movgsts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VehicleDynamic>, I>>(base?: I): VehicleDynamic {
    return VehicleDynamic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VehicleDynamic>, I>>(object: I): VehicleDynamic {
    const message = createBaseVehicleDynamic();
    message.vehspd = (object.vehspd !== undefined && object.vehspd !== null)
      ? VehicleSpeed.fromPartial(object.vehspd)
      : undefined;
    message.vehaccl = (object.vehaccl !== undefined && object.vehaccl !== null)
      ? VehicleAcceleration.fromPartial(object.vehaccl)
      : undefined;
    message.movgsts = (object.movgsts !== undefined && object.movgsts !== null)
      ? MovingStatus.fromPartial(object.movgsts)
      : undefined;
    return message;
  },
};

function createBaseVehicleAcceleration(): VehicleAcceleration {
  return { longAcclMS2: 0 };
}

export const VehicleAcceleration: MessageFns<VehicleAcceleration> = {
  encode(message: VehicleAcceleration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.longAcclMS2 !== 0) {
      writer.uint32(13).float(message.longAcclMS2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleAcceleration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleAcceleration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.longAcclMS2 = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleAcceleration {
    return { longAcclMS2: isSet(object.longAcclMS2) ? globalThis.Number(object.longAcclMS2) : 0 };
  },

  toJSON(message: VehicleAcceleration): unknown {
    const obj: any = {};
    if (message.longAcclMS2 !== 0) {
      obj.longAcclMS2 = message.longAcclMS2;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VehicleAcceleration>, I>>(base?: I): VehicleAcceleration {
    return VehicleAcceleration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VehicleAcceleration>, I>>(object: I): VehicleAcceleration {
    const message = createBaseVehicleAcceleration();
    message.longAcclMS2 = object.longAcclMS2 ?? 0;
    return message;
  },
};

function createBaseVehicleBody(): VehicleBody {
  return { lightSts: undefined };
}

export const VehicleBody: MessageFns<VehicleBody> = {
  encode(message: VehicleBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lightSts !== undefined) {
      LightStatus.encode(message.lightSts, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lightSts = LightStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleBody {
    return { lightSts: isSet(object.lightSts) ? LightStatus.fromJSON(object.lightSts) : undefined };
  },

  toJSON(message: VehicleBody): unknown {
    const obj: any = {};
    if (message.lightSts !== undefined) {
      obj.lightSts = LightStatus.toJSON(message.lightSts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VehicleBody>, I>>(base?: I): VehicleBody {
    return VehicleBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VehicleBody>, I>>(object: I): VehicleBody {
    const message = createBaseVehicleBody();
    message.lightSts = (object.lightSts !== undefined && object.lightSts !== null)
      ? LightStatus.fromPartial(object.lightSts)
      : undefined;
    return message;
  },
};

function createBaseMovingStatus(): MovingStatus {
  return { vehststStsEnum: 0, isVehststStsVld: false, vehMovgDirEnum: 0 };
}

export const MovingStatus: MessageFns<MovingStatus> = {
  encode(message: MovingStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vehststStsEnum !== 0) {
      writer.uint32(8).uint32(message.vehststStsEnum);
    }
    if (message.isVehststStsVld !== false) {
      writer.uint32(16).bool(message.isVehststStsVld);
    }
    if (message.vehMovgDirEnum !== 0) {
      writer.uint32(24).uint32(message.vehMovgDirEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MovingStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMovingStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.vehststStsEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isVehststStsVld = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.vehMovgDirEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MovingStatus {
    return {
      vehststStsEnum: isSet(object.vehststStsEnum) ? globalThis.Number(object.vehststStsEnum) : 0,
      isVehststStsVld: isSet(object.isVehststStsVld) ? globalThis.Boolean(object.isVehststStsVld) : false,
      vehMovgDirEnum: isSet(object.vehMovgDirEnum) ? globalThis.Number(object.vehMovgDirEnum) : 0,
    };
  },

  toJSON(message: MovingStatus): unknown {
    const obj: any = {};
    if (message.vehststStsEnum !== 0) {
      obj.vehststStsEnum = Math.round(message.vehststStsEnum);
    }
    if (message.isVehststStsVld !== false) {
      obj.isVehststStsVld = message.isVehststStsVld;
    }
    if (message.vehMovgDirEnum !== 0) {
      obj.vehMovgDirEnum = Math.round(message.vehMovgDirEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MovingStatus>, I>>(base?: I): MovingStatus {
    return MovingStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MovingStatus>, I>>(object: I): MovingStatus {
    const message = createBaseMovingStatus();
    message.vehststStsEnum = object.vehststStsEnum ?? 0;
    message.isVehststStsVld = object.isVehststStsVld ?? false;
    message.vehMovgDirEnum = object.vehMovgDirEnum ?? 0;
    return message;
  },
};

function createBaseBrakeSystem(): BrakeSystem {
  return { brkpdl: undefined };
}

export const BrakeSystem: MessageFns<BrakeSystem> = {
  encode(message: BrakeSystem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brkpdl !== undefined) {
      BrakePedal.encode(message.brkpdl, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrakeSystem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrakeSystem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brkpdl = BrakePedal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrakeSystem {
    return { brkpdl: isSet(object.brkpdl) ? BrakePedal.fromJSON(object.brkpdl) : undefined };
  },

  toJSON(message: BrakeSystem): unknown {
    const obj: any = {};
    if (message.brkpdl !== undefined) {
      obj.brkpdl = BrakePedal.toJSON(message.brkpdl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrakeSystem>, I>>(base?: I): BrakeSystem {
    return BrakeSystem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrakeSystem>, I>>(object: I): BrakeSystem {
    const message = createBaseBrakeSystem();
    message.brkpdl = (object.brkpdl !== undefined && object.brkpdl !== null)
      ? BrakePedal.fromPartial(object.brkpdl)
      : undefined;
    return message;
  },
};

function createBaseSteeringSystem(): SteeringSystem {
  return { pnnagsaeDeg: 0 };
}

export const SteeringSystem: MessageFns<SteeringSystem> = {
  encode(message: SteeringSystem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pnnagsaeDeg !== 0) {
      writer.uint32(13).float(message.pnnagsaeDeg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SteeringSystem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSteeringSystem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.pnnagsaeDeg = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SteeringSystem {
    return { pnnagsaeDeg: isSet(object.pnnagsaeDeg) ? globalThis.Number(object.pnnagsaeDeg) : 0 };
  },

  toJSON(message: SteeringSystem): unknown {
    const obj: any = {};
    if (message.pnnagsaeDeg !== 0) {
      obj.pnnagsaeDeg = message.pnnagsaeDeg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SteeringSystem>, I>>(base?: I): SteeringSystem {
    return SteeringSystem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SteeringSystem>, I>>(object: I): SteeringSystem {
    const message = createBaseSteeringSystem();
    message.pnnagsaeDeg = object.pnnagsaeDeg ?? 0;
    return message;
  },
};

function createBasePowerTrain(): PowerTrain {
  return { gear: undefined };
}

export const PowerTrain: MessageFns<PowerTrain> = {
  encode(message: PowerTrain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gear !== undefined) {
      Gear.encode(message.gear, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PowerTrain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePowerTrain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gear = Gear.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PowerTrain {
    return { gear: isSet(object.gear) ? Gear.fromJSON(object.gear) : undefined };
  },

  toJSON(message: PowerTrain): unknown {
    const obj: any = {};
    if (message.gear !== undefined) {
      obj.gear = Gear.toJSON(message.gear);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PowerTrain>, I>>(base?: I): PowerTrain {
    return PowerTrain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PowerTrain>, I>>(object: I): PowerTrain {
    const message = createBasePowerTrain();
    message.gear = (object.gear !== undefined && object.gear !== null) ? Gear.fromPartial(object.gear) : undefined;
    return message;
  },
};

function createBaseGear(): Gear {
  return { isActvGearVld: false, actvGearEnum: 0 };
}

export const Gear: MessageFns<Gear> = {
  encode(message: Gear, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isActvGearVld !== false) {
      writer.uint32(8).bool(message.isActvGearVld);
    }
    if (message.actvGearEnum !== 0) {
      writer.uint32(16).uint32(message.actvGearEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gear {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGear();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isActvGearVld = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actvGearEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Gear {
    return {
      isActvGearVld: isSet(object.isActvGearVld) ? globalThis.Boolean(object.isActvGearVld) : false,
      actvGearEnum: isSet(object.actvGearEnum) ? globalThis.Number(object.actvGearEnum) : 0,
    };
  },

  toJSON(message: Gear): unknown {
    const obj: any = {};
    if (message.isActvGearVld !== false) {
      obj.isActvGearVld = message.isActvGearVld;
    }
    if (message.actvGearEnum !== 0) {
      obj.actvGearEnum = Math.round(message.actvGearEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Gear>, I>>(base?: I): Gear {
    return Gear.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gear>, I>>(object: I): Gear {
    const message = createBaseGear();
    message.isActvGearVld = object.isActvGearVld ?? false;
    message.actvGearEnum = object.actvGearEnum ?? 0;
    return message;
  },
};

function createBaseDrivingCruisingFunctionSR(): DrivingCruisingFunctionSR {
  return {
    laneChangeStepEnum: 0,
    iteractionTargetIdList: [],
    iteractionTargetTagEnumList: [],
    targetLaneId: 0,
    trafficLightTypeEnum: [],
    trafficLightColorEnum: [],
    cipvId: 0,
    cipvTagEnum: 0,
    trafficLightCountdown: 0,
  };
}

export const DrivingCruisingFunctionSR: MessageFns<DrivingCruisingFunctionSR> = {
  encode(message: DrivingCruisingFunctionSR, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.laneChangeStepEnum !== 0) {
      writer.uint32(8).uint32(message.laneChangeStepEnum);
    }
    writer.uint32(18).fork();
    for (const v of message.iteractionTargetIdList) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.iteractionTargetTagEnumList) {
      writer.uint32(v);
    }
    writer.join();
    if (message.targetLaneId !== 0) {
      writer.uint32(32).uint32(message.targetLaneId);
    }
    writer.uint32(42).fork();
    for (const v of message.trafficLightTypeEnum) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(50).fork();
    for (const v of message.trafficLightColorEnum) {
      writer.uint32(v);
    }
    writer.join();
    if (message.cipvId !== 0) {
      writer.uint32(56).uint32(message.cipvId);
    }
    if (message.cipvTagEnum !== 0) {
      writer.uint32(64).uint32(message.cipvTagEnum);
    }
    if (message.trafficLightCountdown !== 0) {
      writer.uint32(72).uint32(message.trafficLightCountdown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrivingCruisingFunctionSR {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrivingCruisingFunctionSR();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.laneChangeStepEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.iteractionTargetIdList.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.iteractionTargetIdList.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 24) {
            message.iteractionTargetTagEnumList.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.iteractionTargetTagEnumList.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.targetLaneId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.trafficLightTypeEnum.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.trafficLightTypeEnum.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag === 48) {
            message.trafficLightColorEnum.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.trafficLightColorEnum.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cipvId = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.cipvTagEnum = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.trafficLightCountdown = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrivingCruisingFunctionSR {
    return {
      laneChangeStepEnum: isSet(object.laneChangeStepEnum) ? globalThis.Number(object.laneChangeStepEnum) : 0,
      iteractionTargetIdList: globalThis.Array.isArray(object?.iteractionTargetIdList)
        ? object.iteractionTargetIdList.map((e: any) => globalThis.Number(e))
        : [],
      iteractionTargetTagEnumList: globalThis.Array.isArray(object?.iteractionTargetTagEnumList)
        ? object.iteractionTargetTagEnumList.map((e: any) => globalThis.Number(e))
        : [],
      targetLaneId: isSet(object.targetLaneId) ? globalThis.Number(object.targetLaneId) : 0,
      trafficLightTypeEnum: globalThis.Array.isArray(object?.trafficLightTypeEnum)
        ? object.trafficLightTypeEnum.map((e: any) => globalThis.Number(e))
        : [],
      trafficLightColorEnum: globalThis.Array.isArray(object?.trafficLightColorEnum)
        ? object.trafficLightColorEnum.map((e: any) => globalThis.Number(e))
        : [],
      cipvId: isSet(object.cipvId) ? globalThis.Number(object.cipvId) : 0,
      cipvTagEnum: isSet(object.cipvTagEnum) ? globalThis.Number(object.cipvTagEnum) : 0,
      trafficLightCountdown: isSet(object.trafficLightCountdown) ? globalThis.Number(object.trafficLightCountdown) : 0,
    };
  },

  toJSON(message: DrivingCruisingFunctionSR): unknown {
    const obj: any = {};
    if (message.laneChangeStepEnum !== 0) {
      obj.laneChangeStepEnum = Math.round(message.laneChangeStepEnum);
    }
    if (message.iteractionTargetIdList?.length) {
      obj.iteractionTargetIdList = message.iteractionTargetIdList.map((e) => Math.round(e));
    }
    if (message.iteractionTargetTagEnumList?.length) {
      obj.iteractionTargetTagEnumList = message.iteractionTargetTagEnumList.map((e) => Math.round(e));
    }
    if (message.targetLaneId !== 0) {
      obj.targetLaneId = Math.round(message.targetLaneId);
    }
    if (message.trafficLightTypeEnum?.length) {
      obj.trafficLightTypeEnum = message.trafficLightTypeEnum.map((e) => Math.round(e));
    }
    if (message.trafficLightColorEnum?.length) {
      obj.trafficLightColorEnum = message.trafficLightColorEnum.map((e) => Math.round(e));
    }
    if (message.cipvId !== 0) {
      obj.cipvId = Math.round(message.cipvId);
    }
    if (message.cipvTagEnum !== 0) {
      obj.cipvTagEnum = Math.round(message.cipvTagEnum);
    }
    if (message.trafficLightCountdown !== 0) {
      obj.trafficLightCountdown = Math.round(message.trafficLightCountdown);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrivingCruisingFunctionSR>, I>>(base?: I): DrivingCruisingFunctionSR {
    return DrivingCruisingFunctionSR.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrivingCruisingFunctionSR>, I>>(object: I): DrivingCruisingFunctionSR {
    const message = createBaseDrivingCruisingFunctionSR();
    message.laneChangeStepEnum = object.laneChangeStepEnum ?? 0;
    message.iteractionTargetIdList = object.iteractionTargetIdList?.map((e) => e) || [];
    message.iteractionTargetTagEnumList = object.iteractionTargetTagEnumList?.map((e) => e) || [];
    message.targetLaneId = object.targetLaneId ?? 0;
    message.trafficLightTypeEnum = object.trafficLightTypeEnum?.map((e) => e) || [];
    message.trafficLightColorEnum = object.trafficLightColorEnum?.map((e) => e) || [];
    message.cipvId = object.cipvId ?? 0;
    message.cipvTagEnum = object.cipvTagEnum ?? 0;
    message.trafficLightCountdown = object.trafficLightCountdown ?? 0;
    return message;
  },
};

function createBaseFSMNodeInfo(): FSMNodeInfo {
  return { drivingModeEnum: 0, functionStsEnum: 0 };
}

export const FSMNodeInfo: MessageFns<FSMNodeInfo> = {
  encode(message: FSMNodeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.drivingModeEnum !== 0) {
      writer.uint32(8).int32(message.drivingModeEnum);
    }
    if (message.functionStsEnum !== 0) {
      writer.uint32(16).uint32(message.functionStsEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FSMNodeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFSMNodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.drivingModeEnum = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.functionStsEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FSMNodeInfo {
    return {
      drivingModeEnum: isSet(object.drivingModeEnum) ? fSMNodeInfo_DrivingModeFromJSON(object.drivingModeEnum) : 0,
      functionStsEnum: isSet(object.functionStsEnum) ? globalThis.Number(object.functionStsEnum) : 0,
    };
  },

  toJSON(message: FSMNodeInfo): unknown {
    const obj: any = {};
    if (message.drivingModeEnum !== 0) {
      obj.drivingModeEnum = fSMNodeInfo_DrivingModeToJSON(message.drivingModeEnum);
    }
    if (message.functionStsEnum !== 0) {
      obj.functionStsEnum = Math.round(message.functionStsEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FSMNodeInfo>, I>>(base?: I): FSMNodeInfo {
    return FSMNodeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FSMNodeInfo>, I>>(object: I): FSMNodeInfo {
    const message = createBaseFSMNodeInfo();
    message.drivingModeEnum = object.drivingModeEnum ?? 0;
    message.functionStsEnum = object.functionStsEnum ?? 0;
    return message;
  },
};

function createBaseVertex(): Vertex {
  return { xM: 0, yM: 0, zM: 0, hM: 0 };
}

export const Vertex: MessageFns<Vertex> = {
  encode(message: Vertex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xM !== 0) {
      writer.uint32(13).float(message.xM);
    }
    if (message.yM !== 0) {
      writer.uint32(21).float(message.yM);
    }
    if (message.zM !== 0) {
      writer.uint32(29).float(message.zM);
    }
    if (message.hM !== 0) {
      writer.uint32(37).float(message.hM);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vertex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.xM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.yM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.zM = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.hM = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vertex {
    return {
      xM: isSet(object.xM) ? globalThis.Number(object.xM) : 0,
      yM: isSet(object.yM) ? globalThis.Number(object.yM) : 0,
      zM: isSet(object.zM) ? globalThis.Number(object.zM) : 0,
      hM: isSet(object.hM) ? globalThis.Number(object.hM) : 0,
    };
  },

  toJSON(message: Vertex): unknown {
    const obj: any = {};
    if (message.xM !== 0) {
      obj.xM = message.xM;
    }
    if (message.yM !== 0) {
      obj.yM = message.yM;
    }
    if (message.zM !== 0) {
      obj.zM = message.zM;
    }
    if (message.hM !== 0) {
      obj.hM = message.hM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vertex>, I>>(base?: I): Vertex {
    return Vertex.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vertex>, I>>(object: I): Vertex {
    const message = createBaseVertex();
    message.xM = object.xM ?? 0;
    message.yM = object.yM ?? 0;
    message.zM = object.zM ?? 0;
    message.hM = object.hM ?? 0;
    return message;
  },
};

function createBaseCubicCurve(): CubicCurve {
  return { startXM: 0, endXM: 0, c0: 0, c1: 0, c2: 0, c3: 0 };
}

export const CubicCurve: MessageFns<CubicCurve> = {
  encode(message: CubicCurve, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startXM !== 0) {
      writer.uint32(13).float(message.startXM);
    }
    if (message.endXM !== 0) {
      writer.uint32(21).float(message.endXM);
    }
    if (message.c0 !== 0) {
      writer.uint32(29).float(message.c0);
    }
    if (message.c1 !== 0) {
      writer.uint32(37).float(message.c1);
    }
    if (message.c2 !== 0) {
      writer.uint32(45).float(message.c2);
    }
    if (message.c3 !== 0) {
      writer.uint32(53).float(message.c3);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CubicCurve {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCubicCurve();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.startXM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.endXM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.c0 = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.c1 = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.c2 = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.c3 = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CubicCurve {
    return {
      startXM: isSet(object.startXM) ? globalThis.Number(object.startXM) : 0,
      endXM: isSet(object.endXM) ? globalThis.Number(object.endXM) : 0,
      c0: isSet(object.c0) ? globalThis.Number(object.c0) : 0,
      c1: isSet(object.c1) ? globalThis.Number(object.c1) : 0,
      c2: isSet(object.c2) ? globalThis.Number(object.c2) : 0,
      c3: isSet(object.c3) ? globalThis.Number(object.c3) : 0,
    };
  },

  toJSON(message: CubicCurve): unknown {
    const obj: any = {};
    if (message.startXM !== 0) {
      obj.startXM = message.startXM;
    }
    if (message.endXM !== 0) {
      obj.endXM = message.endXM;
    }
    if (message.c0 !== 0) {
      obj.c0 = message.c0;
    }
    if (message.c1 !== 0) {
      obj.c1 = message.c1;
    }
    if (message.c2 !== 0) {
      obj.c2 = message.c2;
    }
    if (message.c3 !== 0) {
      obj.c3 = message.c3;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CubicCurve>, I>>(base?: I): CubicCurve {
    return CubicCurve.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CubicCurve>, I>>(object: I): CubicCurve {
    const message = createBaseCubicCurve();
    message.startXM = object.startXM ?? 0;
    message.endXM = object.endXM ?? 0;
    message.c0 = object.c0 ?? 0;
    message.c1 = object.c1 ?? 0;
    message.c2 = object.c2 ?? 0;
    message.c3 = object.c3 ?? 0;
    return message;
  },
};

function createBaseSamplingPoint(): SamplingPoint {
  return { xM: 0, yM: 0 };
}

export const SamplingPoint: MessageFns<SamplingPoint> = {
  encode(message: SamplingPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xM !== 0) {
      writer.uint32(13).float(message.xM);
    }
    if (message.yM !== 0) {
      writer.uint32(21).float(message.yM);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SamplingPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSamplingPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.xM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.yM = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SamplingPoint {
    return {
      xM: isSet(object.xM) ? globalThis.Number(object.xM) : 0,
      yM: isSet(object.yM) ? globalThis.Number(object.yM) : 0,
    };
  },

  toJSON(message: SamplingPoint): unknown {
    const obj: any = {};
    if (message.xM !== 0) {
      obj.xM = message.xM;
    }
    if (message.yM !== 0) {
      obj.yM = message.yM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SamplingPoint>, I>>(base?: I): SamplingPoint {
    return SamplingPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SamplingPoint>, I>>(object: I): SamplingPoint {
    const message = createBaseSamplingPoint();
    message.xM = object.xM ?? 0;
    message.yM = object.yM ?? 0;
    return message;
  },
};

function createBaseGeometryLine(): GeometryLine {
  return {
    isCurveValid: false,
    curve: undefined,
    isSamplingPointValid: false,
    numberOfSamplingPoint: 0,
    samplingPointList: [],
  };
}

export const GeometryLine: MessageFns<GeometryLine> = {
  encode(message: GeometryLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isCurveValid !== false) {
      writer.uint32(8).bool(message.isCurveValid);
    }
    if (message.curve !== undefined) {
      CubicCurve.encode(message.curve, writer.uint32(18).fork()).join();
    }
    if (message.isSamplingPointValid !== false) {
      writer.uint32(24).bool(message.isSamplingPointValid);
    }
    if (message.numberOfSamplingPoint !== 0) {
      writer.uint32(32).uint32(message.numberOfSamplingPoint);
    }
    for (const v of message.samplingPointList) {
      SamplingPoint.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeometryLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeometryLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isCurveValid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.curve = CubicCurve.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isSamplingPointValid = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numberOfSamplingPoint = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.samplingPointList.push(SamplingPoint.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeometryLine {
    return {
      isCurveValid: isSet(object.isCurveValid) ? globalThis.Boolean(object.isCurveValid) : false,
      curve: isSet(object.curve) ? CubicCurve.fromJSON(object.curve) : undefined,
      isSamplingPointValid: isSet(object.isSamplingPointValid)
        ? globalThis.Boolean(object.isSamplingPointValid)
        : false,
      numberOfSamplingPoint: isSet(object.numberOfSamplingPoint) ? globalThis.Number(object.numberOfSamplingPoint) : 0,
      samplingPointList: globalThis.Array.isArray(object?.samplingPointList)
        ? object.samplingPointList.map((e: any) => SamplingPoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GeometryLine): unknown {
    const obj: any = {};
    if (message.isCurveValid !== false) {
      obj.isCurveValid = message.isCurveValid;
    }
    if (message.curve !== undefined) {
      obj.curve = CubicCurve.toJSON(message.curve);
    }
    if (message.isSamplingPointValid !== false) {
      obj.isSamplingPointValid = message.isSamplingPointValid;
    }
    if (message.numberOfSamplingPoint !== 0) {
      obj.numberOfSamplingPoint = Math.round(message.numberOfSamplingPoint);
    }
    if (message.samplingPointList?.length) {
      obj.samplingPointList = message.samplingPointList.map((e) => SamplingPoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeometryLine>, I>>(base?: I): GeometryLine {
    return GeometryLine.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeometryLine>, I>>(object: I): GeometryLine {
    const message = createBaseGeometryLine();
    message.isCurveValid = object.isCurveValid ?? false;
    message.curve = (object.curve !== undefined && object.curve !== null)
      ? CubicCurve.fromPartial(object.curve)
      : undefined;
    message.isSamplingPointValid = object.isSamplingPointValid ?? false;
    message.numberOfSamplingPoint = object.numberOfSamplingPoint ?? 0;
    message.samplingPointList = object.samplingPointList?.map((e) => SamplingPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStaticElement(): StaticElement {
  return { id: 0, classEnum: 0, numOfVertices: 0, verticesList: [], heightPropertyEnum: 0 };
}

export const StaticElement: MessageFns<StaticElement> = {
  encode(message: StaticElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.classEnum !== 0) {
      writer.uint32(16).uint32(message.classEnum);
    }
    if (message.numOfVertices !== 0) {
      writer.uint32(24).uint32(message.numOfVertices);
    }
    for (const v of message.verticesList) {
      Vertex.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.heightPropertyEnum !== 0) {
      writer.uint32(40).uint32(message.heightPropertyEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StaticElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaticElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.classEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numOfVertices = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.verticesList.push(Vertex.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.heightPropertyEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StaticElement {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      classEnum: isSet(object.classEnum) ? globalThis.Number(object.classEnum) : 0,
      numOfVertices: isSet(object.numOfVertices) ? globalThis.Number(object.numOfVertices) : 0,
      verticesList: globalThis.Array.isArray(object?.verticesList)
        ? object.verticesList.map((e: any) => Vertex.fromJSON(e))
        : [],
      heightPropertyEnum: isSet(object.heightPropertyEnum) ? globalThis.Number(object.heightPropertyEnum) : 0,
    };
  },

  toJSON(message: StaticElement): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.classEnum !== 0) {
      obj.classEnum = Math.round(message.classEnum);
    }
    if (message.numOfVertices !== 0) {
      obj.numOfVertices = Math.round(message.numOfVertices);
    }
    if (message.verticesList?.length) {
      obj.verticesList = message.verticesList.map((e) => Vertex.toJSON(e));
    }
    if (message.heightPropertyEnum !== 0) {
      obj.heightPropertyEnum = Math.round(message.heightPropertyEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StaticElement>, I>>(base?: I): StaticElement {
    return StaticElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StaticElement>, I>>(object: I): StaticElement {
    const message = createBaseStaticElement();
    message.id = object.id ?? 0;
    message.classEnum = object.classEnum ?? 0;
    message.numOfVertices = object.numOfVertices ?? 0;
    message.verticesList = object.verticesList?.map((e) => Vertex.fromPartial(e)) || [];
    message.heightPropertyEnum = object.heightPropertyEnum ?? 0;
    return message;
  },
};

function createBaseSegLane(): SegLane {
  return { id: 0, laneWidthM: 0, laneGeometry: undefined };
}

export const SegLane: MessageFns<SegLane> = {
  encode(message: SegLane, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.laneWidthM !== 0) {
      writer.uint32(21).float(message.laneWidthM);
    }
    if (message.laneGeometry !== undefined) {
      GeometryLine.encode(message.laneGeometry, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegLane {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegLane();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.laneWidthM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.laneGeometry = GeometryLine.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegLane {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      laneWidthM: isSet(object.laneWidthM) ? globalThis.Number(object.laneWidthM) : 0,
      laneGeometry: isSet(object.laneGeometry) ? GeometryLine.fromJSON(object.laneGeometry) : undefined,
    };
  },

  toJSON(message: SegLane): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.laneWidthM !== 0) {
      obj.laneWidthM = message.laneWidthM;
    }
    if (message.laneGeometry !== undefined) {
      obj.laneGeometry = GeometryLine.toJSON(message.laneGeometry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SegLane>, I>>(base?: I): SegLane {
    return SegLane.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SegLane>, I>>(object: I): SegLane {
    const message = createBaseSegLane();
    message.id = object.id ?? 0;
    message.laneWidthM = object.laneWidthM ?? 0;
    message.laneGeometry = (object.laneGeometry !== undefined && object.laneGeometry !== null)
      ? GeometryLine.fromPartial(object.laneGeometry)
      : undefined;
    return message;
  },
};

function createBaseSegLaneLine(): SegLaneLine {
  return { id: 0, geometry: undefined };
}

export const SegLaneLine: MessageFns<SegLaneLine> = {
  encode(message: SegLaneLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.geometry !== undefined) {
      GeometryLine.encode(message.geometry, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegLaneLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegLaneLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.geometry = GeometryLine.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegLaneLine {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      geometry: isSet(object.geometry) ? GeometryLine.fromJSON(object.geometry) : undefined,
    };
  },

  toJSON(message: SegLaneLine): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.geometry !== undefined) {
      obj.geometry = GeometryLine.toJSON(message.geometry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SegLaneLine>, I>>(base?: I): SegLaneLine {
    return SegLaneLine.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SegLaneLine>, I>>(object: I): SegLaneLine {
    const message = createBaseSegLaneLine();
    message.id = object.id ?? 0;
    message.geometry = (object.geometry !== undefined && object.geometry !== null)
      ? GeometryLine.fromPartial(object.geometry)
      : undefined;
    return message;
  },
};

function createBaseSegLaneLineAttr(): SegLaneLineAttr {
  return { startOffsetM: 0, endOffsetM: 0, type: 0, color: 0 };
}

export const SegLaneLineAttr: MessageFns<SegLaneLineAttr> = {
  encode(message: SegLaneLineAttr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startOffsetM !== 0) {
      writer.uint32(13).float(message.startOffsetM);
    }
    if (message.endOffsetM !== 0) {
      writer.uint32(21).float(message.endOffsetM);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.color !== 0) {
      writer.uint32(32).int32(message.color);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegLaneLineAttr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegLaneLineAttr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.startOffsetM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.endOffsetM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.color = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegLaneLineAttr {
    return {
      startOffsetM: isSet(object.startOffsetM) ? globalThis.Number(object.startOffsetM) : 0,
      endOffsetM: isSet(object.endOffsetM) ? globalThis.Number(object.endOffsetM) : 0,
      type: isSet(object.type) ? segLaneLineAttr_LineTypeFromJSON(object.type) : 0,
      color: isSet(object.color) ? segLaneLineAttr_ColorFromJSON(object.color) : 0,
    };
  },

  toJSON(message: SegLaneLineAttr): unknown {
    const obj: any = {};
    if (message.startOffsetM !== 0) {
      obj.startOffsetM = message.startOffsetM;
    }
    if (message.endOffsetM !== 0) {
      obj.endOffsetM = message.endOffsetM;
    }
    if (message.type !== 0) {
      obj.type = segLaneLineAttr_LineTypeToJSON(message.type);
    }
    if (message.color !== 0) {
      obj.color = segLaneLineAttr_ColorToJSON(message.color);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SegLaneLineAttr>, I>>(base?: I): SegLaneLineAttr {
    return SegLaneLineAttr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SegLaneLineAttr>, I>>(object: I): SegLaneLineAttr {
    const message = createBaseSegLaneLineAttr();
    message.startOffsetM = object.startOffsetM ?? 0;
    message.endOffsetM = object.endOffsetM ?? 0;
    message.type = object.type ?? 0;
    message.color = object.color ?? 0;
    return message;
  },
};

function createBaseSegRoadEdge(): SegRoadEdge {
  return { id: 0, geometry: undefined };
}

export const SegRoadEdge: MessageFns<SegRoadEdge> = {
  encode(message: SegRoadEdge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.geometry !== undefined) {
      GeometryLine.encode(message.geometry, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegRoadEdge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegRoadEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.geometry = GeometryLine.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegRoadEdge {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      geometry: isSet(object.geometry) ? GeometryLine.fromJSON(object.geometry) : undefined,
    };
  },

  toJSON(message: SegRoadEdge): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.geometry !== undefined) {
      obj.geometry = GeometryLine.toJSON(message.geometry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SegRoadEdge>, I>>(base?: I): SegRoadEdge {
    return SegRoadEdge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SegRoadEdge>, I>>(object: I): SegRoadEdge {
    const message = createBaseSegRoadEdge();
    message.id = object.id ?? 0;
    message.geometry = (object.geometry !== undefined && object.geometry !== null)
      ? GeometryLine.fromPartial(object.geometry)
      : undefined;
    return message;
  },
};

function createBaseSlot(): Slot {
  return {
    slotId: 0,
    isSlotBeingOccupied: false,
    p0: undefined,
    p1: undefined,
    p2: undefined,
    p3: undefined,
    typeEnum: 0,
    locationEnum: 0,
    widthM: 0,
    depthM: 0,
    p0p3AngleRad: 0,
    p1p2AngleRad: 0,
    isWheelStopValid: false,
    wheelStopPosition: [],
    isToRelease: false,
  };
}

export const Slot: MessageFns<Slot> = {
  encode(message: Slot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slotId !== 0) {
      writer.uint32(8).uint32(message.slotId);
    }
    if (message.isSlotBeingOccupied !== false) {
      writer.uint32(16).bool(message.isSlotBeingOccupied);
    }
    if (message.p0 !== undefined) {
      Point3f.encode(message.p0, writer.uint32(26).fork()).join();
    }
    if (message.p1 !== undefined) {
      Point3f.encode(message.p1, writer.uint32(34).fork()).join();
    }
    if (message.p2 !== undefined) {
      Point3f.encode(message.p2, writer.uint32(42).fork()).join();
    }
    if (message.p3 !== undefined) {
      Point3f.encode(message.p3, writer.uint32(50).fork()).join();
    }
    if (message.typeEnum !== 0) {
      writer.uint32(56).uint32(message.typeEnum);
    }
    if (message.locationEnum !== 0) {
      writer.uint32(64).uint32(message.locationEnum);
    }
    if (message.widthM !== 0) {
      writer.uint32(77).float(message.widthM);
    }
    if (message.depthM !== 0) {
      writer.uint32(85).float(message.depthM);
    }
    if (message.p0p3AngleRad !== 0) {
      writer.uint32(93).float(message.p0p3AngleRad);
    }
    if (message.p1p2AngleRad !== 0) {
      writer.uint32(101).float(message.p1p2AngleRad);
    }
    if (message.isWheelStopValid !== false) {
      writer.uint32(104).bool(message.isWheelStopValid);
    }
    for (const v of message.wheelStopPosition) {
      Point3f.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.isToRelease !== false) {
      writer.uint32(120).bool(message.isToRelease);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Slot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSlotBeingOccupied = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.p0 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.p1 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.p2 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.p3 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.typeEnum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.locationEnum = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.widthM = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.depthM = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.p0p3AngleRad = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.p1p2AngleRad = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isWheelStopValid = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.wheelStopPosition.push(Point3f.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isToRelease = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Slot {
    return {
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      isSlotBeingOccupied: isSet(object.isSlotBeingOccupied) ? globalThis.Boolean(object.isSlotBeingOccupied) : false,
      p0: isSet(object.p0) ? Point3f.fromJSON(object.p0) : undefined,
      p1: isSet(object.p1) ? Point3f.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Point3f.fromJSON(object.p2) : undefined,
      p3: isSet(object.p3) ? Point3f.fromJSON(object.p3) : undefined,
      typeEnum: isSet(object.typeEnum) ? globalThis.Number(object.typeEnum) : 0,
      locationEnum: isSet(object.locationEnum) ? globalThis.Number(object.locationEnum) : 0,
      widthM: isSet(object.widthM) ? globalThis.Number(object.widthM) : 0,
      depthM: isSet(object.depthM) ? globalThis.Number(object.depthM) : 0,
      p0p3AngleRad: isSet(object.p0p3AngleRad) ? globalThis.Number(object.p0p3AngleRad) : 0,
      p1p2AngleRad: isSet(object.p1p2AngleRad) ? globalThis.Number(object.p1p2AngleRad) : 0,
      isWheelStopValid: isSet(object.isWheelStopValid) ? globalThis.Boolean(object.isWheelStopValid) : false,
      wheelStopPosition: globalThis.Array.isArray(object?.wheelStopPosition)
        ? object.wheelStopPosition.map((e: any) => Point3f.fromJSON(e))
        : [],
      isToRelease: isSet(object.isToRelease) ? globalThis.Boolean(object.isToRelease) : false,
    };
  },

  toJSON(message: Slot): unknown {
    const obj: any = {};
    if (message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.isSlotBeingOccupied !== false) {
      obj.isSlotBeingOccupied = message.isSlotBeingOccupied;
    }
    if (message.p0 !== undefined) {
      obj.p0 = Point3f.toJSON(message.p0);
    }
    if (message.p1 !== undefined) {
      obj.p1 = Point3f.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Point3f.toJSON(message.p2);
    }
    if (message.p3 !== undefined) {
      obj.p3 = Point3f.toJSON(message.p3);
    }
    if (message.typeEnum !== 0) {
      obj.typeEnum = Math.round(message.typeEnum);
    }
    if (message.locationEnum !== 0) {
      obj.locationEnum = Math.round(message.locationEnum);
    }
    if (message.widthM !== 0) {
      obj.widthM = message.widthM;
    }
    if (message.depthM !== 0) {
      obj.depthM = message.depthM;
    }
    if (message.p0p3AngleRad !== 0) {
      obj.p0p3AngleRad = message.p0p3AngleRad;
    }
    if (message.p1p2AngleRad !== 0) {
      obj.p1p2AngleRad = message.p1p2AngleRad;
    }
    if (message.isWheelStopValid !== false) {
      obj.isWheelStopValid = message.isWheelStopValid;
    }
    if (message.wheelStopPosition?.length) {
      obj.wheelStopPosition = message.wheelStopPosition.map((e) => Point3f.toJSON(e));
    }
    if (message.isToRelease !== false) {
      obj.isToRelease = message.isToRelease;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Slot>, I>>(base?: I): Slot {
    return Slot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Slot>, I>>(object: I): Slot {
    const message = createBaseSlot();
    message.slotId = object.slotId ?? 0;
    message.isSlotBeingOccupied = object.isSlotBeingOccupied ?? false;
    message.p0 = (object.p0 !== undefined && object.p0 !== null) ? Point3f.fromPartial(object.p0) : undefined;
    message.p1 = (object.p1 !== undefined && object.p1 !== null) ? Point3f.fromPartial(object.p1) : undefined;
    message.p2 = (object.p2 !== undefined && object.p2 !== null) ? Point3f.fromPartial(object.p2) : undefined;
    message.p3 = (object.p3 !== undefined && object.p3 !== null) ? Point3f.fromPartial(object.p3) : undefined;
    message.typeEnum = object.typeEnum ?? 0;
    message.locationEnum = object.locationEnum ?? 0;
    message.widthM = object.widthM ?? 0;
    message.depthM = object.depthM ?? 0;
    message.p0p3AngleRad = object.p0p3AngleRad ?? 0;
    message.p1p2AngleRad = object.p1p2AngleRad ?? 0;
    message.isWheelStopValid = object.isWheelStopValid ?? false;
    message.wheelStopPosition = object.wheelStopPosition?.map((e) => Point3f.fromPartial(e)) || [];
    message.isToRelease = object.isToRelease ?? false;
    return message;
  },
};

function createBaseLane(): Lane {
  return {
    id: 0,
    numOfSegLane: 0,
    segLaneList: [],
    numOfSegLaneAttr: 0,
    segLaneAttrList: [],
    positionEnum: 0,
    numOfRightLaneLine: 0,
    rightLaneLineIdList: [],
    numOfLeftLaneLine: 0,
    leftLaneLineIdList: [],
  };
}

export const Lane: MessageFns<Lane> = {
  encode(message: Lane, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.numOfSegLane !== 0) {
      writer.uint32(16).uint32(message.numOfSegLane);
    }
    for (const v of message.segLaneList) {
      SegLane.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.numOfSegLaneAttr !== 0) {
      writer.uint32(32).uint32(message.numOfSegLaneAttr);
    }
    for (const v of message.segLaneAttrList) {
      SegLaneAttr.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.positionEnum !== 0) {
      writer.uint32(48).uint32(message.positionEnum);
    }
    if (message.numOfRightLaneLine !== 0) {
      writer.uint32(56).uint32(message.numOfRightLaneLine);
    }
    writer.uint32(66).fork();
    for (const v of message.rightLaneLineIdList) {
      writer.uint32(v);
    }
    writer.join();
    if (message.numOfLeftLaneLine !== 0) {
      writer.uint32(72).uint32(message.numOfLeftLaneLine);
    }
    writer.uint32(82).fork();
    for (const v of message.leftLaneLineIdList) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lane {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLane();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numOfSegLane = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.segLaneList.push(SegLane.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numOfSegLaneAttr = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.segLaneAttrList.push(SegLaneAttr.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.positionEnum = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.numOfRightLaneLine = reader.uint32();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.rightLaneLineIdList.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rightLaneLineIdList.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.numOfLeftLaneLine = reader.uint32();
          continue;
        }
        case 10: {
          if (tag === 80) {
            message.leftLaneLineIdList.push(reader.uint32());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.leftLaneLineIdList.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Lane {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      numOfSegLane: isSet(object.numOfSegLane) ? globalThis.Number(object.numOfSegLane) : 0,
      segLaneList: globalThis.Array.isArray(object?.segLaneList)
        ? object.segLaneList.map((e: any) => SegLane.fromJSON(e))
        : [],
      numOfSegLaneAttr: isSet(object.numOfSegLaneAttr) ? globalThis.Number(object.numOfSegLaneAttr) : 0,
      segLaneAttrList: globalThis.Array.isArray(object?.segLaneAttrList)
        ? object.segLaneAttrList.map((e: any) => SegLaneAttr.fromJSON(e))
        : [],
      positionEnum: isSet(object.positionEnum) ? globalThis.Number(object.positionEnum) : 0,
      numOfRightLaneLine: isSet(object.numOfRightLaneLine) ? globalThis.Number(object.numOfRightLaneLine) : 0,
      rightLaneLineIdList: globalThis.Array.isArray(object?.rightLaneLineIdList)
        ? object.rightLaneLineIdList.map((e: any) => globalThis.Number(e))
        : [],
      numOfLeftLaneLine: isSet(object.numOfLeftLaneLine) ? globalThis.Number(object.numOfLeftLaneLine) : 0,
      leftLaneLineIdList: globalThis.Array.isArray(object?.leftLaneLineIdList)
        ? object.leftLaneLineIdList.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: Lane): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.numOfSegLane !== 0) {
      obj.numOfSegLane = Math.round(message.numOfSegLane);
    }
    if (message.segLaneList?.length) {
      obj.segLaneList = message.segLaneList.map((e) => SegLane.toJSON(e));
    }
    if (message.numOfSegLaneAttr !== 0) {
      obj.numOfSegLaneAttr = Math.round(message.numOfSegLaneAttr);
    }
    if (message.segLaneAttrList?.length) {
      obj.segLaneAttrList = message.segLaneAttrList.map((e) => SegLaneAttr.toJSON(e));
    }
    if (message.positionEnum !== 0) {
      obj.positionEnum = Math.round(message.positionEnum);
    }
    if (message.numOfRightLaneLine !== 0) {
      obj.numOfRightLaneLine = Math.round(message.numOfRightLaneLine);
    }
    if (message.rightLaneLineIdList?.length) {
      obj.rightLaneLineIdList = message.rightLaneLineIdList.map((e) => Math.round(e));
    }
    if (message.numOfLeftLaneLine !== 0) {
      obj.numOfLeftLaneLine = Math.round(message.numOfLeftLaneLine);
    }
    if (message.leftLaneLineIdList?.length) {
      obj.leftLaneLineIdList = message.leftLaneLineIdList.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Lane>, I>>(base?: I): Lane {
    return Lane.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Lane>, I>>(object: I): Lane {
    const message = createBaseLane();
    message.id = object.id ?? 0;
    message.numOfSegLane = object.numOfSegLane ?? 0;
    message.segLaneList = object.segLaneList?.map((e) => SegLane.fromPartial(e)) || [];
    message.numOfSegLaneAttr = object.numOfSegLaneAttr ?? 0;
    message.segLaneAttrList = object.segLaneAttrList?.map((e) => SegLaneAttr.fromPartial(e)) || [];
    message.positionEnum = object.positionEnum ?? 0;
    message.numOfRightLaneLine = object.numOfRightLaneLine ?? 0;
    message.rightLaneLineIdList = object.rightLaneLineIdList?.map((e) => e) || [];
    message.numOfLeftLaneLine = object.numOfLeftLaneLine ?? 0;
    message.leftLaneLineIdList = object.leftLaneLineIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseSegLaneAttr(): SegLaneAttr {
  return { startOffsetM: 0, endOffsetM: 0, laneTypeEnum: 0 };
}

export const SegLaneAttr: MessageFns<SegLaneAttr> = {
  encode(message: SegLaneAttr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startOffsetM !== 0) {
      writer.uint32(13).float(message.startOffsetM);
    }
    if (message.endOffsetM !== 0) {
      writer.uint32(21).float(message.endOffsetM);
    }
    if (message.laneTypeEnum !== 0) {
      writer.uint32(24).uint32(message.laneTypeEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegLaneAttr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegLaneAttr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.startOffsetM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.endOffsetM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.laneTypeEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegLaneAttr {
    return {
      startOffsetM: isSet(object.startOffsetM) ? globalThis.Number(object.startOffsetM) : 0,
      endOffsetM: isSet(object.endOffsetM) ? globalThis.Number(object.endOffsetM) : 0,
      laneTypeEnum: isSet(object.laneTypeEnum) ? globalThis.Number(object.laneTypeEnum) : 0,
    };
  },

  toJSON(message: SegLaneAttr): unknown {
    const obj: any = {};
    if (message.startOffsetM !== 0) {
      obj.startOffsetM = message.startOffsetM;
    }
    if (message.endOffsetM !== 0) {
      obj.endOffsetM = message.endOffsetM;
    }
    if (message.laneTypeEnum !== 0) {
      obj.laneTypeEnum = Math.round(message.laneTypeEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SegLaneAttr>, I>>(base?: I): SegLaneAttr {
    return SegLaneAttr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SegLaneAttr>, I>>(object: I): SegLaneAttr {
    const message = createBaseSegLaneAttr();
    message.startOffsetM = object.startOffsetM ?? 0;
    message.endOffsetM = object.endOffsetM ?? 0;
    message.laneTypeEnum = object.laneTypeEnum ?? 0;
    return message;
  },
};

function createBaseLaneLine(): LaneLine {
  return {
    id: 0,
    numOfSegLaneLine: 0,
    segLaneLineList: [],
    numOfSegLaneLineAttribute: 0,
    segLaneLineAttrList: [],
    positionEnum: 0,
  };
}

export const LaneLine: MessageFns<LaneLine> = {
  encode(message: LaneLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.numOfSegLaneLine !== 0) {
      writer.uint32(16).uint32(message.numOfSegLaneLine);
    }
    for (const v of message.segLaneLineList) {
      SegLaneLine.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.numOfSegLaneLineAttribute !== 0) {
      writer.uint32(32).uint32(message.numOfSegLaneLineAttribute);
    }
    for (const v of message.segLaneLineAttrList) {
      SegLaneLineAttr.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.positionEnum !== 0) {
      writer.uint32(48).uint32(message.positionEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LaneLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLaneLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numOfSegLaneLine = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.segLaneLineList.push(SegLaneLine.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numOfSegLaneLineAttribute = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.segLaneLineAttrList.push(SegLaneLineAttr.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.positionEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LaneLine {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      numOfSegLaneLine: isSet(object.numOfSegLaneLine) ? globalThis.Number(object.numOfSegLaneLine) : 0,
      segLaneLineList: globalThis.Array.isArray(object?.segLaneLineList)
        ? object.segLaneLineList.map((e: any) => SegLaneLine.fromJSON(e))
        : [],
      numOfSegLaneLineAttribute: isSet(object.numOfSegLaneLineAttribute)
        ? globalThis.Number(object.numOfSegLaneLineAttribute)
        : 0,
      segLaneLineAttrList: globalThis.Array.isArray(object?.segLaneLineAttrList)
        ? object.segLaneLineAttrList.map((e: any) => SegLaneLineAttr.fromJSON(e))
        : [],
      positionEnum: isSet(object.positionEnum) ? globalThis.Number(object.positionEnum) : 0,
    };
  },

  toJSON(message: LaneLine): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.numOfSegLaneLine !== 0) {
      obj.numOfSegLaneLine = Math.round(message.numOfSegLaneLine);
    }
    if (message.segLaneLineList?.length) {
      obj.segLaneLineList = message.segLaneLineList.map((e) => SegLaneLine.toJSON(e));
    }
    if (message.numOfSegLaneLineAttribute !== 0) {
      obj.numOfSegLaneLineAttribute = Math.round(message.numOfSegLaneLineAttribute);
    }
    if (message.segLaneLineAttrList?.length) {
      obj.segLaneLineAttrList = message.segLaneLineAttrList.map((e) => SegLaneLineAttr.toJSON(e));
    }
    if (message.positionEnum !== 0) {
      obj.positionEnum = Math.round(message.positionEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LaneLine>, I>>(base?: I): LaneLine {
    return LaneLine.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LaneLine>, I>>(object: I): LaneLine {
    const message = createBaseLaneLine();
    message.id = object.id ?? 0;
    message.numOfSegLaneLine = object.numOfSegLaneLine ?? 0;
    message.segLaneLineList = object.segLaneLineList?.map((e) => SegLaneLine.fromPartial(e)) || [];
    message.numOfSegLaneLineAttribute = object.numOfSegLaneLineAttribute ?? 0;
    message.segLaneLineAttrList = object.segLaneLineAttrList?.map((e) => SegLaneLineAttr.fromPartial(e)) || [];
    message.positionEnum = object.positionEnum ?? 0;
    return message;
  },
};

function createBaseRoadEdge(): RoadEdge {
  return { id: 0, numOfSegRoadEdge: 0, segRoadEdgesList: [] };
}

export const RoadEdge: MessageFns<RoadEdge> = {
  encode(message: RoadEdge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.numOfSegRoadEdge !== 0) {
      writer.uint32(16).uint32(message.numOfSegRoadEdge);
    }
    for (const v of message.segRoadEdgesList) {
      SegRoadEdge.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoadEdge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoadEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numOfSegRoadEdge = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.segRoadEdgesList.push(SegRoadEdge.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoadEdge {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      numOfSegRoadEdge: isSet(object.numOfSegRoadEdge) ? globalThis.Number(object.numOfSegRoadEdge) : 0,
      segRoadEdgesList: globalThis.Array.isArray(object?.segRoadEdgesList)
        ? object.segRoadEdgesList.map((e: any) => SegRoadEdge.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RoadEdge): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.numOfSegRoadEdge !== 0) {
      obj.numOfSegRoadEdge = Math.round(message.numOfSegRoadEdge);
    }
    if (message.segRoadEdgesList?.length) {
      obj.segRoadEdgesList = message.segRoadEdgesList.map((e) => SegRoadEdge.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoadEdge>, I>>(base?: I): RoadEdge {
    return RoadEdge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoadEdge>, I>>(object: I): RoadEdge {
    const message = createBaseRoadEdge();
    message.id = object.id ?? 0;
    message.numOfSegRoadEdge = object.numOfSegRoadEdge ?? 0;
    message.segRoadEdgesList = object.segRoadEdgesList?.map((e) => SegRoadEdge.fromPartial(e)) || [];
    return message;
  },
};

function createBasePoint3f(): Point3f {
  return { xM: 0, yM: 0, zM: 0 };
}

export const Point3f: MessageFns<Point3f> = {
  encode(message: Point3f, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xM !== 0) {
      writer.uint32(13).float(message.xM);
    }
    if (message.yM !== 0) {
      writer.uint32(21).float(message.yM);
    }
    if (message.zM !== 0) {
      writer.uint32(29).float(message.zM);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point3f {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint3f();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.xM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.yM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.zM = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point3f {
    return {
      xM: isSet(object.xM) ? globalThis.Number(object.xM) : 0,
      yM: isSet(object.yM) ? globalThis.Number(object.yM) : 0,
      zM: isSet(object.zM) ? globalThis.Number(object.zM) : 0,
    };
  },

  toJSON(message: Point3f): unknown {
    const obj: any = {};
    if (message.xM !== 0) {
      obj.xM = message.xM;
    }
    if (message.yM !== 0) {
      obj.yM = message.yM;
    }
    if (message.zM !== 0) {
      obj.zM = message.zM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point3f>, I>>(base?: I): Point3f {
    return Point3f.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point3f>, I>>(object: I): Point3f {
    const message = createBasePoint3f();
    message.xM = object.xM ?? 0;
    message.yM = object.yM ?? 0;
    message.zM = object.zM ?? 0;
    return message;
  },
};

function createBaseFusionObject(): FusionObject {
  return {
    id: 0,
    classificationEnum: 0,
    posCenterM: undefined,
    posRefM: undefined,
    yawRad: 0,
    isLightFlashing: [],
    motionTypeEnum: 0,
  };
}

export const FusionObject: MessageFns<FusionObject> = {
  encode(message: FusionObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.classificationEnum !== 0) {
      writer.uint32(16).uint32(message.classificationEnum);
    }
    if (message.posCenterM !== undefined) {
      Point3f.encode(message.posCenterM, writer.uint32(26).fork()).join();
    }
    if (message.posRefM !== undefined) {
      Point3f.encode(message.posRefM, writer.uint32(34).fork()).join();
    }
    if (message.yawRad !== 0) {
      writer.uint32(45).float(message.yawRad);
    }
    writer.uint32(50).fork();
    for (const v of message.isLightFlashing) {
      writer.bool(v);
    }
    writer.join();
    if (message.motionTypeEnum !== 0) {
      writer.uint32(56).uint32(message.motionTypeEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FusionObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFusionObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.classificationEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.posCenterM = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.posRefM = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.yawRad = reader.float();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.isLightFlashing.push(reader.bool());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.isLightFlashing.push(reader.bool());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.motionTypeEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FusionObject {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      classificationEnum: isSet(object.classificationEnum) ? globalThis.Number(object.classificationEnum) : 0,
      posCenterM: isSet(object.posCenterM) ? Point3f.fromJSON(object.posCenterM) : undefined,
      posRefM: isSet(object.posRefM) ? Point3f.fromJSON(object.posRefM) : undefined,
      yawRad: isSet(object.yawRad) ? globalThis.Number(object.yawRad) : 0,
      isLightFlashing: globalThis.Array.isArray(object?.isLightFlashing)
        ? object.isLightFlashing.map((e: any) => globalThis.Boolean(e))
        : [],
      motionTypeEnum: isSet(object.motionTypeEnum) ? globalThis.Number(object.motionTypeEnum) : 0,
    };
  },

  toJSON(message: FusionObject): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.classificationEnum !== 0) {
      obj.classificationEnum = Math.round(message.classificationEnum);
    }
    if (message.posCenterM !== undefined) {
      obj.posCenterM = Point3f.toJSON(message.posCenterM);
    }
    if (message.posRefM !== undefined) {
      obj.posRefM = Point3f.toJSON(message.posRefM);
    }
    if (message.yawRad !== 0) {
      obj.yawRad = message.yawRad;
    }
    if (message.isLightFlashing?.length) {
      obj.isLightFlashing = message.isLightFlashing;
    }
    if (message.motionTypeEnum !== 0) {
      obj.motionTypeEnum = Math.round(message.motionTypeEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FusionObject>, I>>(base?: I): FusionObject {
    return FusionObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FusionObject>, I>>(object: I): FusionObject {
    const message = createBaseFusionObject();
    message.id = object.id ?? 0;
    message.classificationEnum = object.classificationEnum ?? 0;
    message.posCenterM = (object.posCenterM !== undefined && object.posCenterM !== null)
      ? Point3f.fromPartial(object.posCenterM)
      : undefined;
    message.posRefM = (object.posRefM !== undefined && object.posRefM !== null)
      ? Point3f.fromPartial(object.posRefM)
      : undefined;
    message.yawRad = object.yawRad ?? 0;
    message.isLightFlashing = object.isLightFlashing?.map((e) => e) || [];
    message.motionTypeEnum = object.motionTypeEnum ?? 0;
    return message;
  },
};

function createBaseLandMarker(): LandMarker {
  return { id: 0, typeEnum: 0, position: undefined, orientationRad: 0, lengthM: 0, widthM: 0 };
}

export const LandMarker: MessageFns<LandMarker> = {
  encode(message: LandMarker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.typeEnum !== 0) {
      writer.uint32(16).uint32(message.typeEnum);
    }
    if (message.position !== undefined) {
      Point3f.encode(message.position, writer.uint32(26).fork()).join();
    }
    if (message.orientationRad !== 0) {
      writer.uint32(37).float(message.orientationRad);
    }
    if (message.lengthM !== 0) {
      writer.uint32(45).float(message.lengthM);
    }
    if (message.widthM !== 0) {
      writer.uint32(53).float(message.widthM);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandMarker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandMarker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.typeEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.orientationRad = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.lengthM = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.widthM = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandMarker {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      typeEnum: isSet(object.typeEnum) ? globalThis.Number(object.typeEnum) : 0,
      position: isSet(object.position) ? Point3f.fromJSON(object.position) : undefined,
      orientationRad: isSet(object.orientationRad) ? globalThis.Number(object.orientationRad) : 0,
      lengthM: isSet(object.lengthM) ? globalThis.Number(object.lengthM) : 0,
      widthM: isSet(object.widthM) ? globalThis.Number(object.widthM) : 0,
    };
  },

  toJSON(message: LandMarker): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.typeEnum !== 0) {
      obj.typeEnum = Math.round(message.typeEnum);
    }
    if (message.position !== undefined) {
      obj.position = Point3f.toJSON(message.position);
    }
    if (message.orientationRad !== 0) {
      obj.orientationRad = message.orientationRad;
    }
    if (message.lengthM !== 0) {
      obj.lengthM = message.lengthM;
    }
    if (message.widthM !== 0) {
      obj.widthM = message.widthM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandMarker>, I>>(base?: I): LandMarker {
    return LandMarker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandMarker>, I>>(object: I): LandMarker {
    const message = createBaseLandMarker();
    message.id = object.id ?? 0;
    message.typeEnum = object.typeEnum ?? 0;
    message.position = (object.position !== undefined && object.position !== null)
      ? Point3f.fromPartial(object.position)
      : undefined;
    message.orientationRad = object.orientationRad ?? 0;
    message.lengthM = object.lengthM ?? 0;
    message.widthM = object.widthM ?? 0;
    return message;
  },
};

function createBaseLandMarker2(): LandMarker2 {
  return {
    id: 0,
    typeEnum: 0,
    position: undefined,
    orientationRad: 0,
    lengthM: 0,
    widthM: 0,
    trafficLightStatusEnum: 0,
  };
}

export const LandMarker2: MessageFns<LandMarker2> = {
  encode(message: LandMarker2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.typeEnum !== 0) {
      writer.uint32(16).uint32(message.typeEnum);
    }
    if (message.position !== undefined) {
      Point3f.encode(message.position, writer.uint32(26).fork()).join();
    }
    if (message.orientationRad !== 0) {
      writer.uint32(37).float(message.orientationRad);
    }
    if (message.lengthM !== 0) {
      writer.uint32(45).float(message.lengthM);
    }
    if (message.widthM !== 0) {
      writer.uint32(53).float(message.widthM);
    }
    if (message.trafficLightStatusEnum !== 0) {
      writer.uint32(56).uint32(message.trafficLightStatusEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandMarker2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandMarker2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.typeEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.orientationRad = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.lengthM = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.widthM = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.trafficLightStatusEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandMarker2 {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      typeEnum: isSet(object.typeEnum) ? globalThis.Number(object.typeEnum) : 0,
      position: isSet(object.position) ? Point3f.fromJSON(object.position) : undefined,
      orientationRad: isSet(object.orientationRad) ? globalThis.Number(object.orientationRad) : 0,
      lengthM: isSet(object.lengthM) ? globalThis.Number(object.lengthM) : 0,
      widthM: isSet(object.widthM) ? globalThis.Number(object.widthM) : 0,
      trafficLightStatusEnum: isSet(object.trafficLightStatusEnum)
        ? globalThis.Number(object.trafficLightStatusEnum)
        : 0,
    };
  },

  toJSON(message: LandMarker2): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.typeEnum !== 0) {
      obj.typeEnum = Math.round(message.typeEnum);
    }
    if (message.position !== undefined) {
      obj.position = Point3f.toJSON(message.position);
    }
    if (message.orientationRad !== 0) {
      obj.orientationRad = message.orientationRad;
    }
    if (message.lengthM !== 0) {
      obj.lengthM = message.lengthM;
    }
    if (message.widthM !== 0) {
      obj.widthM = message.widthM;
    }
    if (message.trafficLightStatusEnum !== 0) {
      obj.trafficLightStatusEnum = Math.round(message.trafficLightStatusEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandMarker2>, I>>(base?: I): LandMarker2 {
    return LandMarker2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandMarker2>, I>>(object: I): LandMarker2 {
    const message = createBaseLandMarker2();
    message.id = object.id ?? 0;
    message.typeEnum = object.typeEnum ?? 0;
    message.position = (object.position !== undefined && object.position !== null)
      ? Point3f.fromPartial(object.position)
      : undefined;
    message.orientationRad = object.orientationRad ?? 0;
    message.lengthM = object.lengthM ?? 0;
    message.widthM = object.widthM ?? 0;
    message.trafficLightStatusEnum = object.trafficLightStatusEnum ?? 0;
    return message;
  },
};

function createBaseReflineViz(): ReflineViz {
  return { xM: 0, yM: 0, zM: 0, leftWidthM: 0, rightWidthM: 0 };
}

export const ReflineViz: MessageFns<ReflineViz> = {
  encode(message: ReflineViz, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xM !== 0) {
      writer.uint32(13).float(message.xM);
    }
    if (message.yM !== 0) {
      writer.uint32(21).float(message.yM);
    }
    if (message.zM !== 0) {
      writer.uint32(29).float(message.zM);
    }
    if (message.leftWidthM !== 0) {
      writer.uint32(37).float(message.leftWidthM);
    }
    if (message.rightWidthM !== 0) {
      writer.uint32(45).float(message.rightWidthM);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReflineViz {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReflineViz();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.xM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.yM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.zM = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.leftWidthM = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.rightWidthM = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReflineViz {
    return {
      xM: isSet(object.xM) ? globalThis.Number(object.xM) : 0,
      yM: isSet(object.yM) ? globalThis.Number(object.yM) : 0,
      zM: isSet(object.zM) ? globalThis.Number(object.zM) : 0,
      leftWidthM: isSet(object.leftWidthM) ? globalThis.Number(object.leftWidthM) : 0,
      rightWidthM: isSet(object.rightWidthM) ? globalThis.Number(object.rightWidthM) : 0,
    };
  },

  toJSON(message: ReflineViz): unknown {
    const obj: any = {};
    if (message.xM !== 0) {
      obj.xM = message.xM;
    }
    if (message.yM !== 0) {
      obj.yM = message.yM;
    }
    if (message.zM !== 0) {
      obj.zM = message.zM;
    }
    if (message.leftWidthM !== 0) {
      obj.leftWidthM = message.leftWidthM;
    }
    if (message.rightWidthM !== 0) {
      obj.rightWidthM = message.rightWidthM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReflineViz>, I>>(base?: I): ReflineViz {
    return ReflineViz.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReflineViz>, I>>(object: I): ReflineViz {
    const message = createBaseReflineViz();
    message.xM = object.xM ?? 0;
    message.yM = object.yM ?? 0;
    message.zM = object.zM ?? 0;
    message.leftWidthM = object.leftWidthM ?? 0;
    message.rightWidthM = object.rightWidthM ?? 0;
    return message;
  },
};

function createBaseTrajViz(): TrajViz {
  return { xM: 0, yM: 0, zM: 0, sM: 0, vMS: 0 };
}

export const TrajViz: MessageFns<TrajViz> = {
  encode(message: TrajViz, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xM !== 0) {
      writer.uint32(13).float(message.xM);
    }
    if (message.yM !== 0) {
      writer.uint32(21).float(message.yM);
    }
    if (message.zM !== 0) {
      writer.uint32(29).float(message.zM);
    }
    if (message.sM !== 0) {
      writer.uint32(37).float(message.sM);
    }
    if (message.vMS !== 0) {
      writer.uint32(45).float(message.vMS);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrajViz {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrajViz();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.xM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.yM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.zM = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.sM = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.vMS = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrajViz {
    return {
      xM: isSet(object.xM) ? globalThis.Number(object.xM) : 0,
      yM: isSet(object.yM) ? globalThis.Number(object.yM) : 0,
      zM: isSet(object.zM) ? globalThis.Number(object.zM) : 0,
      sM: isSet(object.sM) ? globalThis.Number(object.sM) : 0,
      vMS: isSet(object.vMS) ? globalThis.Number(object.vMS) : 0,
    };
  },

  toJSON(message: TrajViz): unknown {
    const obj: any = {};
    if (message.xM !== 0) {
      obj.xM = message.xM;
    }
    if (message.yM !== 0) {
      obj.yM = message.yM;
    }
    if (message.zM !== 0) {
      obj.zM = message.zM;
    }
    if (message.sM !== 0) {
      obj.sM = message.sM;
    }
    if (message.vMS !== 0) {
      obj.vMS = message.vMS;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrajViz>, I>>(base?: I): TrajViz {
    return TrajViz.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrajViz>, I>>(object: I): TrajViz {
    const message = createBaseTrajViz();
    message.xM = object.xM ?? 0;
    message.yM = object.yM ?? 0;
    message.zM = object.zM ?? 0;
    message.sM = object.sM ?? 0;
    message.vMS = object.vMS ?? 0;
    return message;
  },
};

function createBaseVehicleTrajectory(): VehicleTrajectory {
  return { ptsList: [] };
}

export const VehicleTrajectory: MessageFns<VehicleTrajectory> = {
  encode(message: VehicleTrajectory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ptsList) {
      TrajectoryPoint.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleTrajectory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleTrajectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ptsList.push(TrajectoryPoint.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleTrajectory {
    return {
      ptsList: globalThis.Array.isArray(object?.ptsList)
        ? object.ptsList.map((e: any) => TrajectoryPoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VehicleTrajectory): unknown {
    const obj: any = {};
    if (message.ptsList?.length) {
      obj.ptsList = message.ptsList.map((e) => TrajectoryPoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VehicleTrajectory>, I>>(base?: I): VehicleTrajectory {
    return VehicleTrajectory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VehicleTrajectory>, I>>(object: I): VehicleTrajectory {
    const message = createBaseVehicleTrajectory();
    message.ptsList = object.ptsList?.map((e) => TrajectoryPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrajectoryPoint(): TrajectoryPoint {
  return { xM: 0, yM: 0 };
}

export const TrajectoryPoint: MessageFns<TrajectoryPoint> = {
  encode(message: TrajectoryPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xM !== 0) {
      writer.uint32(13).float(message.xM);
    }
    if (message.yM !== 0) {
      writer.uint32(21).float(message.yM);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrajectoryPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrajectoryPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.xM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.yM = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrajectoryPoint {
    return {
      xM: isSet(object.xM) ? globalThis.Number(object.xM) : 0,
      yM: isSet(object.yM) ? globalThis.Number(object.yM) : 0,
    };
  },

  toJSON(message: TrajectoryPoint): unknown {
    const obj: any = {};
    if (message.xM !== 0) {
      obj.xM = message.xM;
    }
    if (message.yM !== 0) {
      obj.yM = message.yM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrajectoryPoint>, I>>(base?: I): TrajectoryPoint {
    return TrajectoryPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrajectoryPoint>, I>>(object: I): TrajectoryPoint {
    const message = createBaseTrajectoryPoint();
    message.xM = object.xM ?? 0;
    message.yM = object.yM ?? 0;
    return message;
  },
};

function createBasePose(): Pose {
  return { position: undefined, orientation: undefined };
}

export const Pose: MessageFns<Pose> = {
  encode(message: Pose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Point3f.encode(message.position, writer.uint32(10).fork()).join();
    }
    if (message.orientation !== undefined) {
      Quaternion4f.encode(message.orientation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orientation = Quaternion4f.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pose {
    return {
      position: isSet(object.position) ? Point3f.fromJSON(object.position) : undefined,
      orientation: isSet(object.orientation) ? Quaternion4f.fromJSON(object.orientation) : undefined,
    };
  },

  toJSON(message: Pose): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Point3f.toJSON(message.position);
    }
    if (message.orientation !== undefined) {
      obj.orientation = Quaternion4f.toJSON(message.orientation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pose>, I>>(base?: I): Pose {
    return Pose.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pose>, I>>(object: I): Pose {
    const message = createBasePose();
    message.position = (object.position !== undefined && object.position !== null)
      ? Point3f.fromPartial(object.position)
      : undefined;
    message.orientation = (object.orientation !== undefined && object.orientation !== null)
      ? Quaternion4f.fromPartial(object.orientation)
      : undefined;
    return message;
  },
};

function createBaseQuaternion4f(): Quaternion4f {
  return { x: 0, y: 0, z: 0, w: 0 };
}

export const Quaternion4f: MessageFns<Quaternion4f> = {
  encode(message: Quaternion4f, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    if (message.w !== 0) {
      writer.uint32(37).float(message.w);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Quaternion4f {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuaternion4f();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.w = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Quaternion4f {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      w: isSet(object.w) ? globalThis.Number(object.w) : 0,
    };
  },

  toJSON(message: Quaternion4f): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    if (message.w !== 0) {
      obj.w = message.w;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Quaternion4f>, I>>(base?: I): Quaternion4f {
    return Quaternion4f.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Quaternion4f>, I>>(object: I): Quaternion4f {
    const message = createBaseQuaternion4f();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.w = object.w ?? 0;
    return message;
  },
};

function createBaseStaticElements(): StaticElements {
  return { numOfElements: 0, elementsList: [] };
}

export const StaticElements: MessageFns<StaticElements> = {
  encode(message: StaticElements, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numOfElements !== 0) {
      writer.uint32(8).uint32(message.numOfElements);
    }
    for (const v of message.elementsList) {
      StaticElement.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StaticElements {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaticElements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numOfElements = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.elementsList.push(StaticElement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StaticElements {
    return {
      numOfElements: isSet(object.numOfElements) ? globalThis.Number(object.numOfElements) : 0,
      elementsList: globalThis.Array.isArray(object?.elementsList)
        ? object.elementsList.map((e: any) => StaticElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StaticElements): unknown {
    const obj: any = {};
    if (message.numOfElements !== 0) {
      obj.numOfElements = Math.round(message.numOfElements);
    }
    if (message.elementsList?.length) {
      obj.elementsList = message.elementsList.map((e) => StaticElement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StaticElements>, I>>(base?: I): StaticElements {
    return StaticElements.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StaticElements>, I>>(object: I): StaticElements {
    const message = createBaseStaticElements();
    message.numOfElements = object.numOfElements ?? 0;
    message.elementsList = object.elementsList?.map((e) => StaticElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoad(): Road {
  return { numOfLaneLine: 0, laneLinesList: [], numOfRoadedge: 0, roadEdgesList: [], numOfLane: 0, lanesList: [] };
}

export const Road: MessageFns<Road> = {
  encode(message: Road, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numOfLaneLine !== 0) {
      writer.uint32(8).uint32(message.numOfLaneLine);
    }
    for (const v of message.laneLinesList) {
      LaneLine.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.numOfRoadedge !== 0) {
      writer.uint32(24).uint32(message.numOfRoadedge);
    }
    for (const v of message.roadEdgesList) {
      RoadEdge.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.numOfLane !== 0) {
      writer.uint32(40).uint32(message.numOfLane);
    }
    for (const v of message.lanesList) {
      Lane.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Road {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoad();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numOfLaneLine = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.laneLinesList.push(LaneLine.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numOfRoadedge = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.roadEdgesList.push(RoadEdge.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numOfLane = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lanesList.push(Lane.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Road {
    return {
      numOfLaneLine: isSet(object.numOfLaneLine) ? globalThis.Number(object.numOfLaneLine) : 0,
      laneLinesList: globalThis.Array.isArray(object?.laneLinesList)
        ? object.laneLinesList.map((e: any) => LaneLine.fromJSON(e))
        : [],
      numOfRoadedge: isSet(object.numOfRoadedge) ? globalThis.Number(object.numOfRoadedge) : 0,
      roadEdgesList: globalThis.Array.isArray(object?.roadEdgesList)
        ? object.roadEdgesList.map((e: any) => RoadEdge.fromJSON(e))
        : [],
      numOfLane: isSet(object.numOfLane) ? globalThis.Number(object.numOfLane) : 0,
      lanesList: globalThis.Array.isArray(object?.lanesList) ? object.lanesList.map((e: any) => Lane.fromJSON(e)) : [],
    };
  },

  toJSON(message: Road): unknown {
    const obj: any = {};
    if (message.numOfLaneLine !== 0) {
      obj.numOfLaneLine = Math.round(message.numOfLaneLine);
    }
    if (message.laneLinesList?.length) {
      obj.laneLinesList = message.laneLinesList.map((e) => LaneLine.toJSON(e));
    }
    if (message.numOfRoadedge !== 0) {
      obj.numOfRoadedge = Math.round(message.numOfRoadedge);
    }
    if (message.roadEdgesList?.length) {
      obj.roadEdgesList = message.roadEdgesList.map((e) => RoadEdge.toJSON(e));
    }
    if (message.numOfLane !== 0) {
      obj.numOfLane = Math.round(message.numOfLane);
    }
    if (message.lanesList?.length) {
      obj.lanesList = message.lanesList.map((e) => Lane.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Road>, I>>(base?: I): Road {
    return Road.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Road>, I>>(object: I): Road {
    const message = createBaseRoad();
    message.numOfLaneLine = object.numOfLaneLine ?? 0;
    message.laneLinesList = object.laneLinesList?.map((e) => LaneLine.fromPartial(e)) || [];
    message.numOfRoadedge = object.numOfRoadedge ?? 0;
    message.roadEdgesList = object.roadEdgesList?.map((e) => RoadEdge.fromPartial(e)) || [];
    message.numOfLane = object.numOfLane ?? 0;
    message.lanesList = object.lanesList?.map((e) => Lane.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFusionObjects(): FusionObjects {
  return { numberOfObjects: 0, objects: [] };
}

export const FusionObjects: MessageFns<FusionObjects> = {
  encode(message: FusionObjects, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numberOfObjects !== 0) {
      writer.uint32(8).uint32(message.numberOfObjects);
    }
    for (const v of message.objects) {
      FusionObject.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FusionObjects {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFusionObjects();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numberOfObjects = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objects.push(FusionObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FusionObjects {
    return {
      numberOfObjects: isSet(object.numberOfObjects) ? globalThis.Number(object.numberOfObjects) : 0,
      objects: globalThis.Array.isArray(object?.objects)
        ? object.objects.map((e: any) => FusionObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FusionObjects): unknown {
    const obj: any = {};
    if (message.numberOfObjects !== 0) {
      obj.numberOfObjects = Math.round(message.numberOfObjects);
    }
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => FusionObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FusionObjects>, I>>(base?: I): FusionObjects {
    return FusionObjects.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FusionObjects>, I>>(object: I): FusionObjects {
    const message = createBaseFusionObjects();
    message.numberOfObjects = object.numberOfObjects ?? 0;
    message.objects = object.objects?.map((e) => FusionObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSlotsList(): SlotsList {
  return { numOfParkingSlots: 0, slotsList: [] };
}

export const SlotsList: MessageFns<SlotsList> = {
  encode(message: SlotsList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numOfParkingSlots !== 0) {
      writer.uint32(8).uint32(message.numOfParkingSlots);
    }
    for (const v of message.slotsList) {
      Slot.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlotsList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlotsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numOfParkingSlots = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.slotsList.push(Slot.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlotsList {
    return {
      numOfParkingSlots: isSet(object.numOfParkingSlots) ? globalThis.Number(object.numOfParkingSlots) : 0,
      slotsList: globalThis.Array.isArray(object?.slotsList) ? object.slotsList.map((e: any) => Slot.fromJSON(e)) : [],
    };
  },

  toJSON(message: SlotsList): unknown {
    const obj: any = {};
    if (message.numOfParkingSlots !== 0) {
      obj.numOfParkingSlots = Math.round(message.numOfParkingSlots);
    }
    if (message.slotsList?.length) {
      obj.slotsList = message.slotsList.map((e) => Slot.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlotsList>, I>>(base?: I): SlotsList {
    return SlotsList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlotsList>, I>>(object: I): SlotsList {
    const message = createBaseSlotsList();
    message.numOfParkingSlots = object.numOfParkingSlots ?? 0;
    message.slotsList = object.slotsList?.map((e) => Slot.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLandMarkers(): LandMarkers {
  return { numOfTrafficLandmarkers: 0, landMarkersList: [] };
}

export const LandMarkers: MessageFns<LandMarkers> = {
  encode(message: LandMarkers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numOfTrafficLandmarkers !== 0) {
      writer.uint32(8).uint32(message.numOfTrafficLandmarkers);
    }
    for (const v of message.landMarkersList) {
      LandMarker.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandMarkers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandMarkers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numOfTrafficLandmarkers = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.landMarkersList.push(LandMarker.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandMarkers {
    return {
      numOfTrafficLandmarkers: isSet(object.numOfTrafficLandmarkers)
        ? globalThis.Number(object.numOfTrafficLandmarkers)
        : 0,
      landMarkersList: globalThis.Array.isArray(object?.landMarkersList)
        ? object.landMarkersList.map((e: any) => LandMarker.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LandMarkers): unknown {
    const obj: any = {};
    if (message.numOfTrafficLandmarkers !== 0) {
      obj.numOfTrafficLandmarkers = Math.round(message.numOfTrafficLandmarkers);
    }
    if (message.landMarkersList?.length) {
      obj.landMarkersList = message.landMarkersList.map((e) => LandMarker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandMarkers>, I>>(base?: I): LandMarkers {
    return LandMarkers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandMarkers>, I>>(object: I): LandMarkers {
    const message = createBaseLandMarkers();
    message.numOfTrafficLandmarkers = object.numOfTrafficLandmarkers ?? 0;
    message.landMarkersList = object.landMarkersList?.map((e) => LandMarker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFsmOut(): FsmOut {
  return {
    fsmNodeInfo: undefined,
    drvSignals: undefined,
    hmiSignals: undefined,
    panelSignals: undefined,
    prkSignals: undefined,
    drvPrkDualInfoEnum: 0,
  };
}

export const FsmOut: MessageFns<FsmOut> = {
  encode(message: FsmOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fsmNodeInfo !== undefined) {
      FSMNodeInfo.encode(message.fsmNodeInfo, writer.uint32(10).fork()).join();
    }
    if (message.drvSignals !== undefined) {
      DrivingSignals.encode(message.drvSignals, writer.uint32(18).fork()).join();
    }
    if (message.hmiSignals !== undefined) {
      HmiSignals.encode(message.hmiSignals, writer.uint32(26).fork()).join();
    }
    if (message.panelSignals !== undefined) {
      PanelSignals.encode(message.panelSignals, writer.uint32(34).fork()).join();
    }
    if (message.prkSignals !== undefined) {
      ParkingSignals.encode(message.prkSignals, writer.uint32(42).fork()).join();
    }
    if (message.drvPrkDualInfoEnum !== 0) {
      writer.uint32(48).uint32(message.drvPrkDualInfoEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FsmOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFsmOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fsmNodeInfo = FSMNodeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.drvSignals = DrivingSignals.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hmiSignals = HmiSignals.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.panelSignals = PanelSignals.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prkSignals = ParkingSignals.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.drvPrkDualInfoEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FsmOut {
    return {
      fsmNodeInfo: isSet(object.fsmNodeInfo) ? FSMNodeInfo.fromJSON(object.fsmNodeInfo) : undefined,
      drvSignals: isSet(object.drvSignals) ? DrivingSignals.fromJSON(object.drvSignals) : undefined,
      hmiSignals: isSet(object.hmiSignals) ? HmiSignals.fromJSON(object.hmiSignals) : undefined,
      panelSignals: isSet(object.panelSignals) ? PanelSignals.fromJSON(object.panelSignals) : undefined,
      prkSignals: isSet(object.prkSignals) ? ParkingSignals.fromJSON(object.prkSignals) : undefined,
      drvPrkDualInfoEnum: isSet(object.drvPrkDualInfoEnum) ? globalThis.Number(object.drvPrkDualInfoEnum) : 0,
    };
  },

  toJSON(message: FsmOut): unknown {
    const obj: any = {};
    if (message.fsmNodeInfo !== undefined) {
      obj.fsmNodeInfo = FSMNodeInfo.toJSON(message.fsmNodeInfo);
    }
    if (message.drvSignals !== undefined) {
      obj.drvSignals = DrivingSignals.toJSON(message.drvSignals);
    }
    if (message.hmiSignals !== undefined) {
      obj.hmiSignals = HmiSignals.toJSON(message.hmiSignals);
    }
    if (message.panelSignals !== undefined) {
      obj.panelSignals = PanelSignals.toJSON(message.panelSignals);
    }
    if (message.prkSignals !== undefined) {
      obj.prkSignals = ParkingSignals.toJSON(message.prkSignals);
    }
    if (message.drvPrkDualInfoEnum !== 0) {
      obj.drvPrkDualInfoEnum = Math.round(message.drvPrkDualInfoEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FsmOut>, I>>(base?: I): FsmOut {
    return FsmOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FsmOut>, I>>(object: I): FsmOut {
    const message = createBaseFsmOut();
    message.fsmNodeInfo = (object.fsmNodeInfo !== undefined && object.fsmNodeInfo !== null)
      ? FSMNodeInfo.fromPartial(object.fsmNodeInfo)
      : undefined;
    message.drvSignals = (object.drvSignals !== undefined && object.drvSignals !== null)
      ? DrivingSignals.fromPartial(object.drvSignals)
      : undefined;
    message.hmiSignals = (object.hmiSignals !== undefined && object.hmiSignals !== null)
      ? HmiSignals.fromPartial(object.hmiSignals)
      : undefined;
    message.panelSignals = (object.panelSignals !== undefined && object.panelSignals !== null)
      ? PanelSignals.fromPartial(object.panelSignals)
      : undefined;
    message.prkSignals = (object.prkSignals !== undefined && object.prkSignals !== null)
      ? ParkingSignals.fromPartial(object.prkSignals)
      : undefined;
    message.drvPrkDualInfoEnum = object.drvPrkDualInfoEnum ?? 0;
    return message;
  },
};

function createBaseVehicleChassis(): VehicleChassis {
  return { vehdyn: undefined, brksys: undefined, pt: undefined, strsys: undefined };
}

export const VehicleChassis: MessageFns<VehicleChassis> = {
  encode(message: VehicleChassis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vehdyn !== undefined) {
      VehicleDynamic.encode(message.vehdyn, writer.uint32(10).fork()).join();
    }
    if (message.brksys !== undefined) {
      BrakeSystem.encode(message.brksys, writer.uint32(18).fork()).join();
    }
    if (message.pt !== undefined) {
      PowerTrain.encode(message.pt, writer.uint32(26).fork()).join();
    }
    if (message.strsys !== undefined) {
      SteeringSystem.encode(message.strsys, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleChassis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleChassis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vehdyn = VehicleDynamic.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.brksys = BrakeSystem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pt = PowerTrain.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.strsys = SteeringSystem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleChassis {
    return {
      vehdyn: isSet(object.vehdyn) ? VehicleDynamic.fromJSON(object.vehdyn) : undefined,
      brksys: isSet(object.brksys) ? BrakeSystem.fromJSON(object.brksys) : undefined,
      pt: isSet(object.pt) ? PowerTrain.fromJSON(object.pt) : undefined,
      strsys: isSet(object.strsys) ? SteeringSystem.fromJSON(object.strsys) : undefined,
    };
  },

  toJSON(message: VehicleChassis): unknown {
    const obj: any = {};
    if (message.vehdyn !== undefined) {
      obj.vehdyn = VehicleDynamic.toJSON(message.vehdyn);
    }
    if (message.brksys !== undefined) {
      obj.brksys = BrakeSystem.toJSON(message.brksys);
    }
    if (message.pt !== undefined) {
      obj.pt = PowerTrain.toJSON(message.pt);
    }
    if (message.strsys !== undefined) {
      obj.strsys = SteeringSystem.toJSON(message.strsys);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VehicleChassis>, I>>(base?: I): VehicleChassis {
    return VehicleChassis.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VehicleChassis>, I>>(object: I): VehicleChassis {
    const message = createBaseVehicleChassis();
    message.vehdyn = (object.vehdyn !== undefined && object.vehdyn !== null)
      ? VehicleDynamic.fromPartial(object.vehdyn)
      : undefined;
    message.brksys = (object.brksys !== undefined && object.brksys !== null)
      ? BrakeSystem.fromPartial(object.brksys)
      : undefined;
    message.pt = (object.pt !== undefined && object.pt !== null) ? PowerTrain.fromPartial(object.pt) : undefined;
    message.strsys = (object.strsys !== undefined && object.strsys !== null)
      ? SteeringSystem.fromPartial(object.strsys)
      : undefined;
    return message;
  },
};

function createBaseVehicleStatus(): VehicleStatus {
  return { vehbody: undefined };
}

export const VehicleStatus: MessageFns<VehicleStatus> = {
  encode(message: VehicleStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vehbody !== undefined) {
      VehicleBody.encode(message.vehbody, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vehbody = VehicleBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleStatus {
    return { vehbody: isSet(object.vehbody) ? VehicleBody.fromJSON(object.vehbody) : undefined };
  },

  toJSON(message: VehicleStatus): unknown {
    const obj: any = {};
    if (message.vehbody !== undefined) {
      obj.vehbody = VehicleBody.toJSON(message.vehbody);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VehicleStatus>, I>>(base?: I): VehicleStatus {
    return VehicleStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VehicleStatus>, I>>(object: I): VehicleStatus {
    const message = createBaseVehicleStatus();
    message.vehbody = (object.vehbody !== undefined && object.vehbody !== null)
      ? VehicleBody.fromPartial(object.vehbody)
      : undefined;
    return message;
  },
};

function createBasePathInfoHmi(): PathInfoHmi {
  return { numReflineVizPts: 0, reflineVizPts: [], numTrajVizPts: 0, trajVizPts: [] };
}

export const PathInfoHmi: MessageFns<PathInfoHmi> = {
  encode(message: PathInfoHmi, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numReflineVizPts !== 0) {
      writer.uint32(8).uint32(message.numReflineVizPts);
    }
    for (const v of message.reflineVizPts) {
      ReflineViz.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.numTrajVizPts !== 0) {
      writer.uint32(24).uint32(message.numTrajVizPts);
    }
    for (const v of message.trajVizPts) {
      TrajViz.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathInfoHmi {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathInfoHmi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numReflineVizPts = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reflineVizPts.push(ReflineViz.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numTrajVizPts = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trajVizPts.push(TrajViz.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PathInfoHmi {
    return {
      numReflineVizPts: isSet(object.numReflineVizPts) ? globalThis.Number(object.numReflineVizPts) : 0,
      reflineVizPts: globalThis.Array.isArray(object?.reflineVizPts)
        ? object.reflineVizPts.map((e: any) => ReflineViz.fromJSON(e))
        : [],
      numTrajVizPts: isSet(object.numTrajVizPts) ? globalThis.Number(object.numTrajVizPts) : 0,
      trajVizPts: globalThis.Array.isArray(object?.trajVizPts)
        ? object.trajVizPts.map((e: any) => TrajViz.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PathInfoHmi): unknown {
    const obj: any = {};
    if (message.numReflineVizPts !== 0) {
      obj.numReflineVizPts = Math.round(message.numReflineVizPts);
    }
    if (message.reflineVizPts?.length) {
      obj.reflineVizPts = message.reflineVizPts.map((e) => ReflineViz.toJSON(e));
    }
    if (message.numTrajVizPts !== 0) {
      obj.numTrajVizPts = Math.round(message.numTrajVizPts);
    }
    if (message.trajVizPts?.length) {
      obj.trajVizPts = message.trajVizPts.map((e) => TrajViz.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PathInfoHmi>, I>>(base?: I): PathInfoHmi {
    return PathInfoHmi.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathInfoHmi>, I>>(object: I): PathInfoHmi {
    const message = createBasePathInfoHmi();
    message.numReflineVizPts = object.numReflineVizPts ?? 0;
    message.reflineVizPts = object.reflineVizPts?.map((e) => ReflineViz.fromPartial(e)) || [];
    message.numTrajVizPts = object.numTrajVizPts ?? 0;
    message.trajVizPts = object.trajVizPts?.map((e) => TrajViz.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHMIRequest(): HMIRequest {
  return { parkingPadReq: undefined, avmPadReq: undefined };
}

export const HMIRequest: MessageFns<HMIRequest> = {
  encode(message: HMIRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parkingPadReq !== undefined) {
      ParkingPadRequest.encode(message.parkingPadReq, writer.uint32(10).fork()).join();
    }
    if (message.avmPadReq !== undefined) {
      AvmPadRequest.encode(message.avmPadReq, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HMIRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHMIRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parkingPadReq = ParkingPadRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.avmPadReq = AvmPadRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HMIRequest {
    return {
      parkingPadReq: isSet(object.parkingPadReq) ? ParkingPadRequest.fromJSON(object.parkingPadReq) : undefined,
      avmPadReq: isSet(object.avmPadReq) ? AvmPadRequest.fromJSON(object.avmPadReq) : undefined,
    };
  },

  toJSON(message: HMIRequest): unknown {
    const obj: any = {};
    if (message.parkingPadReq !== undefined) {
      obj.parkingPadReq = ParkingPadRequest.toJSON(message.parkingPadReq);
    }
    if (message.avmPadReq !== undefined) {
      obj.avmPadReq = AvmPadRequest.toJSON(message.avmPadReq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HMIRequest>, I>>(base?: I): HMIRequest {
    return HMIRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HMIRequest>, I>>(object: I): HMIRequest {
    const message = createBaseHMIRequest();
    message.parkingPadReq = (object.parkingPadReq !== undefined && object.parkingPadReq !== null)
      ? ParkingPadRequest.fromPartial(object.parkingPadReq)
      : undefined;
    message.avmPadReq = (object.avmPadReq !== undefined && object.avmPadReq !== null)
      ? AvmPadRequest.fromPartial(object.avmPadReq)
      : undefined;
    return message;
  },
};

function createBaseAvmPadRespone(): AvmPadRespone {
  return { avmChannelButtonRespEnum: 0, avmFrontRearWheelRespEnum: 0, apa360ButtonStsEnum: 0, apaSettingsRespEnum: 0 };
}

export const AvmPadRespone: MessageFns<AvmPadRespone> = {
  encode(message: AvmPadRespone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.avmChannelButtonRespEnum !== 0) {
      writer.uint32(8).uint32(message.avmChannelButtonRespEnum);
    }
    if (message.avmFrontRearWheelRespEnum !== 0) {
      writer.uint32(16).uint32(message.avmFrontRearWheelRespEnum);
    }
    if (message.apa360ButtonStsEnum !== 0) {
      writer.uint32(24).uint32(message.apa360ButtonStsEnum);
    }
    if (message.apaSettingsRespEnum !== 0) {
      writer.uint32(32).uint32(message.apaSettingsRespEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvmPadRespone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvmPadRespone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.avmChannelButtonRespEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.avmFrontRearWheelRespEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.apa360ButtonStsEnum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.apaSettingsRespEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvmPadRespone {
    return {
      avmChannelButtonRespEnum: isSet(object.avmChannelButtonRespEnum)
        ? globalThis.Number(object.avmChannelButtonRespEnum)
        : 0,
      avmFrontRearWheelRespEnum: isSet(object.avmFrontRearWheelRespEnum)
        ? globalThis.Number(object.avmFrontRearWheelRespEnum)
        : 0,
      apa360ButtonStsEnum: isSet(object.apa360ButtonStsEnum) ? globalThis.Number(object.apa360ButtonStsEnum) : 0,
      apaSettingsRespEnum: isSet(object.apaSettingsRespEnum) ? globalThis.Number(object.apaSettingsRespEnum) : 0,
    };
  },

  toJSON(message: AvmPadRespone): unknown {
    const obj: any = {};
    if (message.avmChannelButtonRespEnum !== 0) {
      obj.avmChannelButtonRespEnum = Math.round(message.avmChannelButtonRespEnum);
    }
    if (message.avmFrontRearWheelRespEnum !== 0) {
      obj.avmFrontRearWheelRespEnum = Math.round(message.avmFrontRearWheelRespEnum);
    }
    if (message.apa360ButtonStsEnum !== 0) {
      obj.apa360ButtonStsEnum = Math.round(message.apa360ButtonStsEnum);
    }
    if (message.apaSettingsRespEnum !== 0) {
      obj.apaSettingsRespEnum = Math.round(message.apaSettingsRespEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AvmPadRespone>, I>>(base?: I): AvmPadRespone {
    return AvmPadRespone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AvmPadRespone>, I>>(object: I): AvmPadRespone {
    const message = createBaseAvmPadRespone();
    message.avmChannelButtonRespEnum = object.avmChannelButtonRespEnum ?? 0;
    message.avmFrontRearWheelRespEnum = object.avmFrontRearWheelRespEnum ?? 0;
    message.apa360ButtonStsEnum = object.apa360ButtonStsEnum ?? 0;
    message.apaSettingsRespEnum = object.apaSettingsRespEnum ?? 0;
    return message;
  },
};

function createBaseAutoDriveInfo(): AutoDriveInfo {
  return { trajectory: undefined };
}

export const AutoDriveInfo: MessageFns<AutoDriveInfo> = {
  encode(message: AutoDriveInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trajectory !== undefined) {
      VehicleTrajectory.encode(message.trajectory, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoDriveInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoDriveInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trajectory = VehicleTrajectory.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoDriveInfo {
    return { trajectory: isSet(object.trajectory) ? VehicleTrajectory.fromJSON(object.trajectory) : undefined };
  },

  toJSON(message: AutoDriveInfo): unknown {
    const obj: any = {};
    if (message.trajectory !== undefined) {
      obj.trajectory = VehicleTrajectory.toJSON(message.trajectory);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AutoDriveInfo>, I>>(base?: I): AutoDriveInfo {
    return AutoDriveInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AutoDriveInfo>, I>>(object: I): AutoDriveInfo {
    const message = createBaseAutoDriveInfo();
    message.trajectory = (object.trajectory !== undefined && object.trajectory !== null)
      ? VehicleTrajectory.fromPartial(object.trajectory)
      : undefined;
    return message;
  },
};

function createBaseOdometry(): Odometry {
  return {
    pose: undefined,
    statusBits: 0,
    sourceBits: 0,
    twist: undefined,
    accelaration: undefined,
    chassisDiagBits: 0,
    imuDiagBits: 0,
    internalSignalList: [],
  };
}

export const Odometry: MessageFns<Odometry> = {
  encode(message: Odometry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pose !== undefined) {
      Pose.encode(message.pose, writer.uint32(10).fork()).join();
    }
    if (message.statusBits !== 0) {
      writer.uint32(16).uint32(message.statusBits);
    }
    if (message.sourceBits !== 0) {
      writer.uint32(24).uint32(message.sourceBits);
    }
    if (message.twist !== undefined) {
      Twist.encode(message.twist, writer.uint32(34).fork()).join();
    }
    if (message.accelaration !== undefined) {
      Acceleration.encode(message.accelaration, writer.uint32(42).fork()).join();
    }
    if (message.chassisDiagBits !== 0) {
      writer.uint32(48).uint32(message.chassisDiagBits);
    }
    if (message.imuDiagBits !== 0) {
      writer.uint32(56).uint32(message.imuDiagBits);
    }
    writer.uint32(66).fork();
    for (const v of message.internalSignalList) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Odometry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOdometry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pose = Pose.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.statusBits = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sourceBits = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.twist = Twist.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.accelaration = Acceleration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.chassisDiagBits = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.imuDiagBits = reader.uint32();
          continue;
        }
        case 8: {
          if (tag === 69) {
            message.internalSignalList.push(reader.float());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.internalSignalList.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Odometry {
    return {
      pose: isSet(object.pose) ? Pose.fromJSON(object.pose) : undefined,
      statusBits: isSet(object.statusBits) ? globalThis.Number(object.statusBits) : 0,
      sourceBits: isSet(object.sourceBits) ? globalThis.Number(object.sourceBits) : 0,
      twist: isSet(object.twist) ? Twist.fromJSON(object.twist) : undefined,
      accelaration: isSet(object.accelaration) ? Acceleration.fromJSON(object.accelaration) : undefined,
      chassisDiagBits: isSet(object.chassisDiagBits) ? globalThis.Number(object.chassisDiagBits) : 0,
      imuDiagBits: isSet(object.imuDiagBits) ? globalThis.Number(object.imuDiagBits) : 0,
      internalSignalList: globalThis.Array.isArray(object?.internalSignalList)
        ? object.internalSignalList.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: Odometry): unknown {
    const obj: any = {};
    if (message.pose !== undefined) {
      obj.pose = Pose.toJSON(message.pose);
    }
    if (message.statusBits !== 0) {
      obj.statusBits = Math.round(message.statusBits);
    }
    if (message.sourceBits !== 0) {
      obj.sourceBits = Math.round(message.sourceBits);
    }
    if (message.twist !== undefined) {
      obj.twist = Twist.toJSON(message.twist);
    }
    if (message.accelaration !== undefined) {
      obj.accelaration = Acceleration.toJSON(message.accelaration);
    }
    if (message.chassisDiagBits !== 0) {
      obj.chassisDiagBits = Math.round(message.chassisDiagBits);
    }
    if (message.imuDiagBits !== 0) {
      obj.imuDiagBits = Math.round(message.imuDiagBits);
    }
    if (message.internalSignalList?.length) {
      obj.internalSignalList = message.internalSignalList;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Odometry>, I>>(base?: I): Odometry {
    return Odometry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Odometry>, I>>(object: I): Odometry {
    const message = createBaseOdometry();
    message.pose = (object.pose !== undefined && object.pose !== null) ? Pose.fromPartial(object.pose) : undefined;
    message.statusBits = object.statusBits ?? 0;
    message.sourceBits = object.sourceBits ?? 0;
    message.twist = (object.twist !== undefined && object.twist !== null) ? Twist.fromPartial(object.twist) : undefined;
    message.accelaration = (object.accelaration !== undefined && object.accelaration !== null)
      ? Acceleration.fromPartial(object.accelaration)
      : undefined;
    message.chassisDiagBits = object.chassisDiagBits ?? 0;
    message.imuDiagBits = object.imuDiagBits ?? 0;
    message.internalSignalList = object.internalSignalList?.map((e) => e) || [];
    return message;
  },
};

function createBaseTwist(): Twist {
  return { linear: undefined, angular: undefined };
}

export const Twist: MessageFns<Twist> = {
  encode(message: Twist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.linear !== undefined) {
      Vector3f.encode(message.linear, writer.uint32(10).fork()).join();
    }
    if (message.angular !== undefined) {
      Vector3f.encode(message.angular, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Twist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTwist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.linear = Vector3f.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.angular = Vector3f.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Twist {
    return {
      linear: isSet(object.linear) ? Vector3f.fromJSON(object.linear) : undefined,
      angular: isSet(object.angular) ? Vector3f.fromJSON(object.angular) : undefined,
    };
  },

  toJSON(message: Twist): unknown {
    const obj: any = {};
    if (message.linear !== undefined) {
      obj.linear = Vector3f.toJSON(message.linear);
    }
    if (message.angular !== undefined) {
      obj.angular = Vector3f.toJSON(message.angular);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Twist>, I>>(base?: I): Twist {
    return Twist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Twist>, I>>(object: I): Twist {
    const message = createBaseTwist();
    message.linear = (object.linear !== undefined && object.linear !== null)
      ? Vector3f.fromPartial(object.linear)
      : undefined;
    message.angular = (object.angular !== undefined && object.angular !== null)
      ? Vector3f.fromPartial(object.angular)
      : undefined;
    return message;
  },
};

function createBaseAcceleration(): Acceleration {
  return { accelaration: undefined };
}

export const Acceleration: MessageFns<Acceleration> = {
  encode(message: Acceleration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accelaration !== undefined) {
      Vector3f.encode(message.accelaration, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Acceleration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accelaration = Vector3f.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Acceleration {
    return { accelaration: isSet(object.accelaration) ? Vector3f.fromJSON(object.accelaration) : undefined };
  },

  toJSON(message: Acceleration): unknown {
    const obj: any = {};
    if (message.accelaration !== undefined) {
      obj.accelaration = Vector3f.toJSON(message.accelaration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Acceleration>, I>>(base?: I): Acceleration {
    return Acceleration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Acceleration>, I>>(object: I): Acceleration {
    const message = createBaseAcceleration();
    message.accelaration = (object.accelaration !== undefined && object.accelaration !== null)
      ? Vector3f.fromPartial(object.accelaration)
      : undefined;
    return message;
  },
};

function createBaseVector3f(): Vector3f {
  return { x: 0, y: 0, z: 0 };
}

export const Vector3f: MessageFns<Vector3f> = {
  encode(message: Vector3f, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vector3f {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVector3f();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vector3f {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: Vector3f): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vector3f>, I>>(base?: I): Vector3f {
    return Vector3f.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vector3f>, I>>(object: I): Vector3f {
    const message = createBaseVector3f();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseDrivableArea(): DrivableArea {
  return { originXM: 0, originYM: 0, data: [] };
}

export const DrivableArea: MessageFns<DrivableArea> = {
  encode(message: DrivableArea, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originXM !== 0) {
      writer.uint32(13).float(message.originXM);
    }
    if (message.originYM !== 0) {
      writer.uint32(21).float(message.originYM);
    }
    writer.uint32(26).fork();
    for (const v of message.data) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrivableArea {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrivableArea();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.originXM = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.originYM = reader.float();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.data.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.data.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrivableArea {
    return {
      originXM: isSet(object.originXM) ? globalThis.Number(object.originXM) : 0,
      originYM: isSet(object.originYM) ? globalThis.Number(object.originYM) : 0,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: DrivableArea): unknown {
    const obj: any = {};
    if (message.originXM !== 0) {
      obj.originXM = message.originXM;
    }
    if (message.originYM !== 0) {
      obj.originYM = message.originYM;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrivableArea>, I>>(base?: I): DrivableArea {
    return DrivableArea.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrivableArea>, I>>(object: I): DrivableArea {
    const message = createBaseDrivableArea();
    message.originXM = object.originXM ?? 0;
    message.originYM = object.originYM ?? 0;
    message.data = object.data?.map((e) => e) || [];
    return message;
  },
};

function createBaseLandMarkers2(): LandMarkers2 {
  return { numOfTrafficLandmarkers: 0, landMarkersList: [] };
}

export const LandMarkers2: MessageFns<LandMarkers2> = {
  encode(message: LandMarkers2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numOfTrafficLandmarkers !== 0) {
      writer.uint32(8).uint32(message.numOfTrafficLandmarkers);
    }
    for (const v of message.landMarkersList) {
      LandMarker2.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandMarkers2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandMarkers2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numOfTrafficLandmarkers = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.landMarkersList.push(LandMarker2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandMarkers2 {
    return {
      numOfTrafficLandmarkers: isSet(object.numOfTrafficLandmarkers)
        ? globalThis.Number(object.numOfTrafficLandmarkers)
        : 0,
      landMarkersList: globalThis.Array.isArray(object?.landMarkersList)
        ? object.landMarkersList.map((e: any) => LandMarker2.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LandMarkers2): unknown {
    const obj: any = {};
    if (message.numOfTrafficLandmarkers !== 0) {
      obj.numOfTrafficLandmarkers = Math.round(message.numOfTrafficLandmarkers);
    }
    if (message.landMarkersList?.length) {
      obj.landMarkersList = message.landMarkersList.map((e) => LandMarker2.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandMarkers2>, I>>(base?: I): LandMarkers2 {
    return LandMarkers2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandMarkers2>, I>>(object: I): LandMarkers2 {
    const message = createBaseLandMarkers2();
    message.numOfTrafficLandmarkers = object.numOfTrafficLandmarkers ?? 0;
    message.landMarkersList = object.landMarkersList?.map((e) => LandMarker2.fromPartial(e)) || [];
    return message;
  },
};

function createBaseParkingSignals(): ParkingSignals {
  return {
    parkingSlotId: 0,
    hpaMapId: 0,
    hpaDeleteMapIp: 0,
    apaParkModeEnum: 0,
    parkInTypeEnum: 0,
    hpaParkInTypeEnum: 0,
    apaParkInReqEnum: 0,
    parkOutDirectionReqEnum: 0,
    apaSpdTypeReqEnum: 0,
    slotMatchedStsEnum: 0,
    apaSelfSelect: undefined,
    leftMirrorStsEnum: 0,
    rightMirrorStsEnum: 0,
  };
}

export const ParkingSignals: MessageFns<ParkingSignals> = {
  encode(message: ParkingSignals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parkingSlotId !== 0) {
      writer.uint32(8).uint32(message.parkingSlotId);
    }
    if (message.hpaMapId !== 0) {
      writer.uint32(16).uint32(message.hpaMapId);
    }
    if (message.hpaDeleteMapIp !== 0) {
      writer.uint32(24).uint32(message.hpaDeleteMapIp);
    }
    if (message.apaParkModeEnum !== 0) {
      writer.uint32(32).uint32(message.apaParkModeEnum);
    }
    if (message.parkInTypeEnum !== 0) {
      writer.uint32(40).uint32(message.parkInTypeEnum);
    }
    if (message.hpaParkInTypeEnum !== 0) {
      writer.uint32(48).uint32(message.hpaParkInTypeEnum);
    }
    if (message.apaParkInReqEnum !== 0) {
      writer.uint32(56).uint32(message.apaParkInReqEnum);
    }
    if (message.parkOutDirectionReqEnum !== 0) {
      writer.uint32(64).uint32(message.parkOutDirectionReqEnum);
    }
    if (message.apaSpdTypeReqEnum !== 0) {
      writer.uint32(72).uint32(message.apaSpdTypeReqEnum);
    }
    if (message.slotMatchedStsEnum !== 0) {
      writer.uint32(80).uint32(message.slotMatchedStsEnum);
    }
    if (message.apaSelfSelect !== undefined) {
      ApaSelfSelect.encode(message.apaSelfSelect, writer.uint32(90).fork()).join();
    }
    if (message.leftMirrorStsEnum !== 0) {
      writer.uint32(96).uint32(message.leftMirrorStsEnum);
    }
    if (message.rightMirrorStsEnum !== 0) {
      writer.uint32(104).uint32(message.rightMirrorStsEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParkingSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParkingSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.parkingSlotId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hpaMapId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hpaDeleteMapIp = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.apaParkModeEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.parkInTypeEnum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.hpaParkInTypeEnum = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.apaParkInReqEnum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.parkOutDirectionReqEnum = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.apaSpdTypeReqEnum = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.slotMatchedStsEnum = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.apaSelfSelect = ApaSelfSelect.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.leftMirrorStsEnum = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.rightMirrorStsEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParkingSignals {
    return {
      parkingSlotId: isSet(object.parkingSlotId) ? globalThis.Number(object.parkingSlotId) : 0,
      hpaMapId: isSet(object.hpaMapId) ? globalThis.Number(object.hpaMapId) : 0,
      hpaDeleteMapIp: isSet(object.hpaDeleteMapIp) ? globalThis.Number(object.hpaDeleteMapIp) : 0,
      apaParkModeEnum: isSet(object.apaParkModeEnum) ? globalThis.Number(object.apaParkModeEnum) : 0,
      parkInTypeEnum: isSet(object.parkInTypeEnum) ? globalThis.Number(object.parkInTypeEnum) : 0,
      hpaParkInTypeEnum: isSet(object.hpaParkInTypeEnum) ? globalThis.Number(object.hpaParkInTypeEnum) : 0,
      apaParkInReqEnum: isSet(object.apaParkInReqEnum) ? globalThis.Number(object.apaParkInReqEnum) : 0,
      parkOutDirectionReqEnum: isSet(object.parkOutDirectionReqEnum)
        ? globalThis.Number(object.parkOutDirectionReqEnum)
        : 0,
      apaSpdTypeReqEnum: isSet(object.apaSpdTypeReqEnum) ? globalThis.Number(object.apaSpdTypeReqEnum) : 0,
      slotMatchedStsEnum: isSet(object.slotMatchedStsEnum) ? globalThis.Number(object.slotMatchedStsEnum) : 0,
      apaSelfSelect: isSet(object.apaSelfSelect) ? ApaSelfSelect.fromJSON(object.apaSelfSelect) : undefined,
      leftMirrorStsEnum: isSet(object.leftMirrorStsEnum) ? globalThis.Number(object.leftMirrorStsEnum) : 0,
      rightMirrorStsEnum: isSet(object.rightMirrorStsEnum) ? globalThis.Number(object.rightMirrorStsEnum) : 0,
    };
  },

  toJSON(message: ParkingSignals): unknown {
    const obj: any = {};
    if (message.parkingSlotId !== 0) {
      obj.parkingSlotId = Math.round(message.parkingSlotId);
    }
    if (message.hpaMapId !== 0) {
      obj.hpaMapId = Math.round(message.hpaMapId);
    }
    if (message.hpaDeleteMapIp !== 0) {
      obj.hpaDeleteMapIp = Math.round(message.hpaDeleteMapIp);
    }
    if (message.apaParkModeEnum !== 0) {
      obj.apaParkModeEnum = Math.round(message.apaParkModeEnum);
    }
    if (message.parkInTypeEnum !== 0) {
      obj.parkInTypeEnum = Math.round(message.parkInTypeEnum);
    }
    if (message.hpaParkInTypeEnum !== 0) {
      obj.hpaParkInTypeEnum = Math.round(message.hpaParkInTypeEnum);
    }
    if (message.apaParkInReqEnum !== 0) {
      obj.apaParkInReqEnum = Math.round(message.apaParkInReqEnum);
    }
    if (message.parkOutDirectionReqEnum !== 0) {
      obj.parkOutDirectionReqEnum = Math.round(message.parkOutDirectionReqEnum);
    }
    if (message.apaSpdTypeReqEnum !== 0) {
      obj.apaSpdTypeReqEnum = Math.round(message.apaSpdTypeReqEnum);
    }
    if (message.slotMatchedStsEnum !== 0) {
      obj.slotMatchedStsEnum = Math.round(message.slotMatchedStsEnum);
    }
    if (message.apaSelfSelect !== undefined) {
      obj.apaSelfSelect = ApaSelfSelect.toJSON(message.apaSelfSelect);
    }
    if (message.leftMirrorStsEnum !== 0) {
      obj.leftMirrorStsEnum = Math.round(message.leftMirrorStsEnum);
    }
    if (message.rightMirrorStsEnum !== 0) {
      obj.rightMirrorStsEnum = Math.round(message.rightMirrorStsEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParkingSignals>, I>>(base?: I): ParkingSignals {
    return ParkingSignals.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParkingSignals>, I>>(object: I): ParkingSignals {
    const message = createBaseParkingSignals();
    message.parkingSlotId = object.parkingSlotId ?? 0;
    message.hpaMapId = object.hpaMapId ?? 0;
    message.hpaDeleteMapIp = object.hpaDeleteMapIp ?? 0;
    message.apaParkModeEnum = object.apaParkModeEnum ?? 0;
    message.parkInTypeEnum = object.parkInTypeEnum ?? 0;
    message.hpaParkInTypeEnum = object.hpaParkInTypeEnum ?? 0;
    message.apaParkInReqEnum = object.apaParkInReqEnum ?? 0;
    message.parkOutDirectionReqEnum = object.parkOutDirectionReqEnum ?? 0;
    message.apaSpdTypeReqEnum = object.apaSpdTypeReqEnum ?? 0;
    message.slotMatchedStsEnum = object.slotMatchedStsEnum ?? 0;
    message.apaSelfSelect = (object.apaSelfSelect !== undefined && object.apaSelfSelect !== null)
      ? ApaSelfSelect.fromPartial(object.apaSelfSelect)
      : undefined;
    message.leftMirrorStsEnum = object.leftMirrorStsEnum ?? 0;
    message.rightMirrorStsEnum = object.rightMirrorStsEnum ?? 0;
    return message;
  },
};

function createBaseApaSelfSelect(): ApaSelfSelect {
  return {
    slotTypeEnum: 0,
    slotLocationEnum: 0,
    apaSelfSelectPoint0: undefined,
    apaSelfSelectPoint1: undefined,
    apaSelfSelectPoint2: undefined,
    apaSelfSelectPoint3: undefined,
    apaSelfSelectSlotAngleDeg: 0,
    apaSelfSelectSlotXM: 0,
    apaSelfSelectSlotYM: 0,
    apaSelfSelectSlotLengthM: 0,
    apaSelfSelectSlotWidthM: 0,
  };
}

export const ApaSelfSelect: MessageFns<ApaSelfSelect> = {
  encode(message: ApaSelfSelect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slotTypeEnum !== 0) {
      writer.uint32(8).uint32(message.slotTypeEnum);
    }
    if (message.slotLocationEnum !== 0) {
      writer.uint32(16).uint32(message.slotLocationEnum);
    }
    if (message.apaSelfSelectPoint0 !== undefined) {
      Point3f.encode(message.apaSelfSelectPoint0, writer.uint32(26).fork()).join();
    }
    if (message.apaSelfSelectPoint1 !== undefined) {
      Point3f.encode(message.apaSelfSelectPoint1, writer.uint32(34).fork()).join();
    }
    if (message.apaSelfSelectPoint2 !== undefined) {
      Point3f.encode(message.apaSelfSelectPoint2, writer.uint32(42).fork()).join();
    }
    if (message.apaSelfSelectPoint3 !== undefined) {
      Point3f.encode(message.apaSelfSelectPoint3, writer.uint32(50).fork()).join();
    }
    if (message.apaSelfSelectSlotAngleDeg !== 0) {
      writer.uint32(61).float(message.apaSelfSelectSlotAngleDeg);
    }
    if (message.apaSelfSelectSlotXM !== 0) {
      writer.uint32(69).float(message.apaSelfSelectSlotXM);
    }
    if (message.apaSelfSelectSlotYM !== 0) {
      writer.uint32(77).float(message.apaSelfSelectSlotYM);
    }
    if (message.apaSelfSelectSlotLengthM !== 0) {
      writer.uint32(85).float(message.apaSelfSelectSlotLengthM);
    }
    if (message.apaSelfSelectSlotWidthM !== 0) {
      writer.uint32(93).float(message.apaSelfSelectSlotWidthM);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApaSelfSelect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApaSelfSelect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slotTypeEnum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.slotLocationEnum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apaSelfSelectPoint0 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.apaSelfSelectPoint1 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.apaSelfSelectPoint2 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.apaSelfSelectPoint3 = Point3f.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.apaSelfSelectSlotAngleDeg = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.apaSelfSelectSlotXM = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.apaSelfSelectSlotYM = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.apaSelfSelectSlotLengthM = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.apaSelfSelectSlotWidthM = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApaSelfSelect {
    return {
      slotTypeEnum: isSet(object.slotTypeEnum) ? globalThis.Number(object.slotTypeEnum) : 0,
      slotLocationEnum: isSet(object.slotLocationEnum) ? globalThis.Number(object.slotLocationEnum) : 0,
      apaSelfSelectPoint0: isSet(object.apaSelfSelectPoint0) ? Point3f.fromJSON(object.apaSelfSelectPoint0) : undefined,
      apaSelfSelectPoint1: isSet(object.apaSelfSelectPoint1) ? Point3f.fromJSON(object.apaSelfSelectPoint1) : undefined,
      apaSelfSelectPoint2: isSet(object.apaSelfSelectPoint2) ? Point3f.fromJSON(object.apaSelfSelectPoint2) : undefined,
      apaSelfSelectPoint3: isSet(object.apaSelfSelectPoint3) ? Point3f.fromJSON(object.apaSelfSelectPoint3) : undefined,
      apaSelfSelectSlotAngleDeg: isSet(object.apaSelfSelectSlotAngleDeg)
        ? globalThis.Number(object.apaSelfSelectSlotAngleDeg)
        : 0,
      apaSelfSelectSlotXM: isSet(object.apaSelfSelectSlotXM) ? globalThis.Number(object.apaSelfSelectSlotXM) : 0,
      apaSelfSelectSlotYM: isSet(object.apaSelfSelectSlotYM) ? globalThis.Number(object.apaSelfSelectSlotYM) : 0,
      apaSelfSelectSlotLengthM: isSet(object.apaSelfSelectSlotLengthM)
        ? globalThis.Number(object.apaSelfSelectSlotLengthM)
        : 0,
      apaSelfSelectSlotWidthM: isSet(object.apaSelfSelectSlotWidthM)
        ? globalThis.Number(object.apaSelfSelectSlotWidthM)
        : 0,
    };
  },

  toJSON(message: ApaSelfSelect): unknown {
    const obj: any = {};
    if (message.slotTypeEnum !== 0) {
      obj.slotTypeEnum = Math.round(message.slotTypeEnum);
    }
    if (message.slotLocationEnum !== 0) {
      obj.slotLocationEnum = Math.round(message.slotLocationEnum);
    }
    if (message.apaSelfSelectPoint0 !== undefined) {
      obj.apaSelfSelectPoint0 = Point3f.toJSON(message.apaSelfSelectPoint0);
    }
    if (message.apaSelfSelectPoint1 !== undefined) {
      obj.apaSelfSelectPoint1 = Point3f.toJSON(message.apaSelfSelectPoint1);
    }
    if (message.apaSelfSelectPoint2 !== undefined) {
      obj.apaSelfSelectPoint2 = Point3f.toJSON(message.apaSelfSelectPoint2);
    }
    if (message.apaSelfSelectPoint3 !== undefined) {
      obj.apaSelfSelectPoint3 = Point3f.toJSON(message.apaSelfSelectPoint3);
    }
    if (message.apaSelfSelectSlotAngleDeg !== 0) {
      obj.apaSelfSelectSlotAngleDeg = message.apaSelfSelectSlotAngleDeg;
    }
    if (message.apaSelfSelectSlotXM !== 0) {
      obj.apaSelfSelectSlotXM = message.apaSelfSelectSlotXM;
    }
    if (message.apaSelfSelectSlotYM !== 0) {
      obj.apaSelfSelectSlotYM = message.apaSelfSelectSlotYM;
    }
    if (message.apaSelfSelectSlotLengthM !== 0) {
      obj.apaSelfSelectSlotLengthM = message.apaSelfSelectSlotLengthM;
    }
    if (message.apaSelfSelectSlotWidthM !== 0) {
      obj.apaSelfSelectSlotWidthM = message.apaSelfSelectSlotWidthM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApaSelfSelect>, I>>(base?: I): ApaSelfSelect {
    return ApaSelfSelect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApaSelfSelect>, I>>(object: I): ApaSelfSelect {
    const message = createBaseApaSelfSelect();
    message.slotTypeEnum = object.slotTypeEnum ?? 0;
    message.slotLocationEnum = object.slotLocationEnum ?? 0;
    message.apaSelfSelectPoint0 = (object.apaSelfSelectPoint0 !== undefined && object.apaSelfSelectPoint0 !== null)
      ? Point3f.fromPartial(object.apaSelfSelectPoint0)
      : undefined;
    message.apaSelfSelectPoint1 = (object.apaSelfSelectPoint1 !== undefined && object.apaSelfSelectPoint1 !== null)
      ? Point3f.fromPartial(object.apaSelfSelectPoint1)
      : undefined;
    message.apaSelfSelectPoint2 = (object.apaSelfSelectPoint2 !== undefined && object.apaSelfSelectPoint2 !== null)
      ? Point3f.fromPartial(object.apaSelfSelectPoint2)
      : undefined;
    message.apaSelfSelectPoint3 = (object.apaSelfSelectPoint3 !== undefined && object.apaSelfSelectPoint3 !== null)
      ? Point3f.fromPartial(object.apaSelfSelectPoint3)
      : undefined;
    message.apaSelfSelectSlotAngleDeg = object.apaSelfSelectSlotAngleDeg ?? 0;
    message.apaSelfSelectSlotXM = object.apaSelfSelectSlotXM ?? 0;
    message.apaSelfSelectSlotYM = object.apaSelfSelectSlotYM ?? 0;
    message.apaSelfSelectSlotLengthM = object.apaSelfSelectSlotLengthM ?? 0;
    message.apaSelfSelectSlotWidthM = object.apaSelfSelectSlotWidthM ?? 0;
    return message;
  },
};

function createBaseTrajectoryOut(): TrajectoryOut {
  return { numTrajPts: 0, totalTrajLengthM: 0, targetSpeedMS: 0, targetSpeedReasonEnum: 0, trajPtsNum: 0, trajPts: [] };
}

export const TrajectoryOut: MessageFns<TrajectoryOut> = {
  encode(message: TrajectoryOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numTrajPts !== 0) {
      writer.uint32(8).uint32(message.numTrajPts);
    }
    if (message.totalTrajLengthM !== 0) {
      writer.uint32(21).float(message.totalTrajLengthM);
    }
    if (message.targetSpeedMS !== 0) {
      writer.uint32(29).float(message.targetSpeedMS);
    }
    if (message.targetSpeedReasonEnum !== 0) {
      writer.uint32(32).uint32(message.targetSpeedReasonEnum);
    }
    if (message.trajPtsNum !== 0) {
      writer.uint32(40).uint32(message.trajPtsNum);
    }
    for (const v of message.trajPts) {
      PathPoint.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrajectoryOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrajectoryOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numTrajPts = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.totalTrajLengthM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.targetSpeedMS = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.targetSpeedReasonEnum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.trajPtsNum = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trajPts.push(PathPoint.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrajectoryOut {
    return {
      numTrajPts: isSet(object.numTrajPts) ? globalThis.Number(object.numTrajPts) : 0,
      totalTrajLengthM: isSet(object.totalTrajLengthM) ? globalThis.Number(object.totalTrajLengthM) : 0,
      targetSpeedMS: isSet(object.targetSpeedMS) ? globalThis.Number(object.targetSpeedMS) : 0,
      targetSpeedReasonEnum: isSet(object.targetSpeedReasonEnum) ? globalThis.Number(object.targetSpeedReasonEnum) : 0,
      trajPtsNum: isSet(object.trajPtsNum) ? globalThis.Number(object.trajPtsNum) : 0,
      trajPts: globalThis.Array.isArray(object?.trajPts) ? object.trajPts.map((e: any) => PathPoint.fromJSON(e)) : [],
    };
  },

  toJSON(message: TrajectoryOut): unknown {
    const obj: any = {};
    if (message.numTrajPts !== 0) {
      obj.numTrajPts = Math.round(message.numTrajPts);
    }
    if (message.totalTrajLengthM !== 0) {
      obj.totalTrajLengthM = message.totalTrajLengthM;
    }
    if (message.targetSpeedMS !== 0) {
      obj.targetSpeedMS = message.targetSpeedMS;
    }
    if (message.targetSpeedReasonEnum !== 0) {
      obj.targetSpeedReasonEnum = Math.round(message.targetSpeedReasonEnum);
    }
    if (message.trajPtsNum !== 0) {
      obj.trajPtsNum = Math.round(message.trajPtsNum);
    }
    if (message.trajPts?.length) {
      obj.trajPts = message.trajPts.map((e) => PathPoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrajectoryOut>, I>>(base?: I): TrajectoryOut {
    return TrajectoryOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrajectoryOut>, I>>(object: I): TrajectoryOut {
    const message = createBaseTrajectoryOut();
    message.numTrajPts = object.numTrajPts ?? 0;
    message.totalTrajLengthM = object.totalTrajLengthM ?? 0;
    message.targetSpeedMS = object.targetSpeedMS ?? 0;
    message.targetSpeedReasonEnum = object.targetSpeedReasonEnum ?? 0;
    message.trajPtsNum = object.trajPtsNum ?? 0;
    message.trajPts = object.trajPts?.map((e) => PathPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBasePathPoint(): PathPoint {
  return {
    tS: 0,
    xM: 0,
    yM: 0,
    zM: 0,
    thetaRad: 0,
    kappaLM: 0,
    dkappaLM: 0,
    sM: 0,
    vMS: 0,
    aMS2: 0,
    daMS3: 0,
    gearEnum: 0,
  };
}

export const PathPoint: MessageFns<PathPoint> = {
  encode(message: PathPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tS !== 0) {
      writer.uint32(13).float(message.tS);
    }
    if (message.xM !== 0) {
      writer.uint32(21).float(message.xM);
    }
    if (message.yM !== 0) {
      writer.uint32(29).float(message.yM);
    }
    if (message.zM !== 0) {
      writer.uint32(37).float(message.zM);
    }
    if (message.thetaRad !== 0) {
      writer.uint32(45).float(message.thetaRad);
    }
    if (message.kappaLM !== 0) {
      writer.uint32(53).float(message.kappaLM);
    }
    if (message.dkappaLM !== 0) {
      writer.uint32(61).float(message.dkappaLM);
    }
    if (message.sM !== 0) {
      writer.uint32(69).float(message.sM);
    }
    if (message.vMS !== 0) {
      writer.uint32(77).float(message.vMS);
    }
    if (message.aMS2 !== 0) {
      writer.uint32(85).float(message.aMS2);
    }
    if (message.daMS3 !== 0) {
      writer.uint32(93).float(message.daMS3);
    }
    if (message.gearEnum !== 0) {
      writer.uint32(96).uint32(message.gearEnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.tS = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.xM = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.yM = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.zM = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.thetaRad = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.kappaLM = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.dkappaLM = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.sM = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.vMS = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.aMS2 = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.daMS3 = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.gearEnum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PathPoint {
    return {
      tS: isSet(object.tS) ? globalThis.Number(object.tS) : 0,
      xM: isSet(object.xM) ? globalThis.Number(object.xM) : 0,
      yM: isSet(object.yM) ? globalThis.Number(object.yM) : 0,
      zM: isSet(object.zM) ? globalThis.Number(object.zM) : 0,
      thetaRad: isSet(object.thetaRad) ? globalThis.Number(object.thetaRad) : 0,
      kappaLM: isSet(object.kappaLM) ? globalThis.Number(object.kappaLM) : 0,
      dkappaLM: isSet(object.dkappaLM) ? globalThis.Number(object.dkappaLM) : 0,
      sM: isSet(object.sM) ? globalThis.Number(object.sM) : 0,
      vMS: isSet(object.vMS) ? globalThis.Number(object.vMS) : 0,
      aMS2: isSet(object.aMS2) ? globalThis.Number(object.aMS2) : 0,
      daMS3: isSet(object.daMS3) ? globalThis.Number(object.daMS3) : 0,
      gearEnum: isSet(object.gearEnum) ? globalThis.Number(object.gearEnum) : 0,
    };
  },

  toJSON(message: PathPoint): unknown {
    const obj: any = {};
    if (message.tS !== 0) {
      obj.tS = message.tS;
    }
    if (message.xM !== 0) {
      obj.xM = message.xM;
    }
    if (message.yM !== 0) {
      obj.yM = message.yM;
    }
    if (message.zM !== 0) {
      obj.zM = message.zM;
    }
    if (message.thetaRad !== 0) {
      obj.thetaRad = message.thetaRad;
    }
    if (message.kappaLM !== 0) {
      obj.kappaLM = message.kappaLM;
    }
    if (message.dkappaLM !== 0) {
      obj.dkappaLM = message.dkappaLM;
    }
    if (message.sM !== 0) {
      obj.sM = message.sM;
    }
    if (message.vMS !== 0) {
      obj.vMS = message.vMS;
    }
    if (message.aMS2 !== 0) {
      obj.aMS2 = message.aMS2;
    }
    if (message.daMS3 !== 0) {
      obj.daMS3 = message.daMS3;
    }
    if (message.gearEnum !== 0) {
      obj.gearEnum = Math.round(message.gearEnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PathPoint>, I>>(base?: I): PathPoint {
    return PathPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathPoint>, I>>(object: I): PathPoint {
    const message = createBasePathPoint();
    message.tS = object.tS ?? 0;
    message.xM = object.xM ?? 0;
    message.yM = object.yM ?? 0;
    message.zM = object.zM ?? 0;
    message.thetaRad = object.thetaRad ?? 0;
    message.kappaLM = object.kappaLM ?? 0;
    message.dkappaLM = object.dkappaLM ?? 0;
    message.sM = object.sM ?? 0;
    message.vMS = object.vMS ?? 0;
    message.aMS2 = object.aMS2 ?? 0;
    message.daMS3 = object.daMS3 ?? 0;
    message.gearEnum = object.gearEnum ?? 0;
    return message;
  },
};

function createBaseUssPdcData(): UssPdcData {
  return {
    ussDistanceRrsMm: 0,
    ussDistanceRrMm: 0,
    ussDistanceRrmMm: 0,
    ussDistanceRlmMm: 0,
    ussDistanceRlMm: 0,
    ussDistanceRlsMm: 0,
    ussDistanceFrsMm: 0,
    ussDistanceFrMm: 0,
    ussDistanceFrmMm: 0,
    ussDistanceFlmMm: 0,
    ussDistanceFlMm: 0,
    ussDistanceFlsMm: 0,
  };
}

export const UssPdcData: MessageFns<UssPdcData> = {
  encode(message: UssPdcData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ussDistanceRrsMm !== 0) {
      writer.uint32(8).uint32(message.ussDistanceRrsMm);
    }
    if (message.ussDistanceRrMm !== 0) {
      writer.uint32(16).uint32(message.ussDistanceRrMm);
    }
    if (message.ussDistanceRrmMm !== 0) {
      writer.uint32(24).uint32(message.ussDistanceRrmMm);
    }
    if (message.ussDistanceRlmMm !== 0) {
      writer.uint32(32).uint32(message.ussDistanceRlmMm);
    }
    if (message.ussDistanceRlMm !== 0) {
      writer.uint32(40).uint32(message.ussDistanceRlMm);
    }
    if (message.ussDistanceRlsMm !== 0) {
      writer.uint32(48).uint32(message.ussDistanceRlsMm);
    }
    if (message.ussDistanceFrsMm !== 0) {
      writer.uint32(56).uint32(message.ussDistanceFrsMm);
    }
    if (message.ussDistanceFrMm !== 0) {
      writer.uint32(64).uint32(message.ussDistanceFrMm);
    }
    if (message.ussDistanceFrmMm !== 0) {
      writer.uint32(72).uint32(message.ussDistanceFrmMm);
    }
    if (message.ussDistanceFlmMm !== 0) {
      writer.uint32(80).uint32(message.ussDistanceFlmMm);
    }
    if (message.ussDistanceFlMm !== 0) {
      writer.uint32(88).uint32(message.ussDistanceFlMm);
    }
    if (message.ussDistanceFlsMm !== 0) {
      writer.uint32(96).uint32(message.ussDistanceFlsMm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UssPdcData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUssPdcData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ussDistanceRrsMm = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ussDistanceRrMm = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ussDistanceRrmMm = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ussDistanceRlmMm = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ussDistanceRlMm = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ussDistanceRlsMm = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ussDistanceFrsMm = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ussDistanceFrMm = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.ussDistanceFrmMm = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.ussDistanceFlmMm = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.ussDistanceFlMm = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.ussDistanceFlsMm = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UssPdcData {
    return {
      ussDistanceRrsMm: isSet(object.ussDistanceRrsMm) ? globalThis.Number(object.ussDistanceRrsMm) : 0,
      ussDistanceRrMm: isSet(object.ussDistanceRrMm) ? globalThis.Number(object.ussDistanceRrMm) : 0,
      ussDistanceRrmMm: isSet(object.ussDistanceRrmMm) ? globalThis.Number(object.ussDistanceRrmMm) : 0,
      ussDistanceRlmMm: isSet(object.ussDistanceRlmMm) ? globalThis.Number(object.ussDistanceRlmMm) : 0,
      ussDistanceRlMm: isSet(object.ussDistanceRlMm) ? globalThis.Number(object.ussDistanceRlMm) : 0,
      ussDistanceRlsMm: isSet(object.ussDistanceRlsMm) ? globalThis.Number(object.ussDistanceRlsMm) : 0,
      ussDistanceFrsMm: isSet(object.ussDistanceFrsMm) ? globalThis.Number(object.ussDistanceFrsMm) : 0,
      ussDistanceFrMm: isSet(object.ussDistanceFrMm) ? globalThis.Number(object.ussDistanceFrMm) : 0,
      ussDistanceFrmMm: isSet(object.ussDistanceFrmMm) ? globalThis.Number(object.ussDistanceFrmMm) : 0,
      ussDistanceFlmMm: isSet(object.ussDistanceFlmMm) ? globalThis.Number(object.ussDistanceFlmMm) : 0,
      ussDistanceFlMm: isSet(object.ussDistanceFlMm) ? globalThis.Number(object.ussDistanceFlMm) : 0,
      ussDistanceFlsMm: isSet(object.ussDistanceFlsMm) ? globalThis.Number(object.ussDistanceFlsMm) : 0,
    };
  },

  toJSON(message: UssPdcData): unknown {
    const obj: any = {};
    if (message.ussDistanceRrsMm !== 0) {
      obj.ussDistanceRrsMm = Math.round(message.ussDistanceRrsMm);
    }
    if (message.ussDistanceRrMm !== 0) {
      obj.ussDistanceRrMm = Math.round(message.ussDistanceRrMm);
    }
    if (message.ussDistanceRrmMm !== 0) {
      obj.ussDistanceRrmMm = Math.round(message.ussDistanceRrmMm);
    }
    if (message.ussDistanceRlmMm !== 0) {
      obj.ussDistanceRlmMm = Math.round(message.ussDistanceRlmMm);
    }
    if (message.ussDistanceRlMm !== 0) {
      obj.ussDistanceRlMm = Math.round(message.ussDistanceRlMm);
    }
    if (message.ussDistanceRlsMm !== 0) {
      obj.ussDistanceRlsMm = Math.round(message.ussDistanceRlsMm);
    }
    if (message.ussDistanceFrsMm !== 0) {
      obj.ussDistanceFrsMm = Math.round(message.ussDistanceFrsMm);
    }
    if (message.ussDistanceFrMm !== 0) {
      obj.ussDistanceFrMm = Math.round(message.ussDistanceFrMm);
    }
    if (message.ussDistanceFrmMm !== 0) {
      obj.ussDistanceFrmMm = Math.round(message.ussDistanceFrmMm);
    }
    if (message.ussDistanceFlmMm !== 0) {
      obj.ussDistanceFlmMm = Math.round(message.ussDistanceFlmMm);
    }
    if (message.ussDistanceFlMm !== 0) {
      obj.ussDistanceFlMm = Math.round(message.ussDistanceFlMm);
    }
    if (message.ussDistanceFlsMm !== 0) {
      obj.ussDistanceFlsMm = Math.round(message.ussDistanceFlsMm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UssPdcData>, I>>(base?: I): UssPdcData {
    return UssPdcData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UssPdcData>, I>>(object: I): UssPdcData {
    const message = createBaseUssPdcData();
    message.ussDistanceRrsMm = object.ussDistanceRrsMm ?? 0;
    message.ussDistanceRrMm = object.ussDistanceRrMm ?? 0;
    message.ussDistanceRrmMm = object.ussDistanceRrmMm ?? 0;
    message.ussDistanceRlmMm = object.ussDistanceRlmMm ?? 0;
    message.ussDistanceRlMm = object.ussDistanceRlMm ?? 0;
    message.ussDistanceRlsMm = object.ussDistanceRlsMm ?? 0;
    message.ussDistanceFrsMm = object.ussDistanceFrsMm ?? 0;
    message.ussDistanceFrMm = object.ussDistanceFrMm ?? 0;
    message.ussDistanceFrmMm = object.ussDistanceFrmMm ?? 0;
    message.ussDistanceFlmMm = object.ussDistanceFlmMm ?? 0;
    message.ussDistanceFlMm = object.ussDistanceFlMm ?? 0;
    message.ussDistanceFlsMm = object.ussDistanceFlsMm ?? 0;
    return message;
  },
};

function createBasePointCloud2(): PointCloud2 {
  return { height: 0, width: 0, fields: [], isBigendian: false, pointStep: 0, rowStep: 0, data: [], isDense: false };
}

export const PointCloud2: MessageFns<PointCloud2> = {
  encode(message: PointCloud2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(16).uint32(message.width);
    }
    for (const v of message.fields) {
      PointField.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.isBigendian !== false) {
      writer.uint32(32).bool(message.isBigendian);
    }
    if (message.pointStep !== 0) {
      writer.uint32(40).uint32(message.pointStep);
    }
    if (message.rowStep !== 0) {
      writer.uint32(48).uint32(message.rowStep);
    }
    writer.uint32(58).fork();
    for (const v of message.data) {
      writer.uint32(v);
    }
    writer.join();
    if (message.isDense !== false) {
      writer.uint32(64).bool(message.isDense);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointCloud2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointCloud2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fields.push(PointField.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isBigendian = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pointStep = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rowStep = reader.uint32();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.data.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.data.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isDense = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointCloud2 {
    return {
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => PointField.fromJSON(e)) : [],
      isBigendian: isSet(object.isBigendian) ? globalThis.Boolean(object.isBigendian) : false,
      pointStep: isSet(object.pointStep) ? globalThis.Number(object.pointStep) : 0,
      rowStep: isSet(object.rowStep) ? globalThis.Number(object.rowStep) : 0,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => globalThis.Number(e)) : [],
      isDense: isSet(object.isDense) ? globalThis.Boolean(object.isDense) : false,
    };
  },

  toJSON(message: PointCloud2): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => PointField.toJSON(e));
    }
    if (message.isBigendian !== false) {
      obj.isBigendian = message.isBigendian;
    }
    if (message.pointStep !== 0) {
      obj.pointStep = Math.round(message.pointStep);
    }
    if (message.rowStep !== 0) {
      obj.rowStep = Math.round(message.rowStep);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => Math.round(e));
    }
    if (message.isDense !== false) {
      obj.isDense = message.isDense;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PointCloud2>, I>>(base?: I): PointCloud2 {
    return PointCloud2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PointCloud2>, I>>(object: I): PointCloud2 {
    const message = createBasePointCloud2();
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    message.fields = object.fields?.map((e) => PointField.fromPartial(e)) || [];
    message.isBigendian = object.isBigendian ?? false;
    message.pointStep = object.pointStep ?? 0;
    message.rowStep = object.rowStep ?? 0;
    message.data = object.data?.map((e) => e) || [];
    message.isDense = object.isDense ?? false;
    return message;
  },
};

function createBasePointField(): PointField {
  return { name: "", offset: 0, datatype: 0, count: 0 };
}

export const PointField: MessageFns<PointField> = {
  encode(message: PointField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint32(message.offset);
    }
    if (message.datatype !== 0) {
      writer.uint32(24).uint32(message.datatype);
    }
    if (message.count !== 0) {
      writer.uint32(32).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.datatype = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      datatype: isSet(object.datatype) ? globalThis.Number(object.datatype) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: PointField): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.datatype !== 0) {
      obj.datatype = Math.round(message.datatype);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PointField>, I>>(base?: I): PointField {
    return PointField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PointField>, I>>(object: I): PointField {
    const message = createBasePointField();
    message.name = object.name ?? "";
    message.offset = object.offset ?? 0;
    message.datatype = object.datatype ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
